   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.process_hand_swap,"ax",@progbits
  11               	.global	process_hand_swap
  13               	process_hand_swap:
  14               	.LVL0:
  15               	.LFB17:
  16               		.file 1 "quantum/action.c"
   1:quantum/action.c **** /*
   2:quantum/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:quantum/action.c **** 
   4:quantum/action.c **** This program is free software: you can redistribute it and/or modify
   5:quantum/action.c **** it under the terms of the GNU General Public License as published by
   6:quantum/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:quantum/action.c **** (at your option) any later version.
   8:quantum/action.c **** 
   9:quantum/action.c **** This program is distributed in the hope that it will be useful,
  10:quantum/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:quantum/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:quantum/action.c **** GNU General Public License for more details.
  13:quantum/action.c **** 
  14:quantum/action.c **** You should have received a copy of the GNU General Public License
  15:quantum/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:quantum/action.c **** */
  17:quantum/action.c **** #include "host.h"
  18:quantum/action.c **** #include "keycode.h"
  19:quantum/action.c **** #include "keyboard.h"
  20:quantum/action.c **** #include "mousekey.h"
  21:quantum/action.c **** #include "command.h"
  22:quantum/action.c **** #include "led.h"
  23:quantum/action.c **** #include "action_layer.h"
  24:quantum/action.c **** #include "action_tapping.h"
  25:quantum/action.c **** #include "action_macro.h"
  26:quantum/action.c **** #include "action_util.h"
  27:quantum/action.c **** #include "action.h"
  28:quantum/action.c **** #include "wait.h"
  29:quantum/action.c **** 
  30:quantum/action.c **** #ifdef BACKLIGHT_ENABLE
  31:quantum/action.c **** #    include "backlight.h"
  32:quantum/action.c **** #endif
  33:quantum/action.c **** 
  34:quantum/action.c **** #ifdef DEBUG_ACTION
  35:quantum/action.c **** #    include "debug.h"
  36:quantum/action.c **** #else
  37:quantum/action.c **** #    include "nodebug.h"
  38:quantum/action.c **** #endif
  39:quantum/action.c **** 
  40:quantum/action.c **** #ifdef POINTING_DEVICE_ENABLE
  41:quantum/action.c **** #    include "pointing_device.h"
  42:quantum/action.c **** #endif
  43:quantum/action.c **** 
  44:quantum/action.c **** int tp_buttons;
  45:quantum/action.c **** 
  46:quantum/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
  47:quantum/action.c **** int retro_tapping_counter = 0;
  48:quantum/action.c **** #endif
  49:quantum/action.c **** 
  50:quantum/action.c **** #ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
  51:quantum/action.c **** __attribute__((weak)) bool get_ignore_mod_tap_interrupt(uint16_t keycode, keyrecord_t *record) { re
  52:quantum/action.c **** #endif
  53:quantum/action.c **** 
  54:quantum/action.c **** #ifdef RETRO_TAPPING_PER_KEY
  55:quantum/action.c **** __attribute__((weak)) bool get_retro_tapping(uint16_t keycode, keyrecord_t *record) { return false;
  56:quantum/action.c **** #endif
  57:quantum/action.c **** 
  58:quantum/action.c **** __attribute__((weak)) bool pre_process_record_quantum(keyrecord_t *record) { return true; }
  59:quantum/action.c **** 
  60:quantum/action.c **** #ifndef TAP_CODE_DELAY
  61:quantum/action.c **** #    define TAP_CODE_DELAY 0
  62:quantum/action.c **** #endif
  63:quantum/action.c **** #ifndef TAP_HOLD_CAPS_DELAY
  64:quantum/action.c **** #    define TAP_HOLD_CAPS_DELAY 80
  65:quantum/action.c **** #endif
  66:quantum/action.c **** /** \brief Called to execute an action.
  67:quantum/action.c ****  *
  68:quantum/action.c ****  * FIXME: Needs documentation.
  69:quantum/action.c ****  */
  70:quantum/action.c **** void action_exec(keyevent_t event) {
  71:quantum/action.c ****     if (!IS_NOEVENT(event)) {
  72:quantum/action.c ****         dprint("\n---- action_exec: start -----\n");
  73:quantum/action.c ****         dprint("EVENT: ");
  74:quantum/action.c ****         debug_event(event);
  75:quantum/action.c ****         dprintln();
  76:quantum/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
  77:quantum/action.c ****         retro_tapping_counter++;
  78:quantum/action.c **** #endif
  79:quantum/action.c ****     }
  80:quantum/action.c **** 
  81:quantum/action.c ****     if (event.pressed) {
  82:quantum/action.c ****         // clear the potential weak mods left by previously pressed keys
  83:quantum/action.c ****         clear_weak_mods();
  84:quantum/action.c ****     }
  85:quantum/action.c **** 
  86:quantum/action.c **** #ifdef SWAP_HANDS_ENABLE
  87:quantum/action.c ****     if (!IS_NOEVENT(event)) {
  88:quantum/action.c ****         process_hand_swap(&event);
  89:quantum/action.c ****     }
  90:quantum/action.c **** #endif
  91:quantum/action.c **** 
  92:quantum/action.c ****     keyrecord_t record = {.event = event};
  93:quantum/action.c **** 
  94:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
  95:quantum/action.c **** #    if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  96:quantum/action.c ****     if (has_oneshot_layer_timed_out()) {
  97:quantum/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  98:quantum/action.c ****     }
  99:quantum/action.c ****     if (has_oneshot_mods_timed_out()) {
 100:quantum/action.c ****         clear_oneshot_mods();
 101:quantum/action.c ****     }
 102:quantum/action.c **** #        ifdef SWAP_HANDS_ENABLE
 103:quantum/action.c ****     if (has_oneshot_swaphands_timed_out()) {
 104:quantum/action.c ****         clear_oneshot_swaphands();
 105:quantum/action.c ****     }
 106:quantum/action.c **** #        endif
 107:quantum/action.c **** #    endif
 108:quantum/action.c **** #endif
 109:quantum/action.c **** 
 110:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 111:quantum/action.c ****     if (IS_NOEVENT(record.event) || pre_process_record_quantum(&record)) {
 112:quantum/action.c ****         action_tapping_process(record);
 113:quantum/action.c ****     }
 114:quantum/action.c **** #else
 115:quantum/action.c ****     if (IS_NOEVENT(record.event) || pre_process_record_quantum(&record)) {
 116:quantum/action.c ****         process_record(&record);
 117:quantum/action.c ****     }
 118:quantum/action.c ****     if (!IS_NOEVENT(record.event)) {
 119:quantum/action.c ****         dprint("processed: ");
 120:quantum/action.c ****         debug_record(record);
 121:quantum/action.c ****         dprintln();
 122:quantum/action.c ****     }
 123:quantum/action.c **** #endif
 124:quantum/action.c **** }
 125:quantum/action.c **** 
 126:quantum/action.c **** #ifdef SWAP_HANDS_ENABLE
 127:quantum/action.c **** bool swap_hands = false;
 128:quantum/action.c **** bool swap_held  = false;
 129:quantum/action.c **** 
 130:quantum/action.c **** /** \brief Process Hand Swap
 131:quantum/action.c ****  *
 132:quantum/action.c ****  * FIXME: Needs documentation.
 133:quantum/action.c ****  */
 134:quantum/action.c **** void process_hand_swap(keyevent_t *event) {
  17               		.loc 1 134 43 view -0
  18               		.cfi_startproc
  19               		.loc 1 134 43 is_stmt 0 view .LVU1
  20 0000 CF93      		push r28
  21               	.LCFI0:
  22               		.cfi_def_cfa_offset 3
  23               		.cfi_offset 28, -2
  24 0002 DF93      		push r29
  25               	.LCFI1:
  26               		.cfi_def_cfa_offset 4
  27               		.cfi_offset 29, -3
  28               	/* prologue: function */
  29               	/* frame size = 0 */
  30               	/* stack size = 2 */
  31               	.L__stack_usage = 2
  32 0004 EC01      		movw r28,r24
 135:quantum/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
  33               		.loc 1 135 5 is_stmt 1 view .LVU2
 136:quantum/action.c **** 
 137:quantum/action.c ****     keypos_t         pos     = event->key;
  34               		.loc 1 137 5 view .LVU3
  35               		.loc 1 137 22 is_stmt 0 view .LVU4
  36 0006 8881      		ld r24,Y
  37               	.LVL1:
  38               		.loc 1 137 22 view .LVU5
  39 0008 5981      		ldd r21,Y+1
  40               	.LVL2:
 138:quantum/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1 << pos.col;
  41               		.loc 1 138 5 is_stmt 1 view .LVU6
  42               		.loc 1 138 52 is_stmt 0 view .LVU7
  43 000a 21E0      		ldi r18,lo8(1)
  44 000c 30E0      		ldi r19,0
  45 000e 082E      		mov r0,r24
  46 0010 00C0      		rjmp 2f
  47               		1:
  48 0012 220F      		lsl r18
  49               		2:
  50 0014 0A94      		dec r0
  51 0016 02F4      		brpl 1b
  52               	.LVL3:
 139:quantum/action.c ****     bool             do_swap = event->pressed ? swap_hands : swap_state[pos.row] & (col_bit);
  53               		.loc 1 139 5 is_stmt 1 view .LVU8
  54               		.loc 1 139 76 is_stmt 0 view .LVU9
  55 0018 A52F      		mov r26,r21
  56 001a B0E0      		ldi r27,0
  57               		.loc 1 139 72 view .LVU10
  58 001c A050      		subi r26,lo8(-(swap_state.0))
  59 001e B040      		sbci r27,hi8(-(swap_state.0))
  60 0020 4C91      		ld r20,X
  61               		.loc 1 139 60 view .LVU11
  62 0022 9A81      		ldd r25,Y+2
  63 0024 9923      		tst r25
  64 0026 01F0      		breq .L2
  65               	.LVL4:
 140:quantum/action.c **** 
 141:quantum/action.c ****     if (do_swap) {
  66               		.loc 1 141 5 is_stmt 1 discriminator 1 view .LVU12
  67               		.loc 1 141 8 is_stmt 0 discriminator 1 view .LVU13
  68 0028 9091 0000 		lds r25,swap_hands
  69               	.LVL5:
  70               	.L9:
  71               		.loc 1 141 8 discriminator 2 view .LVU14
  72 002c 9923      		tst r25
  73 002e 01F0      		breq .L4
 142:quantum/action.c ****         event->key.row = pgm_read_byte(&hand_swap_config[pos.row][pos.col].row);
  74               		.loc 1 142 9 is_stmt 1 view .LVU15
  75               	.LBB28:
  76               		.loc 1 142 26 view .LVU16
  77 0030 90E0      		ldi r25,0
  78 0032 66E0      		ldi r22,lo8(6)
  79 0034 569F      		mul r21,r22
  80 0036 800D      		add r24,r0
  81 0038 911D      		adc r25,r1
  82 003a 1124      		clr __zero_reg__
  83               	.LVL6:
  84               		.loc 1 142 26 is_stmt 0 view .LVU17
  85 003c 880F      		lsl r24
  86 003e 991F      		rol r25
  87               	.LVL7:
  88               		.loc 1 142 26 is_stmt 1 view .LVU18
  89               		.loc 1 142 26 view .LVU19
  90 0040 FC01      		movw r30,r24
  91 0042 E050      		subi r30,lo8(-(hand_swap_config+1))
  92 0044 F040      		sbci r31,hi8(-(hand_swap_config+1))
  93               	.LVL8:
  94               		.loc 1 142 26 is_stmt 0 view .LVU20
  95               	/* #APP */
  96               	 ;  142 "quantum/action.c" 1
  97 0046 E491      		lpm r30, Z
  98               		
  99               	 ;  0 "" 2
 100               	.LVL9:
 101               		.loc 1 142 26 is_stmt 1 view .LVU21
 102               	/* #NOAPP */
 103               	.LBE28:
 104               		.loc 1 142 24 is_stmt 0 view .LVU22
 105 0048 E983      		std Y+1,r30
 143:quantum/action.c ****         event->key.col = pgm_read_byte(&hand_swap_config[pos.row][pos.col].col);
 106               		.loc 1 143 9 is_stmt 1 view .LVU23
 107               	.LBB29:
 108               		.loc 1 143 26 view .LVU24
 109               	.LVL10:
 110               		.loc 1 143 26 view .LVU25
 111               		.loc 1 143 26 view .LVU26
 112 004a FC01      		movw r30,r24
 113               	.LVL11:
 114               		.loc 1 143 26 is_stmt 0 view .LVU27
 115 004c E050      		subi r30,lo8(-(hand_swap_config))
 116 004e F040      		sbci r31,hi8(-(hand_swap_config))
 117               	.LVL12:
 118               		.loc 1 143 26 view .LVU28
 119               	/* #APP */
 120               	 ;  143 "quantum/action.c" 1
 121 0050 E491      		lpm r30, Z
 122               		
 123               	 ;  0 "" 2
 124               	.LVL13:
 125               		.loc 1 143 26 is_stmt 1 view .LVU29
 126               	/* #NOAPP */
 127               	.LBE29:
 128               		.loc 1 143 24 is_stmt 0 view .LVU30
 129 0052 E883      		st Y,r30
 130               	.LVL14:
 144:quantum/action.c ****         swap_state[pos.row] |= col_bit;
 131               		.loc 1 144 9 is_stmt 1 view .LVU31
 132               		.loc 1 144 29 is_stmt 0 view .LVU32
 133 0054 422B      		or r20,r18
 134               	.LVL15:
 135               	.L5:
 136               		.loc 1 144 29 view .LVU33
 137 0056 4C93      		st X,r20
 138               	.LVL16:
 139               	/* epilogue start */
 145:quantum/action.c ****     } else {
 146:quantum/action.c ****         swap_state[pos.row] &= ~(col_bit);
 147:quantum/action.c ****     }
 148:quantum/action.c **** }
 140               		.loc 1 148 1 view .LVU34
 141 0058 DF91      		pop r29
 142 005a CF91      		pop r28
 143               	.LVL17:
 144               		.loc 1 148 1 view .LVU35
 145 005c 0895      		ret
 146               	.LVL18:
 147               	.L2:
 141:quantum/action.c ****         event->key.row = pgm_read_byte(&hand_swap_config[pos.row][pos.col].row);
 148               		.loc 1 141 5 is_stmt 1 discriminator 2 view .LVU36
 139:quantum/action.c **** 
 149               		.loc 1 139 60 is_stmt 0 discriminator 2 view .LVU37
 150 005e 942F      		mov r25,r20
 151 0060 9223      		and r25,r18
 152 0062 00C0      		rjmp .L9
 153               	.LVL19:
 154               	.L4:
 146:quantum/action.c ****     }
 155               		.loc 1 146 9 is_stmt 1 view .LVU38
 146:quantum/action.c ****     }
 156               		.loc 1 146 29 is_stmt 0 view .LVU39
 157 0064 2095      		com r18
 158               	.LVL20:
 146:quantum/action.c ****     }
 159               		.loc 1 146 29 view .LVU40
 160 0066 4223      		and r20,r18
 161 0068 00C0      		rjmp .L5
 162               		.cfi_endproc
 163               	.LFE17:
 165               		.section	.text.process_record_quantum,"ax",@progbits
 166               		.weak	process_record_quantum
 168               	process_record_quantum:
 169               	.LVL21:
 170               	.LFB19:
 149:quantum/action.c **** #endif
 150:quantum/action.c **** 
 151:quantum/action.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 152:quantum/action.c **** bool disable_action_cache = false;
 153:quantum/action.c **** 
 154:quantum/action.c **** void process_record_nocache(keyrecord_t *record) {
 155:quantum/action.c ****     disable_action_cache = true;
 156:quantum/action.c ****     process_record(record);
 157:quantum/action.c ****     disable_action_cache = false;
 158:quantum/action.c **** }
 159:quantum/action.c **** #else
 160:quantum/action.c **** void process_record_nocache(keyrecord_t *record) { process_record(record); }
 161:quantum/action.c **** #endif
 162:quantum/action.c **** 
 163:quantum/action.c **** __attribute__((weak)) bool process_record_quantum(keyrecord_t *record) { return true; }
 171               		.loc 1 163 72 is_stmt 1 view -0
 172               		.cfi_startproc
 173               	/* prologue: function */
 174               	/* frame size = 0 */
 175               	/* stack size = 0 */
 176               	.L__stack_usage = 0
 177               		.loc 1 163 74 view .LVU42
 178               		.loc 1 163 87 is_stmt 0 view .LVU43
 179 0000 81E0      		ldi r24,lo8(1)
 180               	.LVL22:
 181               	/* epilogue start */
 182               		.loc 1 163 87 view .LVU44
 183 0002 0895      		ret
 184               		.cfi_endproc
 185               	.LFE19:
 187               		.set	process_record_quantum.localalias,process_record_quantum
 188               		.section	.text.pre_process_record_quantum,"ax",@progbits
 189               		.weak	pre_process_record_quantum
 191               	pre_process_record_quantum:
 192               	.LFB43:
 193               		.cfi_startproc
 194               	/* prologue: function */
 195               	/* frame size = 0 */
 196               	/* stack size = 0 */
 197               	.L__stack_usage = 0
 198 0000 0C94 0000 		jmp process_record_quantum.localalias
 199               		.cfi_endproc
 200               	.LFE43:
 202               		.section	.text.action_exec,"ax",@progbits
 203               	.global	action_exec
 205               	action_exec:
 206               	.LFB16:
  70:quantum/action.c ****     if (!IS_NOEVENT(event)) {
 207               		.loc 1 70 36 is_stmt 1 view -0
 208               		.cfi_startproc
 209 0000 EF92      		push r14
 210               	.LCFI2:
 211               		.cfi_def_cfa_offset 3
 212               		.cfi_offset 14, -2
 213 0002 FF92      		push r15
 214               	.LCFI3:
 215               		.cfi_def_cfa_offset 4
 216               		.cfi_offset 15, -3
 217 0004 0F93      		push r16
 218               	.LCFI4:
 219               		.cfi_def_cfa_offset 5
 220               		.cfi_offset 16, -4
 221 0006 1F93      		push r17
 222               	.LCFI5:
 223               		.cfi_def_cfa_offset 6
 224               		.cfi_offset 17, -5
 225 0008 CF93      		push r28
 226               	.LCFI6:
 227               		.cfi_def_cfa_offset 7
 228               		.cfi_offset 28, -6
 229 000a DF93      		push r29
 230               	.LCFI7:
 231               		.cfi_def_cfa_offset 8
 232               		.cfi_offset 29, -7
 233 000c CDB7      		in r28,__SP_L__
 234 000e DEB7      		in r29,__SP_H__
 235               	.LCFI8:
 236               		.cfi_def_cfa_register 28
 237 0010 2B97      		sbiw r28,11
 238               	.LCFI9:
 239               		.cfi_def_cfa_offset 19
 240 0012 0FB6      		in __tmp_reg__,__SREG__
 241 0014 F894      		cli
 242 0016 DEBF      		out __SP_H__,r29
 243 0018 0FBE      		out __SREG__,__tmp_reg__
 244 001a CDBF      		out __SP_L__,r28
 245               	/* prologue: function */
 246               	/* frame size = 11 */
 247               	/* stack size = 17 */
 248               	.L__stack_usage = 17
 249 001c 042F      		mov r16,r20
 250 001e 4F83      		std Y+7,r20
 251 0020 152F      		mov r17,r21
 252 0022 5887      		std Y+8,r21
 253 0024 6987      		std Y+9,r22
 254 0026 7A87      		std Y+10,r23
 255 0028 8B87      		std Y+11,r24
  71:quantum/action.c ****         dprint("\n---- action_exec: start -----\n");
 256               		.loc 1 71 5 view .LVU46
 257               	.LVL23:
  71:quantum/action.c ****         dprint("\n---- action_exec: start -----\n");
 258               		.loc 1 71 5 is_stmt 0 view .LVU47
 259 002a EA84      		ldd r14,Y+10
 260 002c FB84      		ldd r15,Y+11
 261               	.LVL24:
 262               	.LBB30:
 263               	.LBI30:
 264               		.file 2 "quantum/keyboard.h"
   1:quantum/keyboard.h **** /*
   2:quantum/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:quantum/keyboard.h **** 
   4:quantum/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:quantum/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:quantum/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:quantum/keyboard.h **** (at your option) any later version.
   8:quantum/keyboard.h **** 
   9:quantum/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:quantum/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:quantum/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:quantum/keyboard.h **** GNU General Public License for more details.
  13:quantum/keyboard.h **** 
  14:quantum/keyboard.h **** You should have received a copy of the GNU General Public License
  15:quantum/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:quantum/keyboard.h **** */
  17:quantum/keyboard.h **** 
  18:quantum/keyboard.h **** #pragma once
  19:quantum/keyboard.h **** 
  20:quantum/keyboard.h **** #include <stdbool.h>
  21:quantum/keyboard.h **** #include <stdint.h>
  22:quantum/keyboard.h **** 
  23:quantum/keyboard.h **** #ifdef __cplusplus
  24:quantum/keyboard.h **** extern "C" {
  25:quantum/keyboard.h **** #endif
  26:quantum/keyboard.h **** 
  27:quantum/keyboard.h **** /* key matrix position */
  28:quantum/keyboard.h **** typedef struct {
  29:quantum/keyboard.h ****     uint8_t col;
  30:quantum/keyboard.h ****     uint8_t row;
  31:quantum/keyboard.h **** } keypos_t;
  32:quantum/keyboard.h **** 
  33:quantum/keyboard.h **** /* key event */
  34:quantum/keyboard.h **** typedef struct {
  35:quantum/keyboard.h ****     keypos_t key;
  36:quantum/keyboard.h ****     bool     pressed;
  37:quantum/keyboard.h ****     uint16_t time;
  38:quantum/keyboard.h **** } keyevent_t;
  39:quantum/keyboard.h **** 
  40:quantum/keyboard.h **** /* equivalent test of keypos_t */
  41:quantum/keyboard.h **** #define KEYEQ(keya, keyb) ((keya).row == (keyb).row && (keya).col == (keyb).col)
  42:quantum/keyboard.h **** 
  43:quantum/keyboard.h **** /* Rules for No Event:
  44:quantum/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  45:quantum/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  46:quantum/keyboard.h ****  */
  47:quantum/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 265               		.loc 2 47 20 is_stmt 1 view .LVU48
 266               		.loc 2 47 51 view .LVU49
 267               		.loc 2 47 51 is_stmt 0 view .LVU50
 268               	.LBE30:
  75:quantum/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
 269               		.loc 1 75 19 is_stmt 1 view .LVU51
  81:quantum/action.c ****         // clear the potential weak mods left by previously pressed keys
 270               		.loc 1 81 5 view .LVU52
  81:quantum/action.c ****         // clear the potential weak mods left by previously pressed keys
 271               		.loc 1 81 8 is_stmt 0 view .LVU53
 272 002e 6111      		cpse r22,__zero_reg__
  83:quantum/action.c ****     }
 273               		.loc 1 83 9 is_stmt 1 view .LVU54
 274 0030 0E94 0000 		call clear_weak_mods
 275               	.LVL25:
 276               	.L13:
  87:quantum/action.c ****         process_hand_swap(&event);
 277               		.loc 1 87 5 view .LVU55
 278               	.LBB31:
 279               	.LBI31:
 280               		.loc 2 47 20 view .LVU56
 281               	.LBB32:
 282               		.loc 2 47 51 view .LVU57
 283               		.loc 2 47 74 is_stmt 0 view .LVU58
 284 0034 EF28      		or r14,r15
 285 0036 01F0      		breq .L14
 286 0038 1023      		and r17,r16
 287               	.LVL26:
 288               		.loc 2 47 74 view .LVU59
 289 003a 1F3F      		cpi r17,lo8(-1)
 290 003c 01F4      		brne .L15
 291               	.LVL27:
 292               	.L14:
 293               		.loc 2 47 74 view .LVU60
 294               	.LBE32:
 295               	.LBE31:
  92:quantum/action.c **** 
 296               		.loc 1 92 5 is_stmt 1 view .LVU61
  92:quantum/action.c **** 
 297               		.loc 1 92 17 is_stmt 0 view .LVU62
 298 003e 1E82      		std Y+6,__zero_reg__
 299 0040 85E0      		ldi r24,lo8(5)
 300 0042 FE01      		movw r30,r28
 301 0044 3796      		adiw r30,7
 302 0046 DE01      		movw r26,r28
 303 0048 1196      		adiw r26,1
 304               		0:
 305 004a 0190      		ld r0,Z+
 306 004c 0D92      		st X+,r0
 307 004e 8A95      		dec r24
 308 0050 01F4      		brne 0b
 111:quantum/action.c ****         action_tapping_process(record);
 309               		.loc 1 111 5 is_stmt 1 view .LVU63
 310 0052 8981      		ldd r24,Y+1
 311               	.LVL28:
 111:quantum/action.c ****         action_tapping_process(record);
 312               		.loc 1 111 5 is_stmt 0 view .LVU64
 313 0054 9A81      		ldd r25,Y+2
 314               	.LVL29:
 315               	.LBB33:
 316               	.LBI33:
 317               		.loc 2 47 20 is_stmt 1 view .LVU65
 318               	.LBB34:
 319               		.loc 2 47 51 view .LVU66
 320               		.loc 2 47 74 is_stmt 0 view .LVU67
 321 0056 2C81      		ldd r18,Y+4
 322 0058 3D81      		ldd r19,Y+5
 323 005a 232B      		or r18,r19
 324 005c 01F4      		brne .L16
 325               	.LVL30:
 326               	.L18:
 327               		.loc 2 47 74 view .LVU68
 328               	.LBE34:
 329               	.LBE33:
 112:quantum/action.c ****     }
 330               		.loc 1 112 9 is_stmt 1 view .LVU69
 331 005e 4981      		ldd r20,Y+1
 332 0060 5A81      		ldd r21,Y+2
 333 0062 6B81      		ldd r22,Y+3
 334 0064 7C81      		ldd r23,Y+4
 335 0066 8D81      		ldd r24,Y+5
 336 0068 9E81      		ldd r25,Y+6
 337 006a 0E94 0000 		call action_tapping_process
 338               	.LVL31:
 339               	.L12:
 340               	/* epilogue start */
 124:quantum/action.c **** 
 341               		.loc 1 124 1 is_stmt 0 view .LVU70
 342 006e 2B96      		adiw r28,11
 343 0070 0FB6      		in __tmp_reg__,__SREG__
 344 0072 F894      		cli
 345 0074 DEBF      		out __SP_H__,r29
 346 0076 0FBE      		out __SREG__,__tmp_reg__
 347 0078 CDBF      		out __SP_L__,r28
 348 007a DF91      		pop r29
 349 007c CF91      		pop r28
 350 007e 1F91      		pop r17
 351 0080 0F91      		pop r16
 352 0082 FF90      		pop r15
 353 0084 EF90      		pop r14
 354 0086 0895      		ret
 355               	.LVL32:
 356               	.L16:
 357               	.LBB36:
 358               	.LBB35:
 359               		.loc 2 47 74 view .LVU71
 360 0088 8923      		and r24,r25
 361               	.LVL33:
 362               		.loc 2 47 74 view .LVU72
 363 008a 8F3F      		cpi r24,lo8(-1)
 364 008c 01F0      		breq .L18
 365               	.LVL34:
 366               		.loc 2 47 74 view .LVU73
 367               	.LBE35:
 368               	.LBE36:
 111:quantum/action.c ****         action_tapping_process(record);
 369               		.loc 1 111 37 view .LVU74
 370 008e CE01      		movw r24,r28
 371 0090 0196      		adiw r24,1
 372 0092 0E94 0000 		call pre_process_record_quantum
 373               	.LVL35:
 111:quantum/action.c ****         action_tapping_process(record);
 374               		.loc 1 111 34 view .LVU75
 375 0096 8111      		cpse r24,__zero_reg__
 376 0098 00C0      		rjmp .L18
 377 009a 00C0      		rjmp .L12
 378               	.LVL36:
 379               	.L15:
  88:quantum/action.c ****     }
 380               		.loc 1 88 9 is_stmt 1 view .LVU76
 381 009c CE01      		movw r24,r28
 382 009e 0796      		adiw r24,7
 383 00a0 0E94 0000 		call process_hand_swap
 384               	.LVL37:
 385 00a4 00C0      		rjmp .L14
 386               		.cfi_endproc
 387               	.LFE16:
 389               		.section	.text.post_process_record_quantum,"ax",@progbits
 390               		.weak	post_process_record_quantum
 392               	post_process_record_quantum:
 393               	.LVL38:
 394               	.LFB20:
 164:quantum/action.c **** 
 165:quantum/action.c **** __attribute__((weak)) void post_process_record_quantum(keyrecord_t *record) {}
 395               		.loc 1 165 77 view -0
 396               		.cfi_startproc
 397               	/* prologue: function */
 398               	/* frame size = 0 */
 399               	/* stack size = 0 */
 400               	.L__stack_usage = 0
 401               		.loc 1 165 78 view .LVU78
 402               	/* epilogue start */
 403 0000 0895      		ret
 404               		.cfi_endproc
 405               	.LFE20:
 407               		.section	.text.process_record_tap_hint,"ax",@progbits
 408               	.global	process_record_tap_hint
 410               	process_record_tap_hint:
 411               	.LVL39:
 412               	.LFB21:
 166:quantum/action.c **** 
 167:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 168:quantum/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 169:quantum/action.c ****  *
 170:quantum/action.c ****  * FIXME: Needs documentation.
 171:quantum/action.c ****  */
 172:quantum/action.c **** void process_record_tap_hint(keyrecord_t *record) {
 413               		.loc 1 172 51 view -0
 414               		.cfi_startproc
 415               	/* prologue: function */
 416               	/* frame size = 0 */
 417               	/* stack size = 0 */
 418               	.L__stack_usage = 0
 173:quantum/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 419               		.loc 1 173 5 view .LVU80
 420               		.loc 1 173 23 is_stmt 0 view .LVU81
 421 0000 FC01      		movw r30,r24
 422 0002 8081      		ld r24,Z
 423 0004 9181      		ldd r25,Z+1
 424               	.LVL40:
 425               		.loc 1 173 23 view .LVU82
 426 0006 0E94 0000 		call layer_switch_get_action
 427               	.LVL41:
 174:quantum/action.c **** 
 175:quantum/action.c ****     switch (action.kind.id) {
 428               		.loc 1 175 5 is_stmt 1 view .LVU83
 429               		.loc 1 175 24 is_stmt 0 view .LVU84
 430 000a 9295      		swap r25
 431 000c 9F70      		andi r25,lo8(15)
 432               		.loc 1 175 5 view .LVU85
 433 000e 9630      		cpi r25,lo8(6)
 434 0010 01F4      		brne .L31
 176:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 177:quantum/action.c ****         case ACT_SWAP_HANDS:
 178:quantum/action.c ****             switch (action.swap.code) {
 435               		.loc 1 178 13 is_stmt 1 view .LVU86
 436               	.LVL42:
 437               		.loc 1 178 13 is_stmt 0 view .LVU87
 438 0012 863F      		cpi r24,lo8(-10)
 439 0014 01F0      		breq .L31
 179:quantum/action.c ****                 case OP_SH_ONESHOT:
 180:quantum/action.c ****                     break;
 181:quantum/action.c ****                 case OP_SH_TAP_TOGGLE:
 182:quantum/action.c ****                 default:
 183:quantum/action.c ****                     swap_hands = !swap_hands;
 440               		.loc 1 183 21 is_stmt 1 view .LVU88
 441 0016 8091 0000 		lds r24,swap_hands
 442               		.loc 1 183 21 is_stmt 0 view .LVU89
 443 001a 91E0      		ldi r25,lo8(1)
 444 001c 8927      		eor r24,r25
 445               		.loc 1 183 32 view .LVU90
 446 001e 8093 0000 		sts swap_hands,r24
 184:quantum/action.c ****                     swap_held  = true;
 447               		.loc 1 184 21 is_stmt 1 view .LVU91
 448               		.loc 1 184 32 is_stmt 0 view .LVU92
 449 0022 9093 0000 		sts swap_held,r25
 450               	.L31:
 451               	/* epilogue start */
 185:quantum/action.c ****             }
 186:quantum/action.c ****             break;
 187:quantum/action.c **** #    endif
 188:quantum/action.c ****     }
 189:quantum/action.c **** }
 452               		.loc 1 189 1 discriminator 1 view .LVU93
 453 0026 0895      		ret
 454               		.cfi_endproc
 455               	.LFE21:
 457               		.section	.text.register_code,"ax",@progbits
 458               	.global	register_code
 460               	register_code:
 461               	.LVL43:
 462               	.LFB25:
 190:quantum/action.c **** #endif
 191:quantum/action.c **** 
 192:quantum/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 193:quantum/action.c ****  *
 194:quantum/action.c ****  * FIXME: Needs documentation.
 195:quantum/action.c ****  */
 196:quantum/action.c **** void process_record(keyrecord_t *record) {
 197:quantum/action.c ****     if (IS_NOEVENT(record->event)) {
 198:quantum/action.c ****         return;
 199:quantum/action.c ****     }
 200:quantum/action.c **** 
 201:quantum/action.c ****     if (!process_record_quantum(record)) {
 202:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 203:quantum/action.c ****         if (is_oneshot_layer_active() && record->event.pressed) {
 204:quantum/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 205:quantum/action.c ****         }
 206:quantum/action.c **** #endif
 207:quantum/action.c ****         return;
 208:quantum/action.c ****     }
 209:quantum/action.c **** 
 210:quantum/action.c ****     process_record_handler(record);
 211:quantum/action.c ****     post_process_record_quantum(record);
 212:quantum/action.c **** }
 213:quantum/action.c **** 
 214:quantum/action.c **** void process_record_handler(keyrecord_t *record) {
 215:quantum/action.c **** #ifdef COMBO_ENABLE
 216:quantum/action.c ****     action_t action;
 217:quantum/action.c ****     if (record->keycode) {
 218:quantum/action.c ****         action = action_for_keycode(record->keycode);
 219:quantum/action.c ****     } else {
 220:quantum/action.c ****         action = store_or_get_action(record->event.pressed, record->event.key);
 221:quantum/action.c ****     }
 222:quantum/action.c **** #else
 223:quantum/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 224:quantum/action.c **** #endif
 225:quantum/action.c ****     dprint("ACTION: ");
 226:quantum/action.c ****     debug_action(action);
 227:quantum/action.c **** #ifndef NO_ACTION_LAYER
 228:quantum/action.c ****     dprint(" layer_state: ");
 229:quantum/action.c ****     layer_debug();
 230:quantum/action.c ****     dprint(" default_layer_state: ");
 231:quantum/action.c ****     default_layer_debug();
 232:quantum/action.c **** #endif
 233:quantum/action.c ****     dprintln();
 234:quantum/action.c **** 
 235:quantum/action.c ****     process_action(record, action);
 236:quantum/action.c **** }
 237:quantum/action.c **** 
 238:quantum/action.c **** #if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 239:quantum/action.c **** void register_button(bool pressed, enum mouse_buttons button) {
 240:quantum/action.c **** #    ifdef PS2_MOUSE_ENABLE
 241:quantum/action.c ****     tp_buttons = pressed ? tp_buttons | button : tp_buttons & ~button;
 242:quantum/action.c **** #    endif
 243:quantum/action.c **** #    ifdef POINTING_DEVICE_ENABLE
 244:quantum/action.c ****     report_mouse_t currentReport = pointing_device_get_report();
 245:quantum/action.c ****     currentReport.buttons        = pressed ? currentReport.buttons | button : currentReport.buttons
 246:quantum/action.c ****     pointing_device_set_report(currentReport);
 247:quantum/action.c **** #    endif
 248:quantum/action.c **** }
 249:quantum/action.c **** #endif
 250:quantum/action.c **** 
 251:quantum/action.c **** /** \brief Take an action and processes it.
 252:quantum/action.c ****  *
 253:quantum/action.c ****  * FIXME: Needs documentation.
 254:quantum/action.c ****  */
 255:quantum/action.c **** void process_action(keyrecord_t *record, action_t action) {
 256:quantum/action.c ****     keyevent_t event = record->event;
 257:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 258:quantum/action.c ****     uint8_t tap_count = record->tap.count;
 259:quantum/action.c **** #endif
 260:quantum/action.c **** 
 261:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 262:quantum/action.c ****     bool do_release_oneshot = false;
 263:quantum/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 264:quantum/action.c ****     if (is_oneshot_layer_active() && event.pressed && (action.kind.id == ACT_USAGE || !IS_MOD(actio
 265:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 266:quantum/action.c ****         && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)
 267:quantum/action.c **** #    endif
 268:quantum/action.c ****     ) {
 269:quantum/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 270:quantum/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 271:quantum/action.c ****     }
 272:quantum/action.c **** #endif
 273:quantum/action.c **** 
 274:quantum/action.c ****     switch (action.kind.id) {
 275:quantum/action.c ****         /* Key and Mods */
 276:quantum/action.c ****         case ACT_LMODS:
 277:quantum/action.c ****         case ACT_RMODS: {
 278:quantum/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS) ? action.key.mods : action.key.mods << 4;
 279:quantum/action.c ****             if (event.pressed) {
 280:quantum/action.c ****                 if (mods) {
 281:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 282:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 283:quantum/action.c ****                         // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSFT).
 284:quantum/action.c ****                         // Same applies for some keys like KC_MEH which are declared as MEH(KC_NO).
 285:quantum/action.c ****                         add_mods(mods);
 286:quantum/action.c ****                     } else {
 287:quantum/action.c ****                         add_weak_mods(mods);
 288:quantum/action.c ****                     }
 289:quantum/action.c ****                     send_keyboard_report();
 290:quantum/action.c ****                 }
 291:quantum/action.c ****                 register_code(action.key.code);
 292:quantum/action.c ****             } else {
 293:quantum/action.c ****                 unregister_code(action.key.code);
 294:quantum/action.c ****                 if (mods) {
 295:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 296:quantum/action.c ****                         del_mods(mods);
 297:quantum/action.c ****                     } else {
 298:quantum/action.c ****                         del_weak_mods(mods);
 299:quantum/action.c ****                     }
 300:quantum/action.c ****                     send_keyboard_report();
 301:quantum/action.c ****                 }
 302:quantum/action.c ****             }
 303:quantum/action.c ****         } break;
 304:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 305:quantum/action.c ****         case ACT_LMODS_TAP:
 306:quantum/action.c ****         case ACT_RMODS_TAP: {
 307:quantum/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ? action.key.mods : action.key.mods <<
 308:quantum/action.c ****             switch (action.layer_tap.code) {
 309:quantum/action.c **** #    ifndef NO_ACTION_ONESHOT
 310:quantum/action.c ****                 case MODS_ONESHOT:
 311:quantum/action.c ****                     // Oneshot modifier
 312:quantum/action.c ****                     if (event.pressed) {
 313:quantum/action.c ****                         if (tap_count == 0) {
 314:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 315:quantum/action.c ****                             register_mods(mods | get_oneshot_mods());
 316:quantum/action.c ****                         } else if (tap_count == 1) {
 317:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 318:quantum/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 319:quantum/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 320:quantum/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 321:quantum/action.c ****                             dprint("MODS_TAP: Toggling oneshot");
 322:quantum/action.c ****                             clear_oneshot_mods();
 323:quantum/action.c ****                             set_oneshot_locked_mods(mods);
 324:quantum/action.c ****                             register_mods(mods);
 325:quantum/action.c **** #        endif
 326:quantum/action.c ****                         } else {
 327:quantum/action.c ****                             register_mods(mods | get_oneshot_mods());
 328:quantum/action.c ****                         }
 329:quantum/action.c ****                     } else {
 330:quantum/action.c ****                         if (tap_count == 0) {
 331:quantum/action.c ****                             clear_oneshot_mods();
 332:quantum/action.c ****                             unregister_mods(mods);
 333:quantum/action.c ****                         } else if (tap_count == 1) {
 334:quantum/action.c ****                             // Retain Oneshot mods
 335:quantum/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 336:quantum/action.c ****                             if (mods & get_mods()) {
 337:quantum/action.c ****                                 clear_oneshot_locked_mods();
 338:quantum/action.c ****                                 clear_oneshot_mods();
 339:quantum/action.c ****                                 unregister_mods(mods);
 340:quantum/action.c ****                             }
 341:quantum/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 342:quantum/action.c ****                             // Toggle Oneshot Layer
 343:quantum/action.c **** #        endif
 344:quantum/action.c ****                         } else {
 345:quantum/action.c ****                             clear_oneshot_mods();
 346:quantum/action.c ****                             unregister_mods(mods);
 347:quantum/action.c ****                         }
 348:quantum/action.c ****                     }
 349:quantum/action.c ****                     break;
 350:quantum/action.c **** #    endif
 351:quantum/action.c ****                 case MODS_TAP_TOGGLE:
 352:quantum/action.c ****                     if (event.pressed) {
 353:quantum/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 354:quantum/action.c ****                             register_mods(mods);
 355:quantum/action.c ****                         }
 356:quantum/action.c ****                     } else {
 357:quantum/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 358:quantum/action.c ****                             unregister_mods(mods);
 359:quantum/action.c ****                         }
 360:quantum/action.c ****                     }
 361:quantum/action.c ****                     break;
 362:quantum/action.c ****                 default:
 363:quantum/action.c ****                     if (event.pressed) {
 364:quantum/action.c ****                         if (tap_count > 0) {
 365:quantum/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 366:quantum/action.c ****                             if (
 367:quantum/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 368:quantum/action.c ****                                 !get_ignore_mod_tap_interrupt(get_event_keycode(record->event, fals
 369:quantum/action.c **** #        endif
 370:quantum/action.c ****                                 record->tap.interrupted) {
 371:quantum/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 372:quantum/action.c ****                                 // ad hoc: set 0 to cancel tap
 373:quantum/action.c ****                                 record->tap.count = 0;
 374:quantum/action.c ****                                 register_mods(mods);
 375:quantum/action.c ****                             } else
 376:quantum/action.c **** #    endif
 377:quantum/action.c ****                             {
 378:quantum/action.c ****                                 dprint("MODS_TAP: Tap: register_code\n");
 379:quantum/action.c ****                                 register_code(action.key.code);
 380:quantum/action.c ****                             }
 381:quantum/action.c ****                         } else {
 382:quantum/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 383:quantum/action.c ****                             register_mods(mods);
 384:quantum/action.c ****                         }
 385:quantum/action.c ****                     } else {
 386:quantum/action.c ****                         if (tap_count > 0) {
 387:quantum/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 388:quantum/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 389:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 390:quantum/action.c ****                             } else {
 391:quantum/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 392:quantum/action.c ****                             }
 393:quantum/action.c ****                             unregister_code(action.key.code);
 394:quantum/action.c ****                         } else {
 395:quantum/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 396:quantum/action.c ****                             unregister_mods(mods);
 397:quantum/action.c ****                         }
 398:quantum/action.c ****                     }
 399:quantum/action.c ****                     break;
 400:quantum/action.c ****             }
 401:quantum/action.c ****         } break;
 402:quantum/action.c **** #endif
 403:quantum/action.c **** #ifdef EXTRAKEY_ENABLE
 404:quantum/action.c ****         /* other HID usage */
 405:quantum/action.c ****         case ACT_USAGE:
 406:quantum/action.c ****             switch (action.usage.page) {
 407:quantum/action.c ****                 case PAGE_SYSTEM:
 408:quantum/action.c ****                     if (event.pressed) {
 409:quantum/action.c ****                         host_system_send(action.usage.code);
 410:quantum/action.c ****                     } else {
 411:quantum/action.c ****                         host_system_send(0);
 412:quantum/action.c ****                     }
 413:quantum/action.c ****                     break;
 414:quantum/action.c ****                 case PAGE_CONSUMER:
 415:quantum/action.c ****                     if (event.pressed) {
 416:quantum/action.c ****                         host_consumer_send(action.usage.code);
 417:quantum/action.c ****                     } else {
 418:quantum/action.c ****                         host_consumer_send(0);
 419:quantum/action.c ****                     }
 420:quantum/action.c ****                     break;
 421:quantum/action.c ****             }
 422:quantum/action.c ****             break;
 423:quantum/action.c **** #endif
 424:quantum/action.c **** #ifdef MOUSEKEY_ENABLE
 425:quantum/action.c ****         /* Mouse key */
 426:quantum/action.c ****         case ACT_MOUSEKEY:
 427:quantum/action.c ****             if (event.pressed) {
 428:quantum/action.c ****                 mousekey_on(action.key.code);
 429:quantum/action.c ****             } else {
 430:quantum/action.c ****                 mousekey_off(action.key.code);
 431:quantum/action.c ****             }
 432:quantum/action.c ****             switch (action.key.code) {
 433:quantum/action.c **** #    if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 434:quantum/action.c **** #        ifdef POINTING_DEVICE_ENABLE
 435:quantum/action.c ****                 case KC_MS_BTN1 ... KC_MS_BTN8:
 436:quantum/action.c **** #        else
 437:quantum/action.c ****                 case KC_MS_BTN1 ... KC_MS_BTN3:
 438:quantum/action.c **** #        endif
 439:quantum/action.c ****                     register_button(event.pressed, MOUSE_BTN_MASK(action.key.code - KC_MS_BTN1));
 440:quantum/action.c ****                     break;
 441:quantum/action.c **** #    endif
 442:quantum/action.c ****                 default:
 443:quantum/action.c ****                     mousekey_send();
 444:quantum/action.c ****                     break;
 445:quantum/action.c ****             }
 446:quantum/action.c ****             break;
 447:quantum/action.c **** #endif
 448:quantum/action.c **** #ifndef NO_ACTION_LAYER
 449:quantum/action.c ****         case ACT_LAYER:
 450:quantum/action.c ****             if (action.layer_bitop.on == 0) {
 451:quantum/action.c ****                 /* Default Layer Bitwise Operation */
 452:quantum/action.c ****                 if (!event.pressed) {
 453:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 454:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 455:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 456:quantum/action.c ****                     switch (action.layer_bitop.op) {
 457:quantum/action.c ****                         case OP_BIT_AND:
 458:quantum/action.c ****                             default_layer_and(bits | mask);
 459:quantum/action.c ****                             break;
 460:quantum/action.c ****                         case OP_BIT_OR:
 461:quantum/action.c ****                             default_layer_or(bits | mask);
 462:quantum/action.c ****                             break;
 463:quantum/action.c ****                         case OP_BIT_XOR:
 464:quantum/action.c ****                             default_layer_xor(bits | mask);
 465:quantum/action.c ****                             break;
 466:quantum/action.c ****                         case OP_BIT_SET:
 467:quantum/action.c ****                             default_layer_set(bits | mask);
 468:quantum/action.c ****                             break;
 469:quantum/action.c ****                     }
 470:quantum/action.c ****                 }
 471:quantum/action.c ****             } else {
 472:quantum/action.c ****                 /* Layer Bitwise Operation */
 473:quantum/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) : (action.layer_bitop.on & O
 474:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 475:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 476:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 477:quantum/action.c ****                     switch (action.layer_bitop.op) {
 478:quantum/action.c ****                         case OP_BIT_AND:
 479:quantum/action.c ****                             layer_and(bits | mask);
 480:quantum/action.c ****                             break;
 481:quantum/action.c ****                         case OP_BIT_OR:
 482:quantum/action.c ****                             layer_or(bits | mask);
 483:quantum/action.c ****                             break;
 484:quantum/action.c ****                         case OP_BIT_XOR:
 485:quantum/action.c ****                             layer_xor(bits | mask);
 486:quantum/action.c ****                             break;
 487:quantum/action.c ****                         case OP_BIT_SET:
 488:quantum/action.c ****                             layer_state_set(bits | mask);
 489:quantum/action.c ****                             break;
 490:quantum/action.c ****                     }
 491:quantum/action.c ****                 }
 492:quantum/action.c ****             }
 493:quantum/action.c ****             break;
 494:quantum/action.c ****         case ACT_LAYER_MODS:
 495:quantum/action.c ****             if (event.pressed) {
 496:quantum/action.c ****                 layer_on(action.layer_mods.layer);
 497:quantum/action.c ****                 register_mods(action.layer_mods.mods);
 498:quantum/action.c ****             } else {
 499:quantum/action.c ****                 unregister_mods(action.layer_mods.mods);
 500:quantum/action.c ****                 layer_off(action.layer_mods.layer);
 501:quantum/action.c ****             }
 502:quantum/action.c ****             break;
 503:quantum/action.c **** #    ifndef NO_ACTION_TAPPING
 504:quantum/action.c ****         case ACT_LAYER_TAP:
 505:quantum/action.c ****         case ACT_LAYER_TAP_EXT:
 506:quantum/action.c ****             switch (action.layer_tap.code) {
 507:quantum/action.c ****                 case OP_TAP_TOGGLE:
 508:quantum/action.c ****                     /* tap toggle */
 509:quantum/action.c ****                     if (event.pressed) {
 510:quantum/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 511:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 512:quantum/action.c ****                         }
 513:quantum/action.c ****                     } else {
 514:quantum/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 515:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 516:quantum/action.c ****                         }
 517:quantum/action.c ****                     }
 518:quantum/action.c ****                     break;
 519:quantum/action.c ****                 case OP_ON_OFF:
 520:quantum/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) : layer_off(action.layer_tap.val
 521:quantum/action.c ****                     break;
 522:quantum/action.c ****                 case OP_OFF_ON:
 523:quantum/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) : layer_on(action.layer_tap.val
 524:quantum/action.c ****                     break;
 525:quantum/action.c ****                 case OP_SET_CLEAR:
 526:quantum/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) : layer_clear();
 527:quantum/action.c ****                     break;
 528:quantum/action.c **** #        ifndef NO_ACTION_ONESHOT
 529:quantum/action.c ****                 case OP_ONESHOT:
 530:quantum/action.c ****                     // Oneshot modifier
 531:quantum/action.c **** #            if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 532:quantum/action.c ****                     do_release_oneshot = false;
 533:quantum/action.c ****                     if (event.pressed) {
 534:quantum/action.c ****                         del_mods(get_oneshot_locked_mods());
 535:quantum/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 536:quantum/action.c ****                             reset_oneshot_layer();
 537:quantum/action.c ****                             layer_off(action.layer_tap.val);
 538:quantum/action.c ****                             break;
 539:quantum/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 540:quantum/action.c ****                             layer_on(action.layer_tap.val);
 541:quantum/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 542:quantum/action.c ****                         }
 543:quantum/action.c ****                     } else {
 544:quantum/action.c ****                         add_mods(get_oneshot_locked_mods());
 545:quantum/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 546:quantum/action.c ****                             reset_oneshot_layer();
 547:quantum/action.c ****                             clear_oneshot_locked_mods();
 548:quantum/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 549:quantum/action.c ****                         } else {
 550:quantum/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 551:quantum/action.c ****                         }
 552:quantum/action.c ****                     }
 553:quantum/action.c **** #            else
 554:quantum/action.c ****                     if (event.pressed) {
 555:quantum/action.c ****                         layer_on(action.layer_tap.val);
 556:quantum/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 557:quantum/action.c ****                     } else {
 558:quantum/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 559:quantum/action.c ****                         if (tap_count > 1) {
 560:quantum/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 561:quantum/action.c ****                         }
 562:quantum/action.c ****                     }
 563:quantum/action.c **** #            endif
 564:quantum/action.c ****                     break;
 565:quantum/action.c **** #        endif
 566:quantum/action.c ****                 default:
 567:quantum/action.c ****                     /* tap key */
 568:quantum/action.c ****                     if (event.pressed) {
 569:quantum/action.c ****                         if (tap_count > 0) {
 570:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 571:quantum/action.c ****                             register_code(action.layer_tap.code);
 572:quantum/action.c ****                         } else {
 573:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 574:quantum/action.c ****                             layer_on(action.layer_tap.val);
 575:quantum/action.c ****                         }
 576:quantum/action.c ****                     } else {
 577:quantum/action.c ****                         if (tap_count > 0) {
 578:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 579:quantum/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 580:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 581:quantum/action.c ****                             } else {
 582:quantum/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 583:quantum/action.c ****                             }
 584:quantum/action.c ****                             unregister_code(action.layer_tap.code);
 585:quantum/action.c ****                         } else {
 586:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 587:quantum/action.c ****                             layer_off(action.layer_tap.val);
 588:quantum/action.c ****                         }
 589:quantum/action.c ****                     }
 590:quantum/action.c ****                     break;
 591:quantum/action.c ****             }
 592:quantum/action.c ****             break;
 593:quantum/action.c **** #    endif
 594:quantum/action.c **** #endif
 595:quantum/action.c ****             /* Extentions */
 596:quantum/action.c **** #ifndef NO_ACTION_MACRO
 597:quantum/action.c ****         case ACT_MACRO:
 598:quantum/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 599:quantum/action.c ****             break;
 600:quantum/action.c **** #endif
 601:quantum/action.c **** #ifdef SWAP_HANDS_ENABLE
 602:quantum/action.c ****         case ACT_SWAP_HANDS:
 603:quantum/action.c ****             switch (action.swap.code) {
 604:quantum/action.c ****                 case OP_SH_TOGGLE:
 605:quantum/action.c ****                     if (event.pressed) {
 606:quantum/action.c ****                         swap_hands = !swap_hands;
 607:quantum/action.c ****                     }
 608:quantum/action.c ****                     break;
 609:quantum/action.c ****                 case OP_SH_ON_OFF:
 610:quantum/action.c ****                     swap_hands = event.pressed;
 611:quantum/action.c ****                     break;
 612:quantum/action.c ****                 case OP_SH_OFF_ON:
 613:quantum/action.c ****                     swap_hands = !event.pressed;
 614:quantum/action.c ****                     break;
 615:quantum/action.c ****                 case OP_SH_ON:
 616:quantum/action.c ****                     if (!event.pressed) {
 617:quantum/action.c ****                         swap_hands = true;
 618:quantum/action.c ****                     }
 619:quantum/action.c ****                     break;
 620:quantum/action.c ****                 case OP_SH_OFF:
 621:quantum/action.c ****                     if (!event.pressed) {
 622:quantum/action.c ****                         swap_hands = false;
 623:quantum/action.c ****                     }
 624:quantum/action.c ****                     break;
 625:quantum/action.c **** #    ifndef NO_ACTION_ONESHOT
 626:quantum/action.c ****                 case OP_SH_ONESHOT:
 627:quantum/action.c ****                     if (event.pressed) {
 628:quantum/action.c ****                         set_oneshot_swaphands();
 629:quantum/action.c ****                     } else {
 630:quantum/action.c ****                         release_oneshot_swaphands();
 631:quantum/action.c ****                     }
 632:quantum/action.c ****                     break;
 633:quantum/action.c **** #    endif
 634:quantum/action.c **** 
 635:quantum/action.c **** #    ifndef NO_ACTION_TAPPING
 636:quantum/action.c ****                 case OP_SH_TAP_TOGGLE:
 637:quantum/action.c ****                     /* tap toggle */
 638:quantum/action.c **** 
 639:quantum/action.c ****                     if (event.pressed) {
 640:quantum/action.c ****                         if (swap_held) {
 641:quantum/action.c ****                             swap_held = false;
 642:quantum/action.c ****                         } else {
 643:quantum/action.c ****                             swap_hands = !swap_hands;
 644:quantum/action.c ****                         }
 645:quantum/action.c ****                     } else {
 646:quantum/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 647:quantum/action.c ****                             swap_hands = !swap_hands;
 648:quantum/action.c ****                         }
 649:quantum/action.c ****                     }
 650:quantum/action.c ****                     break;
 651:quantum/action.c ****                 default:
 652:quantum/action.c ****                     /* tap key */
 653:quantum/action.c ****                     if (tap_count > 0) {
 654:quantum/action.c ****                         if (swap_held) {
 655:quantum/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 656:quantum/action.c ****                             swap_held  = false;
 657:quantum/action.c ****                         }
 658:quantum/action.c ****                         if (event.pressed) {
 659:quantum/action.c ****                             register_code(action.swap.code);
 660:quantum/action.c ****                         } else {
 661:quantum/action.c ****                             wait_ms(TAP_CODE_DELAY);
 662:quantum/action.c ****                             unregister_code(action.swap.code);
 663:quantum/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 664:quantum/action.c ****                         }
 665:quantum/action.c ****                     } else {
 666:quantum/action.c ****                         if (swap_held && !event.pressed) {
 667:quantum/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 668:quantum/action.c ****                             swap_held  = false;
 669:quantum/action.c ****                         }
 670:quantum/action.c ****                     }
 671:quantum/action.c **** #    endif
 672:quantum/action.c ****             }
 673:quantum/action.c **** #endif
 674:quantum/action.c **** #ifndef NO_ACTION_FUNCTION
 675:quantum/action.c ****         case ACT_FUNCTION:
 676:quantum/action.c ****             action_function(record, action.func.id, action.func.opt);
 677:quantum/action.c ****             break;
 678:quantum/action.c **** #endif
 679:quantum/action.c ****         default:
 680:quantum/action.c ****             break;
 681:quantum/action.c ****     }
 682:quantum/action.c **** 
 683:quantum/action.c **** #ifndef NO_ACTION_LAYER
 684:quantum/action.c ****     // if this event is a layer action, update the leds
 685:quantum/action.c ****     switch (action.kind.id) {
 686:quantum/action.c ****         case ACT_LAYER:
 687:quantum/action.c ****         case ACT_LAYER_MODS:
 688:quantum/action.c **** #    ifndef NO_ACTION_TAPPING
 689:quantum/action.c ****         case ACT_LAYER_TAP:
 690:quantum/action.c ****         case ACT_LAYER_TAP_EXT:
 691:quantum/action.c **** #    endif
 692:quantum/action.c ****             led_set(host_keyboard_leds());
 693:quantum/action.c ****             break;
 694:quantum/action.c ****         default:
 695:quantum/action.c ****             break;
 696:quantum/action.c ****     }
 697:quantum/action.c **** #endif
 698:quantum/action.c **** 
 699:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 700:quantum/action.c **** #    if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
 701:quantum/action.c ****     if (!is_tap_action(action)) {
 702:quantum/action.c ****         retro_tapping_counter = 0;
 703:quantum/action.c ****     } else {
 704:quantum/action.c ****         if (event.pressed) {
 705:quantum/action.c ****             if (tap_count > 0) {
 706:quantum/action.c ****                 retro_tapping_counter = 0;
 707:quantum/action.c ****             }
 708:quantum/action.c ****         } else {
 709:quantum/action.c ****             if (tap_count > 0) {
 710:quantum/action.c ****                 retro_tapping_counter = 0;
 711:quantum/action.c ****             } else {
 712:quantum/action.c ****                 if (
 713:quantum/action.c **** #        ifdef RETRO_TAPPING_PER_KEY
 714:quantum/action.c ****                     get_retro_tapping(get_event_keycode(record->event, false), record) &&
 715:quantum/action.c **** #        endif
 716:quantum/action.c ****                     retro_tapping_counter == 2) {
 717:quantum/action.c ****                     tap_code(action.layer_tap.code);
 718:quantum/action.c ****                 }
 719:quantum/action.c ****                 retro_tapping_counter = 0;
 720:quantum/action.c ****             }
 721:quantum/action.c ****         }
 722:quantum/action.c ****     }
 723:quantum/action.c **** #    endif
 724:quantum/action.c **** #endif
 725:quantum/action.c **** 
 726:quantum/action.c **** #ifdef SWAP_HANDS_ENABLE
 727:quantum/action.c **** #    ifndef NO_ACTION_ONESHOT
 728:quantum/action.c ****     if (event.pressed && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)) 
 729:quantum/action.c ****         use_oneshot_swaphands();
 730:quantum/action.c ****     }
 731:quantum/action.c **** #    endif
 732:quantum/action.c **** #endif
 733:quantum/action.c **** 
 734:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 735:quantum/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 736:quantum/action.c ****      * key before we leave the layer or no key up event will be generated.
 737:quantum/action.c ****      */
 738:quantum/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED)) {
 739:quantum/action.c ****         record->event.pressed = false;
 740:quantum/action.c ****         layer_on(get_oneshot_layer());
 741:quantum/action.c ****         process_record(record);
 742:quantum/action.c ****         layer_off(get_oneshot_layer());
 743:quantum/action.c ****     }
 744:quantum/action.c **** #endif
 745:quantum/action.c **** }
 746:quantum/action.c **** 
 747:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 748:quantum/action.c ****  *
 749:quantum/action.c ****  * FIXME: Needs documentation.
 750:quantum/action.c ****  */
 751:quantum/action.c **** void register_code(uint8_t code) {
 463               		.loc 1 751 34 is_stmt 1 view -0
 464               		.cfi_startproc
 465               		.loc 1 751 34 is_stmt 0 view .LVU95
 466 0000 CF93      		push r28
 467               	.LCFI10:
 468               		.cfi_def_cfa_offset 3
 469               		.cfi_offset 28, -2
 470               	/* prologue: function */
 471               	/* frame size = 0 */
 472               	/* stack size = 1 */
 473               	.L__stack_usage = 1
 474 0002 C82F      		mov r28,r24
 752:quantum/action.c ****     if (code == KC_NO) {
 475               		.loc 1 752 5 is_stmt 1 view .LVU96
 476               		.loc 1 752 8 is_stmt 0 view .LVU97
 477 0004 8823      		tst r24
 478 0006 01F0      		breq .L35
 753:quantum/action.c ****         return;
 754:quantum/action.c ****     }
 755:quantum/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 756:quantum/action.c ****     else if (KC_LOCKING_CAPS == code) {
 757:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 758:quantum/action.c ****         // Resync: ignore if caps lock already is on
 759:quantum/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK)) return;
 760:quantum/action.c **** #    endif
 761:quantum/action.c ****         add_key(KC_CAPSLOCK);
 762:quantum/action.c ****         send_keyboard_report();
 763:quantum/action.c ****         wait_ms(100);
 764:quantum/action.c ****         del_key(KC_CAPSLOCK);
 765:quantum/action.c ****         send_keyboard_report();
 766:quantum/action.c ****     }
 767:quantum/action.c **** 
 768:quantum/action.c ****     else if (KC_LOCKING_NUM == code) {
 769:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 770:quantum/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_NUM_LOCK)) return;
 771:quantum/action.c **** #    endif
 772:quantum/action.c ****         add_key(KC_NUMLOCK);
 773:quantum/action.c ****         send_keyboard_report();
 774:quantum/action.c ****         wait_ms(100);
 775:quantum/action.c ****         del_key(KC_NUMLOCK);
 776:quantum/action.c ****         send_keyboard_report();
 777:quantum/action.c ****     }
 778:quantum/action.c **** 
 779:quantum/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 780:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 781:quantum/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK)) return;
 782:quantum/action.c **** #    endif
 783:quantum/action.c ****         add_key(KC_SCROLLLOCK);
 784:quantum/action.c ****         send_keyboard_report();
 785:quantum/action.c ****         wait_ms(100);
 786:quantum/action.c ****         del_key(KC_SCROLLLOCK);
 787:quantum/action.c ****         send_keyboard_report();
 788:quantum/action.c ****     }
 789:quantum/action.c **** #endif
 790:quantum/action.c **** 
 791:quantum/action.c ****     else if IS_KEY (code) {
 479               		.loc 1 791 10 is_stmt 1 view .LVU98
 480               		.loc 1 791 13 is_stmt 0 view .LVU99
 481 0008 8CEF      		ldi r24,lo8(-4)
 482               	.LVL44:
 483               		.loc 1 791 13 view .LVU100
 484 000a 8C0F      		add r24,r28
 485 000c 813A      		cpi r24,lo8(-95)
 486 000e 00F4      		brsh .L37
 792:quantum/action.c ****         // TODO: should push command_proc out of this block?
 793:quantum/action.c ****         if (command_proc(code)) return;
 487               		.loc 1 793 9 is_stmt 1 view .LVU101
 794:quantum/action.c **** 
 795:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 796:quantum/action.c **** /* TODO: remove
 797:quantum/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 798:quantum/action.c ****             uint8_t tmp_mods = get_mods();
 799:quantum/action.c ****             add_mods(oneshot_state.mods);
 800:quantum/action.c **** 
 801:quantum/action.c ****             add_key(code);
 802:quantum/action.c ****             send_keyboard_report();
 803:quantum/action.c **** 
 804:quantum/action.c ****             set_mods(tmp_mods);
 805:quantum/action.c ****             send_keyboard_report();
 806:quantum/action.c ****             oneshot_cancel();
 807:quantum/action.c ****         } else
 808:quantum/action.c **** */
 809:quantum/action.c **** #endif
 810:quantum/action.c ****         {
 811:quantum/action.c ****             // Force a new key press if the key is already pressed
 812:quantum/action.c ****             // without this, keys with the same keycode, but different
 813:quantum/action.c ****             // modifiers will be reported incorrectly, see issue #1708
 814:quantum/action.c ****             if (is_key_pressed(keyboard_report, code)) {
 488               		.loc 1 814 13 view .LVU102
 489               		.loc 1 814 17 is_stmt 0 view .LVU103
 490 0010 6C2F      		mov r22,r28
 491 0012 8091 0000 		lds r24,keyboard_report
 492 0016 9091 0000 		lds r25,keyboard_report+1
 493 001a 0E94 0000 		call is_key_pressed
 494               	.LVL45:
 495               		.loc 1 814 16 view .LVU104
 496 001e 8823      		tst r24
 497 0020 01F0      		breq .L38
 815:quantum/action.c ****                 del_key(code);
 498               		.loc 1 815 17 is_stmt 1 view .LVU105
 499 0022 8C2F      		mov r24,r28
 500 0024 0E94 0000 		call del_key
 501               	.LVL46:
 816:quantum/action.c ****                 send_keyboard_report();
 502               		.loc 1 816 17 view .LVU106
 503 0028 0E94 0000 		call send_keyboard_report
 504               	.LVL47:
 505               	.L38:
 817:quantum/action.c ****             }
 818:quantum/action.c ****             add_key(code);
 506               		.loc 1 818 13 view .LVU107
 507 002c 8C2F      		mov r24,r28
 508 002e 0E94 0000 		call add_key
 509               	.LVL48:
 819:quantum/action.c ****             send_keyboard_report();
 510               		.loc 1 819 13 view .LVU108
 511               	.L45:
 820:quantum/action.c ****         }
 821:quantum/action.c ****     } else if IS_MOD (code) {
 822:quantum/action.c ****         add_mods(MOD_BIT(code));
 823:quantum/action.c ****         send_keyboard_report();
 512               		.loc 1 823 9 view .LVU109
 513               	/* epilogue start */
 824:quantum/action.c ****     }
 825:quantum/action.c **** #ifdef EXTRAKEY_ENABLE
 826:quantum/action.c ****     else if IS_SYSTEM (code) {
 827:quantum/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 828:quantum/action.c ****     } else if IS_CONSUMER (code) {
 829:quantum/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 830:quantum/action.c ****     }
 831:quantum/action.c **** #endif
 832:quantum/action.c **** #ifdef MOUSEKEY_ENABLE
 833:quantum/action.c ****     else if IS_MOUSEKEY (code) {
 834:quantum/action.c ****         mousekey_on(code);
 835:quantum/action.c ****         mousekey_send();
 836:quantum/action.c ****     }
 837:quantum/action.c **** #endif
 838:quantum/action.c **** }
 514               		.loc 1 838 1 is_stmt 0 view .LVU110
 515 0032 CF91      		pop r28
 823:quantum/action.c ****     }
 516               		.loc 1 823 9 view .LVU111
 517 0034 0C94 0000 		jmp send_keyboard_report
 518               	.LVL49:
 519               	.L37:
 821:quantum/action.c ****         add_mods(MOD_BIT(code));
 520               		.loc 1 821 12 is_stmt 1 view .LVU112
 821:quantum/action.c ****         add_mods(MOD_BIT(code));
 521               		.loc 1 821 15 is_stmt 0 view .LVU113
 522 0038 80E2      		ldi r24,lo8(32)
 523 003a 8C0F      		add r24,r28
 524 003c 8830      		cpi r24,lo8(8)
 525 003e 00F4      		brsh .L35
 822:quantum/action.c ****         send_keyboard_report();
 526               		.loc 1 822 9 is_stmt 1 view .LVU114
 822:quantum/action.c ****         send_keyboard_report();
 527               		.loc 1 822 18 is_stmt 0 view .LVU115
 528 0040 C770      		andi r28,lo8(7)
 529               	.LVL50:
 822:quantum/action.c ****         send_keyboard_report();
 530               		.loc 1 822 9 view .LVU116
 531 0042 81E0      		ldi r24,lo8(1)
 532 0044 00C0      		rjmp 2f
 533               		1:
 534 0046 880F      		lsl r24
 535               		2:
 536 0048 CA95      		dec r28
 537 004a 02F4      		brpl 1b
 538 004c 0E94 0000 		call add_mods
 539               	.LVL51:
 540 0050 00C0      		rjmp .L45
 541               	.LVL52:
 542               	.L35:
 543               	/* epilogue start */
 544               		.loc 1 838 1 view .LVU117
 545 0052 CF91      		pop r28
 546               	.LVL53:
 547               		.loc 1 838 1 view .LVU118
 548 0054 0895      		ret
 549               		.cfi_endproc
 550               	.LFE25:
 552               		.section	.text.unregister_code,"ax",@progbits
 553               	.global	unregister_code
 555               	unregister_code:
 556               	.LVL54:
 557               	.LFB26:
 839:quantum/action.c **** 
 840:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 841:quantum/action.c ****  *
 842:quantum/action.c ****  * FIXME: Needs documentation.
 843:quantum/action.c ****  */
 844:quantum/action.c **** void unregister_code(uint8_t code) {
 558               		.loc 1 844 36 is_stmt 1 view -0
 559               		.cfi_startproc
 560               	/* prologue: function */
 561               	/* frame size = 0 */
 562               	/* stack size = 0 */
 563               	.L__stack_usage = 0
 845:quantum/action.c ****     if (code == KC_NO) {
 564               		.loc 1 845 5 view .LVU120
 565               		.loc 1 845 8 is_stmt 0 view .LVU121
 566 0000 8823      		tst r24
 567 0002 01F0      		breq .L46
 846:quantum/action.c ****         return;
 847:quantum/action.c ****     }
 848:quantum/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 849:quantum/action.c ****     else if (KC_LOCKING_CAPS == code) {
 850:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 851:quantum/action.c ****         // Resync: ignore if caps lock already is off
 852:quantum/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK))) return;
 853:quantum/action.c **** #    endif
 854:quantum/action.c ****         add_key(KC_CAPSLOCK);
 855:quantum/action.c ****         send_keyboard_report();
 856:quantum/action.c ****         del_key(KC_CAPSLOCK);
 857:quantum/action.c ****         send_keyboard_report();
 858:quantum/action.c ****     }
 859:quantum/action.c **** 
 860:quantum/action.c ****     else if (KC_LOCKING_NUM == code) {
 861:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 862:quantum/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_NUM_LOCK))) return;
 863:quantum/action.c **** #    endif
 864:quantum/action.c ****         add_key(KC_NUMLOCK);
 865:quantum/action.c ****         send_keyboard_report();
 866:quantum/action.c ****         del_key(KC_NUMLOCK);
 867:quantum/action.c ****         send_keyboard_report();
 868:quantum/action.c ****     }
 869:quantum/action.c **** 
 870:quantum/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 871:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 872:quantum/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK))) return;
 873:quantum/action.c **** #    endif
 874:quantum/action.c ****         add_key(KC_SCROLLLOCK);
 875:quantum/action.c ****         send_keyboard_report();
 876:quantum/action.c ****         del_key(KC_SCROLLLOCK);
 877:quantum/action.c ****         send_keyboard_report();
 878:quantum/action.c ****     }
 879:quantum/action.c **** #endif
 880:quantum/action.c **** 
 881:quantum/action.c ****     else if IS_KEY (code) {
 568               		.loc 1 881 10 is_stmt 1 view .LVU122
 569               		.loc 1 881 13 is_stmt 0 view .LVU123
 570 0004 9CEF      		ldi r25,lo8(-4)
 571 0006 980F      		add r25,r24
 572 0008 913A      		cpi r25,lo8(-95)
 573 000a 00F4      		brsh .L48
 882:quantum/action.c ****         del_key(code);
 574               		.loc 1 882 9 is_stmt 1 view .LVU124
 575 000c 0E94 0000 		call del_key
 576               	.LVL55:
 883:quantum/action.c ****         send_keyboard_report();
 577               		.loc 1 883 9 view .LVU125
 578               	.L54:
 884:quantum/action.c ****     } else if IS_MOD (code) {
 885:quantum/action.c ****         del_mods(MOD_BIT(code));
 886:quantum/action.c ****         send_keyboard_report();
 579               		.loc 1 886 9 view .LVU126
 580 0010 0C94 0000 		jmp send_keyboard_report
 581               	.LVL56:
 582               	.L48:
 884:quantum/action.c ****     } else if IS_MOD (code) {
 583               		.loc 1 884 12 view .LVU127
 884:quantum/action.c ****     } else if IS_MOD (code) {
 584               		.loc 1 884 15 is_stmt 0 view .LVU128
 585 0014 90E2      		ldi r25,lo8(32)
 586 0016 980F      		add r25,r24
 587 0018 9830      		cpi r25,lo8(8)
 588 001a 00F4      		brsh .L49
 885:quantum/action.c ****         send_keyboard_report();
 589               		.loc 1 885 9 is_stmt 1 view .LVU129
 885:quantum/action.c ****         send_keyboard_report();
 590               		.loc 1 885 18 is_stmt 0 view .LVU130
 591 001c 8770      		andi r24,lo8(7)
 592               	.LVL57:
 885:quantum/action.c ****         send_keyboard_report();
 593               		.loc 1 885 9 view .LVU131
 594 001e 91E0      		ldi r25,lo8(1)
 595 0020 00C0      		rjmp 2f
 596               		1:
 597 0022 990F      		lsl r25
 598               		2:
 599 0024 8A95      		dec r24
 600 0026 02F4      		brpl 1b
 601 0028 892F      		mov r24,r25
 602 002a 0E94 0000 		call del_mods
 603               	.LVL58:
 604 002e 00C0      		rjmp .L54
 605               	.LVL59:
 606               	.L49:
 887:quantum/action.c ****     } else if IS_SYSTEM (code) {
 607               		.loc 1 887 12 is_stmt 1 view .LVU132
 608               		.loc 1 887 15 is_stmt 0 view .LVU133
 609 0030 9BE5      		ldi r25,lo8(91)
 610 0032 980F      		add r25,r24
 611 0034 9330      		cpi r25,lo8(3)
 612 0036 00F4      		brsh .L50
 888:quantum/action.c ****         host_system_send(0);
 613               		.loc 1 888 9 is_stmt 1 view .LVU134
 614 0038 90E0      		ldi r25,0
 615 003a 80E0      		ldi r24,0
 616               	.LVL60:
 617               		.loc 1 888 9 is_stmt 0 view .LVU135
 618 003c 0C94 0000 		jmp host_system_send
 619               	.LVL61:
 620               	.L50:
 889:quantum/action.c ****     } else if IS_CONSUMER (code) {
 621               		.loc 1 889 12 is_stmt 1 view .LVU136
 622               		.loc 1 889 15 is_stmt 0 view .LVU137
 623 0040 885A      		subi r24,lo8(-(88))
 624               	.LVL62:
 625               		.loc 1 889 15 view .LVU138
 626 0042 8731      		cpi r24,lo8(23)
 627 0044 00F4      		brsh .L46
 890:quantum/action.c ****         host_consumer_send(0);
 628               		.loc 1 890 9 is_stmt 1 view .LVU139
 629 0046 90E0      		ldi r25,0
 630 0048 80E0      		ldi r24,0
 631               	.LVL63:
 632               		.loc 1 890 9 is_stmt 0 view .LVU140
 633 004a 0C94 0000 		jmp host_consumer_send
 634               	.LVL64:
 635               	.L46:
 636               	/* epilogue start */
 891:quantum/action.c ****     }
 892:quantum/action.c **** #ifdef MOUSEKEY_ENABLE
 893:quantum/action.c ****     else if IS_MOUSEKEY (code) {
 894:quantum/action.c ****         mousekey_off(code);
 895:quantum/action.c ****         mousekey_send();
 896:quantum/action.c ****     }
 897:quantum/action.c **** #endif
 898:quantum/action.c **** }
 637               		.loc 1 898 1 view .LVU141
 638 004e 0895      		ret
 639               		.cfi_endproc
 640               	.LFE26:
 642               		.section	.text.tap_code_delay,"ax",@progbits
 643               	.global	tap_code_delay
 645               	tap_code_delay:
 646               	.LVL65:
 647               	.LFB27:
 899:quantum/action.c **** 
 900:quantum/action.c **** /** \brief Tap a keycode with a delay.
 901:quantum/action.c ****  *
 902:quantum/action.c ****  * \param code The basic keycode to tap.
 903:quantum/action.c ****  * \param delay The amount of time in milliseconds to leave the keycode registered, before unregist
 904:quantum/action.c ****  */
 905:quantum/action.c **** void tap_code_delay(uint8_t code, uint16_t delay) {
 648               		.loc 1 905 51 is_stmt 1 view -0
 649               		.cfi_startproc
 650               		.loc 1 905 51 is_stmt 0 view .LVU143
 651 0000 1F93      		push r17
 652               	.LCFI11:
 653               		.cfi_def_cfa_offset 3
 654               		.cfi_offset 17, -2
 655 0002 CF93      		push r28
 656               	.LCFI12:
 657               		.cfi_def_cfa_offset 4
 658               		.cfi_offset 28, -3
 659 0004 DF93      		push r29
 660               	.LCFI13:
 661               		.cfi_def_cfa_offset 5
 662               		.cfi_offset 29, -4
 663               	/* prologue: function */
 664               	/* frame size = 0 */
 665               	/* stack size = 3 */
 666               	.L__stack_usage = 3
 667 0006 182F      		mov r17,r24
 668 0008 EB01      		movw r28,r22
 906:quantum/action.c ****     register_code(code);
 669               		.loc 1 906 5 is_stmt 1 view .LVU144
 670 000a 0E94 0000 		call register_code
 671               	.LVL66:
 907:quantum/action.c ****     for (uint16_t i = delay; i > 0; i--) {
 672               		.loc 1 907 5 view .LVU145
 673               	.LBB37:
 674               		.loc 1 907 10 view .LVU146
 675               	.L56:
 676               		.loc 1 907 32 discriminator 2 view .LVU147
 677 000e 2097      		sbiw r28,0
 678 0010 01F4      		brne .L57
 679               		.loc 1 907 32 is_stmt 0 discriminator 2 view .LVU148
 680               	.LBE37:
 908:quantum/action.c ****         wait_ms(1);
 909:quantum/action.c ****     }
 910:quantum/action.c ****     unregister_code(code);
 681               		.loc 1 910 5 is_stmt 1 view .LVU149
 682 0012 812F      		mov r24,r17
 683               	/* epilogue start */
 911:quantum/action.c **** }
 684               		.loc 1 911 1 is_stmt 0 view .LVU150
 685 0014 DF91      		pop r29
 686 0016 CF91      		pop r28
 687               	.LVL67:
 688               		.loc 1 911 1 view .LVU151
 689 0018 1F91      		pop r17
 690               	.LVL68:
 910:quantum/action.c **** }
 691               		.loc 1 910 5 view .LVU152
 692 001a 0C94 0000 		jmp unregister_code
 693               	.LVL69:
 694               	.L57:
 695               	.LBB40:
 908:quantum/action.c ****         wait_ms(1);
 696               		.loc 1 908 9 is_stmt 1 view .LVU153
 908:quantum/action.c ****         wait_ms(1);
 697               		.loc 1 908 9 view .LVU154
 908:quantum/action.c ****         wait_ms(1);
 698               		.loc 1 908 9 view .LVU155
 699               	.LBB38:
 700               	.LBI38:
 701               		.file 3 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 702               		.loc 3 166 1 view .LVU156
 703               	.LBB39:
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 704               		.loc 3 168 2 view .LVU157
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 705               		.loc 3 172 2 view .LVU158
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 706               		.loc 3 173 2 view .LVU159
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 707               		.loc 3 174 2 view .LVU160
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 708               		.loc 3 184 3 view .LVU161
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 709               		.loc 3 187 2 view .LVU162
 710 001e 8FE9      		ldi r24,lo8(3999)
 711 0020 9FE0      		ldi r25,hi8(3999)
 712 0022 0197      	1:	sbiw r24,1
 713 0024 01F4      		brne 1b
 714 0026 00C0      		rjmp .
 715 0028 0000      		nop
 716               	.LVL70:
 717               		.loc 3 187 2 is_stmt 0 view .LVU163
 718               	.LBE39:
 719               	.LBE38:
 908:quantum/action.c ****     }
 720               		.loc 1 908 9 is_stmt 1 view .LVU164
 907:quantum/action.c ****         wait_ms(1);
 721               		.loc 1 907 38 view .LVU165
 722 002a 2197      		sbiw r28,1
 723               	.LVL71:
 907:quantum/action.c ****         wait_ms(1);
 724               		.loc 1 907 38 is_stmt 0 view .LVU166
 725 002c 00C0      		rjmp .L56
 726               	.LBE40:
 727               		.cfi_endproc
 728               	.LFE27:
 730               		.section	.text.tap_code,"ax",@progbits
 731               	.global	tap_code
 733               	tap_code:
 734               	.LVL72:
 735               	.LFB28:
 912:quantum/action.c **** 
 913:quantum/action.c **** /** \brief Tap a keycode with the default delay.
 914:quantum/action.c ****  *
 915:quantum/action.c ****  * \param code The basic keycode to tap. If `code` is `KC_CAPS`, the delay will be `TAP_HOLD_CAPS_D
 916:quantum/action.c ****  */
 917:quantum/action.c **** void tap_code(uint8_t code) { tap_code_delay(code, code == KC_CAPS ? TAP_HOLD_CAPS_DELAY : TAP_CODE
 736               		.loc 1 917 29 is_stmt 1 view -0
 737               		.cfi_startproc
 738               	/* prologue: function */
 739               	/* frame size = 0 */
 740               	/* stack size = 0 */
 741               	.L__stack_usage = 0
 742               		.loc 1 917 31 view .LVU168
 743 0000 6AE0      		ldi r22,lo8(10)
 744 0002 70E0      		ldi r23,0
 745 0004 8933      		cpi r24,lo8(57)
 746 0006 01F4      		brne .L59
 747 0008 60E5      		ldi r22,lo8(80)
 748 000a 70E0      		ldi r23,0
 749               	.L59:
 750               		.loc 1 917 31 is_stmt 0 discriminator 4 view .LVU169
 751 000c 0C94 0000 		jmp tap_code_delay
 752               	.LVL73:
 753               		.loc 1 917 31 discriminator 4 view .LVU170
 754               		.cfi_endproc
 755               	.LFE28:
 757               		.section	.text.register_mods,"ax",@progbits
 758               	.global	register_mods
 760               	register_mods:
 761               	.LVL74:
 762               	.LFB29:
 918:quantum/action.c **** 
 919:quantum/action.c **** /** \brief Adds the given physically pressed modifiers and sends a keyboard report immediately.
 920:quantum/action.c ****  *
 921:quantum/action.c ****  * \param mods A bitfield of modifiers to register.
 922:quantum/action.c ****  */
 923:quantum/action.c **** void register_mods(uint8_t mods) {
 763               		.loc 1 923 34 is_stmt 1 view -0
 764               		.cfi_startproc
 765               	/* prologue: function */
 766               	/* frame size = 0 */
 767               	/* stack size = 0 */
 768               	.L__stack_usage = 0
 924:quantum/action.c ****     if (mods) {
 769               		.loc 1 924 5 view .LVU172
 770               		.loc 1 924 8 is_stmt 0 view .LVU173
 771 0000 8823      		tst r24
 772 0002 01F0      		breq .L61
 925:quantum/action.c ****         add_mods(mods);
 773               		.loc 1 925 9 is_stmt 1 view .LVU174
 774 0004 0E94 0000 		call add_mods
 775               	.LVL75:
 926:quantum/action.c ****         send_keyboard_report();
 776               		.loc 1 926 9 view .LVU175
 777 0008 0C94 0000 		jmp send_keyboard_report
 778               	.LVL76:
 779               	.L61:
 780               	/* epilogue start */
 927:quantum/action.c ****     }
 928:quantum/action.c **** }
 781               		.loc 1 928 1 is_stmt 0 view .LVU176
 782 000c 0895      		ret
 783               		.cfi_endproc
 784               	.LFE29:
 786               		.section	.text.unregister_mods,"ax",@progbits
 787               	.global	unregister_mods
 789               	unregister_mods:
 790               	.LVL77:
 791               	.LFB30:
 929:quantum/action.c **** 
 930:quantum/action.c **** /** \brief Removes the given physically pressed modifiers and sends a keyboard report immediately.
 931:quantum/action.c ****  *
 932:quantum/action.c ****  * \param mods A bitfield of modifiers to unregister.
 933:quantum/action.c ****  */
 934:quantum/action.c **** void unregister_mods(uint8_t mods) {
 792               		.loc 1 934 36 is_stmt 1 view -0
 793               		.cfi_startproc
 794               	/* prologue: function */
 795               	/* frame size = 0 */
 796               	/* stack size = 0 */
 797               	.L__stack_usage = 0
 935:quantum/action.c ****     if (mods) {
 798               		.loc 1 935 5 view .LVU178
 799               		.loc 1 935 8 is_stmt 0 view .LVU179
 800 0000 8823      		tst r24
 801 0002 01F0      		breq .L63
 936:quantum/action.c ****         del_mods(mods);
 802               		.loc 1 936 9 is_stmt 1 view .LVU180
 803 0004 0E94 0000 		call del_mods
 804               	.LVL78:
 937:quantum/action.c ****         send_keyboard_report();
 805               		.loc 1 937 9 view .LVU181
 806 0008 0C94 0000 		jmp send_keyboard_report
 807               	.LVL79:
 808               	.L63:
 809               	/* epilogue start */
 938:quantum/action.c ****     }
 939:quantum/action.c **** }
 810               		.loc 1 939 1 is_stmt 0 view .LVU182
 811 000c 0895      		ret
 812               		.cfi_endproc
 813               	.LFE30:
 815               		.section	.text.process_action,"ax",@progbits
 816               	.global	process_action
 818               	process_action:
 819               	.LVL80:
 820               	.LFB24:
 255:quantum/action.c ****     keyevent_t event = record->event;
 821               		.loc 1 255 59 is_stmt 1 view -0
 822               		.cfi_startproc
 255:quantum/action.c ****     keyevent_t event = record->event;
 823               		.loc 1 255 59 is_stmt 0 view .LVU184
 824 0000 6F92      		push r6
 825               	.LCFI14:
 826               		.cfi_def_cfa_offset 3
 827               		.cfi_offset 6, -2
 828 0002 7F92      		push r7
 829               	.LCFI15:
 830               		.cfi_def_cfa_offset 4
 831               		.cfi_offset 7, -3
 832 0004 8F92      		push r8
 833               	.LCFI16:
 834               		.cfi_def_cfa_offset 5
 835               		.cfi_offset 8, -4
 836 0006 9F92      		push r9
 837               	.LCFI17:
 838               		.cfi_def_cfa_offset 6
 839               		.cfi_offset 9, -5
 840 0008 BF92      		push r11
 841               	.LCFI18:
 842               		.cfi_def_cfa_offset 7
 843               		.cfi_offset 11, -6
 844 000a CF92      		push r12
 845               	.LCFI19:
 846               		.cfi_def_cfa_offset 8
 847               		.cfi_offset 12, -7
 848 000c DF92      		push r13
 849               	.LCFI20:
 850               		.cfi_def_cfa_offset 9
 851               		.cfi_offset 13, -8
 852 000e EF92      		push r14
 853               	.LCFI21:
 854               		.cfi_def_cfa_offset 10
 855               		.cfi_offset 14, -9
 856 0010 FF92      		push r15
 857               	.LCFI22:
 858               		.cfi_def_cfa_offset 11
 859               		.cfi_offset 15, -10
 860 0012 0F93      		push r16
 861               	.LCFI23:
 862               		.cfi_def_cfa_offset 12
 863               		.cfi_offset 16, -11
 864 0014 1F93      		push r17
 865               	.LCFI24:
 866               		.cfi_def_cfa_offset 13
 867               		.cfi_offset 17, -12
 868 0016 CF93      		push r28
 869               	.LCFI25:
 870               		.cfi_def_cfa_offset 14
 871               		.cfi_offset 28, -13
 872 0018 DF93      		push r29
 873               	.LCFI26:
 874               		.cfi_def_cfa_offset 15
 875               		.cfi_offset 29, -14
 876 001a 00D0      		rcall .
 877 001c 00D0      		rcall .
 878 001e 00D0      		rcall .
 879               	.LCFI27:
 880               		.cfi_def_cfa_offset 21
 881 0020 CDB7      		in r28,__SP_L__
 882 0022 DEB7      		in r29,__SP_H__
 883               	.LCFI28:
 884               		.cfi_def_cfa_register 28
 885               	/* prologue: function */
 886               	/* frame size = 6 */
 887               	/* stack size = 19 */
 888               	.L__stack_usage = 19
 889 0024 7C01      		movw r14,r24
 890 0026 6D83      		std Y+5,r22
 891 0028 072F      		mov r16,r23
 256:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 892               		.loc 1 256 5 is_stmt 1 view .LVU185
 256:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 893               		.loc 1 256 16 is_stmt 0 view .LVU186
 894 002a FC01      		movw r30,r24
 895 002c F281      		ldd r31,Z+2
 896 002e FE83      		std Y+6,r31
 897               	.LVL81:
 258:quantum/action.c **** #endif
 898               		.loc 1 258 5 is_stmt 1 view .LVU187
 258:quantum/action.c **** #endif
 899               		.loc 1 258 36 is_stmt 0 view .LVU188
 900 0030 FC01      		movw r30,r24
 901 0032 D580      		ldd r13,Z+5
 902 0034 D294      		swap r13
 903 0036 4FE0      		ldi r20,lo8(15)
 904 0038 D422      		and r13,r20
 905               	.LVL82:
 262:quantum/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 906               		.loc 1 262 5 is_stmt 1 view .LVU189
 264:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 907               		.loc 1 264 5 view .LVU190
 264:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 908               		.loc 1 264 9 is_stmt 0 view .LVU191
 909 003a 0E94 0000 		call is_oneshot_layer_active
 910               	.LVL83:
 264:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 911               		.loc 1 264 9 view .LVU192
 912 003e C82E      		mov r12,r24
 264:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 913               		.loc 1 264 8 view .LVU193
 914 0040 8823      		tst r24
 915 0042 01F0      		breq .L66
 264:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 916               		.loc 1 264 35 discriminator 1 view .LVU194
 917 0044 6E80      		ldd r6,Y+6
 918 0046 6620      		tst r6
 919 0048 01F4      		brne .+2
 920 004a 00C0      		rjmp .L156
 264:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 921               		.loc 1 264 71 discriminator 2 view .LVU195
 922 004c 802F      		mov r24,r16
 923 004e 807F      		andi r24,lo8(-16)
 264:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 924               		.loc 1 264 52 discriminator 2 view .LVU196
 925 0050 8034      		cpi r24,lo8(64)
 926 0052 01F0      		breq .L67
 264:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 927               		.loc 1 264 87 discriminator 3 view .LVU197
 928 0054 9D81      		ldd r25,Y+5
 929 0056 905E      		subi r25,lo8(-(32))
 264:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 930               		.loc 1 264 84 discriminator 3 view .LVU198
 931 0058 9830      		cpi r25,lo8(8)
 932 005a 00F0      		brlo .L156
 266:quantum/action.c **** #    endif
 933               		.loc 1 266 9 view .LVU199
 934 005c 8036      		cpi r24,lo8(96)
 935 005e 01F4      		brne .L67
 266:quantum/action.c **** #    endif
 936               		.loc 1 266 12 discriminator 1 view .LVU200
 937 0060 2D81      		ldd r18,Y+5
 938 0062 263F      		cpi r18,lo8(-10)
 939 0064 01F0      		breq .L156
 940               	.L67:
 269:quantum/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 941               		.loc 1 269 9 is_stmt 1 view .LVU201
 942 0066 82E0      		ldi r24,lo8(2)
 943 0068 0E94 0000 		call clear_oneshot_layer_state
 944               	.LVL84:
 270:quantum/action.c ****     }
 945               		.loc 1 270 9 view .LVU202
 270:quantum/action.c ****     }
 946               		.loc 1 270 31 is_stmt 0 view .LVU203
 947 006c 0E94 0000 		call is_oneshot_layer_active
 948               	.LVL85:
 270:quantum/action.c ****     }
 949               		.loc 1 270 9 view .LVU204
 950 0070 91E0      		ldi r25,lo8(1)
 951 0072 C82E      		mov r12,r24
 952 0074 C926      		eor r12,r25
 953               	.LVL86:
 954               	.L66:
 274:quantum/action.c ****         /* Key and Mods */
 955               		.loc 1 274 5 is_stmt 1 view .LVU205
 274:quantum/action.c ****         /* Key and Mods */
 956               		.loc 1 274 24 is_stmt 0 view .LVU206
 957 0076 B02E      		mov r11,r16
 958 0078 B294      		swap r11
 959 007a 3FE0      		ldi r19,lo8(15)
 960 007c B322      		and r11,r19
 274:quantum/action.c ****         /* Key and Mods */
 961               		.loc 1 274 5 view .LVU207
 962 007e 38E0      		ldi r19,lo8(8)
 963 0080 B316      		cp r11,r19
 964 0082 01F4      		brne .+2
 965 0084 00C0      		rjmp .L68
 966 0086 3B15      		cp r19,r11
 967 0088 00F4      		brsh .+2
 968 008a 00C0      		rjmp .L69
 969 008c 83E0      		ldi r24,lo8(3)
 970 008e 8B15      		cp r24,r11
 971 0090 00F0      		brlo .L70
 972 0092 802F      		mov r24,r16
 973 0094 807F      		andi r24,lo8(-16)
 974 0096 102F      		mov r17,r16
 975 0098 1F70      		andi r17,lo8(15)
 976 009a 91E0      		ldi r25,lo8(1)
 977 009c 9B15      		cp r25,r11
 978 009e 00F0      		brlo .+2
 979 00a0 00C0      		rjmp .L198
 980               	.LBB41:
 307:quantum/action.c ****             switch (action.layer_tap.code) {
 981               		.loc 1 307 13 is_stmt 1 view .LVU208
 307:quantum/action.c ****             switch (action.layer_tap.code) {
 982               		.loc 1 307 21 is_stmt 0 view .LVU209
 983 00a2 8032      		cpi r24,lo8(32)
 984 00a4 01F0      		breq .L88
 307:quantum/action.c ****             switch (action.layer_tap.code) {
 985               		.loc 1 307 21 discriminator 2 view .LVU210
 986 00a6 1295      		swap r17
 987 00a8 107F      		andi r17,lo8(-16)
 988               	.L88:
 989               	.LVL87:
 308:quantum/action.c **** #    ifndef NO_ACTION_ONESHOT
 990               		.loc 1 308 13 is_stmt 1 discriminator 4 view .LVU211
 991 00aa 9D80      		ldd r9,Y+5
 992 00ac 9920      		tst r9
 993 00ae 01F4      		brne .+2
 994 00b0 00C0      		rjmp .L89
 995 00b2 292D      		mov r18,r9
 996 00b4 2130      		cpi r18,lo8(1)
 997 00b6 01F4      		brne .+2
 998 00b8 00C0      		rjmp .L90
 363:quantum/action.c ****                         if (tap_count > 0) {
 999               		.loc 1 363 21 view .LVU212
 363:quantum/action.c ****                         if (tap_count > 0) {
 1000               		.loc 1 363 24 is_stmt 0 view .LVU213
 1001 00ba 6E80      		ldd r6,Y+6
 1002 00bc 6620      		tst r6
 1003 00be 01F4      		brne .+2
 1004 00c0 00C0      		rjmp .L98
 364:quantum/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 1005               		.loc 1 364 25 is_stmt 1 view .LVU214
 364:quantum/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 1006               		.loc 1 364 28 is_stmt 0 view .LVU215
 1007 00c2 DD20      		tst r13
 1008 00c4 01F4      		brne .+2
 1009 00c6 00C0      		rjmp .L99
 366:quantum/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 1010               		.loc 1 366 29 is_stmt 1 view .LVU216
 370:quantum/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 1011               		.loc 1 370 33 is_stmt 0 view .LVU217
 1012 00c8 F701      		movw r30,r14
 1013 00ca 8581      		ldd r24,Z+5
 366:quantum/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 1014               		.loc 1 366 32 view .LVU218
 1015 00cc 80FF      		sbrs r24,0
 1016 00ce 00C0      		rjmp .L203
 371:quantum/action.c ****                                 // ad hoc: set 0 to cancel tap
 1017               		.loc 1 371 76 is_stmt 1 view .LVU219
 373:quantum/action.c ****                                 register_mods(mods);
 1018               		.loc 1 373 33 view .LVU220
 373:quantum/action.c ****                                 register_mods(mods);
 1019               		.loc 1 373 51 is_stmt 0 view .LVU221
 1020 00d0 8F70      		andi r24,lo8(15)
 1021 00d2 8583      		std Z+5,r24
 374:quantum/action.c ****                             } else
 1022               		.loc 1 374 33 is_stmt 1 view .LVU222
 1023 00d4 00C0      		rjmp .L99
 1024               	.LVL88:
 1025               	.L156:
 374:quantum/action.c ****                             } else
 1026               		.loc 1 374 33 is_stmt 0 view .LVU223
 1027               	.LBE41:
 262:quantum/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 1028               		.loc 1 262 10 view .LVU224
 1029 00d6 C12C      		mov r12,__zero_reg__
 1030 00d8 00C0      		rjmp .L66
 1031               	.LVL89:
 1032               	.L70:
 274:quantum/action.c ****         /* Key and Mods */
 1033               		.loc 1 274 5 view .LVU225
 1034 00da E6E0      		ldi r30,lo8(6)
 1035 00dc BE16      		cp r11,r30
 1036 00de 01F4      		brne .+2
 1037 00e0 00C0      		rjmp .L73
 1038               	.L74:
 685:quantum/action.c ****         case ACT_LAYER:
 1039               		.loc 1 685 5 is_stmt 1 view .LVU226
 1040 00e2 2B2D      		mov r18,r11
 1041 00e4 2850      		subi r18,8
 1042 00e6 330B      		sbc r19,r19
 1043 00e8 2430      		cpi r18,4
 1044 00ea 3105      		cpc r19,__zero_reg__
 1045 00ec 00F4      		brsh .L148
 692:quantum/action.c ****             break;
 1046               		.loc 1 692 13 view .LVU227
 1047 00ee 0E94 0000 		call host_keyboard_leds
 1048               	.LVL90:
 1049 00f2 0E94 0000 		call led_set
 1050               	.LVL91:
 693:quantum/action.c ****         default:
 1051               		.loc 1 693 13 view .LVU228
 1052               	.L148:
 728:quantum/action.c ****         use_oneshot_swaphands();
 1053               		.loc 1 728 5 view .LVU229
 728:quantum/action.c ****         use_oneshot_swaphands();
 1054               		.loc 1 728 8 is_stmt 0 view .LVU230
 1055 00f6 6E80      		ldd r6,Y+6
 1056 00f8 6620      		tst r6
 1057 00fa 01F0      		breq .L149
 728:quantum/action.c ****         use_oneshot_swaphands();
 1058               		.loc 1 728 43 discriminator 1 view .LVU231
 1059 00fc 007F      		andi r16,lo8(-16)
 728:quantum/action.c ****         use_oneshot_swaphands();
 1060               		.loc 1 728 23 discriminator 1 view .LVU232
 1061 00fe 0036      		cpi r16,lo8(96)
 1062 0100 01F4      		brne .L150
 728:quantum/action.c ****         use_oneshot_swaphands();
 1063               		.loc 1 728 26 discriminator 2 view .LVU233
 1064 0102 2D81      		ldd r18,Y+5
 1065 0104 263F      		cpi r18,lo8(-10)
 1066 0106 01F0      		breq .L149
 1067               	.L150:
 729:quantum/action.c ****     }
 1068               		.loc 1 729 9 is_stmt 1 view .LVU234
 1069 0108 0E94 0000 		call use_oneshot_swaphands
 1070               	.LVL92:
 1071               	.L149:
 738:quantum/action.c ****         record->event.pressed = false;
 1072               		.loc 1 738 5 view .LVU235
 738:quantum/action.c ****         record->event.pressed = false;
 1073               		.loc 1 738 8 is_stmt 0 view .LVU236
 1074 010c CC20      		tst r12
 1075 010e 01F4      		brne .+2
 1076 0110 00C0      		rjmp .L65
 738:quantum/action.c ****         record->event.pressed = false;
 1077               		.loc 1 738 33 discriminator 1 view .LVU237
 1078 0112 0E94 0000 		call get_oneshot_layer_state
 1079               	.LVL93:
 738:quantum/action.c ****         record->event.pressed = false;
 1080               		.loc 1 738 28 discriminator 1 view .LVU238
 1081 0116 80FD      		sbrc r24,0
 1082 0118 00C0      		rjmp .L65
 739:quantum/action.c ****         layer_on(get_oneshot_layer());
 1083               		.loc 1 739 9 is_stmt 1 view .LVU239
 739:quantum/action.c ****         layer_on(get_oneshot_layer());
 1084               		.loc 1 739 31 is_stmt 0 view .LVU240
 1085 011a F701      		movw r30,r14
 1086 011c 1282      		std Z+2,__zero_reg__
 740:quantum/action.c ****         process_record(record);
 1087               		.loc 1 740 9 is_stmt 1 view .LVU241
 1088 011e 0E94 0000 		call get_oneshot_layer
 1089               	.LVL94:
 1090 0122 0E94 0000 		call layer_on
 1091               	.LVL95:
 741:quantum/action.c ****         layer_off(get_oneshot_layer());
 1092               		.loc 1 741 9 view .LVU242
 1093 0126 C701      		movw r24,r14
 1094 0128 0E94 0000 		call process_record
 1095               	.LVL96:
 742:quantum/action.c ****     }
 1096               		.loc 1 742 9 view .LVU243
 1097 012c 0E94 0000 		call get_oneshot_layer
 1098               	.LVL97:
 1099               	/* epilogue start */
 745:quantum/action.c **** 
 1100               		.loc 1 745 1 is_stmt 0 view .LVU244
 1101 0130 2696      		adiw r28,6
 1102 0132 0FB6      		in __tmp_reg__,__SREG__
 1103 0134 F894      		cli
 1104 0136 DEBF      		out __SP_H__,r29
 1105 0138 0FBE      		out __SREG__,__tmp_reg__
 1106 013a CDBF      		out __SP_L__,r28
 1107 013c DF91      		pop r29
 1108 013e CF91      		pop r28
 1109 0140 1F91      		pop r17
 1110 0142 0F91      		pop r16
 745:quantum/action.c **** 
 1111               		.loc 1 745 1 view .LVU245
 1112 0144 FF90      		pop r15
 1113 0146 EF90      		pop r14
 1114               	.LVL98:
 745:quantum/action.c **** 
 1115               		.loc 1 745 1 view .LVU246
 1116 0148 DF90      		pop r13
 1117               	.LVL99:
 745:quantum/action.c **** 
 1118               		.loc 1 745 1 view .LVU247
 1119 014a CF90      		pop r12
 1120               	.LVL100:
 745:quantum/action.c **** 
 1121               		.loc 1 745 1 view .LVU248
 1122 014c BF90      		pop r11
 1123 014e 9F90      		pop r9
 1124 0150 8F90      		pop r8
 1125 0152 7F90      		pop r7
 1126 0154 6F90      		pop r6
 742:quantum/action.c ****     }
 1127               		.loc 1 742 9 view .LVU249
 1128 0156 0C94 0000 		jmp layer_off
 1129               	.LVL101:
 1130               	.L69:
 274:quantum/action.c ****         /* Key and Mods */
 1131               		.loc 1 274 5 view .LVU250
 1132 015a F9E0      		ldi r31,lo8(9)
 1133 015c BF16      		cp r11,r31
 1134 015e 01F4      		brne .+2
 1135 0160 00C0      		rjmp .L75
 1136 0162 86E0      		ldi r24,lo8(6)
 1137 0164 8B0D      		add r24,r11
 1138 0166 8F70      		andi r24,lo8(15)
 1139 0168 8230      		cpi r24,lo8(2)
 1140 016a 00F0      		brlo .+2
 1141 016c 00C0      		rjmp .L74
 506:quantum/action.c ****                 case OP_TAP_TOGGLE:
 1142               		.loc 1 506 13 is_stmt 1 view .LVU251
 1143 016e 2D81      		ldd r18,Y+5
 1144 0170 223F      		cpi r18,lo8(-14)
 1145 0172 01F0      		breq .+2
 1146 0174 00C0      		rjmp .L199
 523:quantum/action.c ****                     break;
 1147               		.loc 1 523 21 view .LVU252
 511:quantum/action.c ****                         }
 1148               		.loc 1 511 58 is_stmt 0 view .LVU253
 1149 0176 802F      		mov r24,r16
 1150 0178 8F71      		andi r24,lo8(31)
 523:quantum/action.c ****                     break;
 1151               		.loc 1 523 69 view .LVU254
 1152 017a 6E80      		ldd r6,Y+6
 1153 017c 6620      		tst r6
 1154 017e 01F4      		brne .+2
 1155 0180 00C0      		rjmp .L208
 1156 0182 00C0      		rjmp .L209
 1157               	.L198:
 1158               	.LBB44:
 278:quantum/action.c ****             if (event.pressed) {
 1159               		.loc 1 278 13 is_stmt 1 view .LVU255
 278:quantum/action.c ****             if (event.pressed) {
 1160               		.loc 1 278 21 is_stmt 0 view .LVU256
 1161 0184 8823      		tst r24
 1162 0186 01F0      		breq .L78
 278:quantum/action.c ****             if (event.pressed) {
 1163               		.loc 1 278 21 discriminator 2 view .LVU257
 1164 0188 1295      		swap r17
 1165 018a 107F      		andi r17,lo8(-16)
 1166               	.L78:
 1167               	.LVL102:
 279:quantum/action.c ****                 if (mods) {
 1168               		.loc 1 279 13 is_stmt 1 discriminator 4 view .LVU258
 279:quantum/action.c ****                 if (mods) {
 1169               		.loc 1 279 16 is_stmt 0 discriminator 4 view .LVU259
 1170 018c 6E80      		ldd r6,Y+6
 1171 018e 6620      		tst r6
 1172 0190 01F0      		breq .L79
 280:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1173               		.loc 1 280 17 is_stmt 1 view .LVU260
 280:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1174               		.loc 1 280 20 is_stmt 0 view .LVU261
 1175 0192 1123      		tst r17
 1176 0194 01F0      		breq .L203
 281:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1177               		.loc 1 281 21 is_stmt 1 view .LVU262
 281:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1178               		.loc 1 281 25 is_stmt 0 view .LVU263
 1179 0196 8D81      		ldd r24,Y+5
 1180 0198 805E      		subi r24,lo8(-(32))
 281:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1181               		.loc 1 281 24 view .LVU264
 1182 019a 8830      		cpi r24,lo8(8)
 1183 019c 00F0      		brlo .L81
 281:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1184               		.loc 1 281 49 discriminator 1 view .LVU265
 1185 019e 7D80      		ldd r7,Y+5
 1186 01a0 7110      		cpse r7,__zero_reg__
 1187 01a2 00C0      		rjmp .L82
 1188               	.L81:
 285:quantum/action.c ****                     } else {
 1189               		.loc 1 285 25 is_stmt 1 view .LVU266
 1190 01a4 812F      		mov r24,r17
 1191 01a6 0E94 0000 		call add_mods
 1192               	.LVL103:
 1193               	.L83:
 289:quantum/action.c ****                 }
 1194               		.loc 1 289 21 view .LVU267
 1195 01aa 0E94 0000 		call send_keyboard_report
 1196               	.LVL104:
 291:quantum/action.c ****             } else {
 1197               		.loc 1 291 17 view .LVU268
 1198               	.L203:
 291:quantum/action.c ****             } else {
 1199               		.loc 1 291 17 is_stmt 0 view .LVU269
 1200               	.LBE44:
 659:quantum/action.c ****                         } else {
 1201               		.loc 1 659 29 is_stmt 1 view .LVU270
 1202 01ae 8D81      		ldd r24,Y+5
 1203 01b0 0E94 0000 		call register_code
 1204               	.LVL105:
 1205 01b4 00C0      		rjmp .L74
 1206               	.LVL106:
 1207               	.L82:
 1208               	.LBB45:
 287:quantum/action.c ****                     }
 1209               		.loc 1 287 25 view .LVU271
 1210 01b6 812F      		mov r24,r17
 1211 01b8 0E94 0000 		call add_weak_mods
 1212               	.LVL107:
 1213 01bc 00C0      		rjmp .L83
 1214               	.L79:
 293:quantum/action.c ****                 if (mods) {
 1215               		.loc 1 293 17 view .LVU272
 1216 01be 8D81      		ldd r24,Y+5
 1217 01c0 0E94 0000 		call unregister_code
 1218               	.LVL108:
 294:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1219               		.loc 1 294 17 view .LVU273
 294:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1220               		.loc 1 294 20 is_stmt 0 view .LVU274
 1221 01c4 1123      		tst r17
 1222 01c6 01F4      		brne .+2
 1223 01c8 00C0      		rjmp .L74
 295:quantum/action.c ****                         del_mods(mods);
 1224               		.loc 1 295 21 is_stmt 1 view .LVU275
 295:quantum/action.c ****                         del_mods(mods);
 1225               		.loc 1 295 25 is_stmt 0 view .LVU276
 1226 01ca 8D81      		ldd r24,Y+5
 1227 01cc 805E      		subi r24,lo8(-(32))
 295:quantum/action.c ****                         del_mods(mods);
 1228               		.loc 1 295 24 view .LVU277
 1229 01ce 8830      		cpi r24,lo8(8)
 1230 01d0 00F0      		brlo .L85
 295:quantum/action.c ****                         del_mods(mods);
 1231               		.loc 1 295 49 discriminator 1 view .LVU278
 1232 01d2 8D80      		ldd r8,Y+5
 1233 01d4 8110      		cpse r8,__zero_reg__
 1234 01d6 00C0      		rjmp .L86
 1235               	.L85:
 296:quantum/action.c ****                     } else {
 1236               		.loc 1 296 25 is_stmt 1 view .LVU279
 1237 01d8 812F      		mov r24,r17
 1238 01da 0E94 0000 		call del_mods
 1239               	.LVL109:
 1240               	.L87:
 300:quantum/action.c ****                 }
 1241               		.loc 1 300 21 view .LVU280
 1242 01de 0E94 0000 		call send_keyboard_report
 1243               	.LVL110:
 1244 01e2 00C0      		rjmp .L74
 1245               	.L86:
 298:quantum/action.c ****                     }
 1246               		.loc 1 298 25 view .LVU281
 1247 01e4 812F      		mov r24,r17
 1248 01e6 0E94 0000 		call del_weak_mods
 1249               	.LVL111:
 1250 01ea 00C0      		rjmp .L87
 1251               	.LVL112:
 1252               	.L89:
 298:quantum/action.c ****                     }
 1253               		.loc 1 298 25 is_stmt 0 view .LVU282
 1254               	.LBE45:
 1255               	.LBB46:
 312:quantum/action.c ****                         if (tap_count == 0) {
 1256               		.loc 1 312 21 is_stmt 1 view .LVU283
 312:quantum/action.c ****                         if (tap_count == 0) {
 1257               		.loc 1 312 24 is_stmt 0 view .LVU284
 1258 01ec 6E80      		ldd r6,Y+6
 1259 01ee 6620      		tst r6
 1260 01f0 01F0      		breq .L92
 313:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 1261               		.loc 1 313 25 is_stmt 1 view .LVU285
 313:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 1262               		.loc 1 313 28 is_stmt 0 view .LVU286
 1263 01f2 D110      		cpse r13,__zero_reg__
 1264 01f4 00C0      		rjmp .L93
 1265               	.L94:
 327:quantum/action.c ****                         }
 1266               		.loc 1 327 29 is_stmt 1 view .LVU287
 327:quantum/action.c ****                         }
 1267               		.loc 1 327 50 is_stmt 0 view .LVU288
 1268 01f6 0E94 0000 		call get_oneshot_mods
 1269               	.LVL113:
 327:quantum/action.c ****                         }
 1270               		.loc 1 327 29 view .LVU289
 1271 01fa 812B      		or r24,r17
 1272               	.LVL114:
 1273               	.L204:
 327:quantum/action.c ****                         }
 1274               		.loc 1 327 29 view .LVU290
 1275               	.LBE46:
 497:quantum/action.c ****             } else {
 1276               		.loc 1 497 17 view .LVU291
 1277 01fc 0E94 0000 		call register_mods
 1278               	.LVL115:
 1279 0200 00C0      		rjmp .L74
 1280               	.LVL116:
 1281               	.L93:
 1282               	.LBB47:
 316:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1283               		.loc 1 316 32 is_stmt 1 view .LVU292
 316:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1284               		.loc 1 316 35 is_stmt 0 view .LVU293
 1285 0202 7724      		clr r7
 1286 0204 7394      		inc r7
 1287 0206 D710      		cpse r13,r7
 1288 0208 00C0      		rjmp .L94
 317:quantum/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 1289               		.loc 1 317 65 is_stmt 1 view .LVU294
 318:quantum/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1290               		.loc 1 318 29 view .LVU295
 318:quantum/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1291               		.loc 1 318 53 is_stmt 0 view .LVU296
 1292 020a 0E94 0000 		call get_oneshot_mods
 1293               	.LVL117:
 318:quantum/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1294               		.loc 1 318 29 view .LVU297
 1295 020e 812B      		or r24,r17
 1296 0210 0E94 0000 		call set_oneshot_mods
 1297               	.LVL118:
 1298 0214 00C0      		rjmp .L74
 1299               	.L92:
 330:quantum/action.c ****                             clear_oneshot_mods();
 1300               		.loc 1 330 25 is_stmt 1 view .LVU298
 330:quantum/action.c ****                             clear_oneshot_mods();
 1301               		.loc 1 330 28 is_stmt 0 view .LVU299
 1302 0216 D110      		cpse r13,__zero_reg__
 1303 0218 00C0      		rjmp .L95
 1304               	.L210:
 345:quantum/action.c ****                             unregister_mods(mods);
 1305               		.loc 1 345 29 is_stmt 1 view .LVU300
 1306 021a 0E94 0000 		call clear_oneshot_mods
 1307               	.LVL119:
 346:quantum/action.c ****                         }
 1308               		.loc 1 346 29 view .LVU301
 1309               	.L101:
 395:quantum/action.c ****                             unregister_mods(mods);
 1310               		.loc 1 395 67 view .LVU302
 396:quantum/action.c ****                         }
 1311               		.loc 1 396 29 view .LVU303
 1312 021e 812F      		mov r24,r17
 1313 0220 0E94 0000 		call unregister_mods
 1314               	.LVL120:
 1315 0224 00C0      		rjmp .L74
 1316               	.L95:
 333:quantum/action.c ****                             // Retain Oneshot mods
 1317               		.loc 1 333 32 view .LVU304
 333:quantum/action.c ****                             // Retain Oneshot mods
 1318               		.loc 1 333 35 is_stmt 0 view .LVU305
 1319 0226 8824      		clr r8
 1320 0228 8394      		inc r8
 1321 022a D814      		cp r13,r8
 1322 022c 01F4      		brne .+2
 1323 022e 00C0      		rjmp .L74
 1324 0230 00C0      		rjmp .L210
 1325               	.L90:
 352:quantum/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1326               		.loc 1 352 21 is_stmt 1 view .LVU306
 352:quantum/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1327               		.loc 1 352 24 is_stmt 0 view .LVU307
 1328 0232 9E80      		ldd r9,Y+6
 1329 0234 9920      		tst r9
 1330 0236 01F0      		breq .L97
 353:quantum/action.c ****                             register_mods(mods);
 1331               		.loc 1 353 25 is_stmt 1 view .LVU308
 353:quantum/action.c ****                             register_mods(mods);
 1332               		.loc 1 353 28 is_stmt 0 view .LVU309
 1333 0238 25E0      		ldi r18,lo8(5)
 1334 023a 2D15      		cp r18,r13
 1335 023c 00F4      		brsh .+2
 1336 023e 00C0      		rjmp .L74
 1337               	.L99:
 382:quantum/action.c ****                             register_mods(mods);
 1338               		.loc 1 382 67 is_stmt 1 view .LVU310
 383:quantum/action.c ****                         }
 1339               		.loc 1 383 29 view .LVU311
 1340 0240 812F      		mov r24,r17
 1341 0242 00C0      		rjmp .L204
 1342               	.L97:
 357:quantum/action.c ****                             unregister_mods(mods);
 1343               		.loc 1 357 25 view .LVU312
 357:quantum/action.c ****                             unregister_mods(mods);
 1344               		.loc 1 357 28 is_stmt 0 view .LVU313
 1345 0244 34E0      		ldi r19,lo8(4)
 1346 0246 3D15      		cp r19,r13
 1347 0248 00F4      		brsh .+2
 1348 024a 00C0      		rjmp .L74
 1349 024c 00C0      		rjmp .L101
 1350               	.L98:
 386:quantum/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1351               		.loc 1 386 25 is_stmt 1 view .LVU314
 386:quantum/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1352               		.loc 1 386 28 is_stmt 0 view .LVU315
 1353 024e DD20      		tst r13
 1354 0250 01F0      		breq .L101
 387:quantum/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1355               		.loc 1 387 71 is_stmt 1 view .LVU316
 388:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1356               		.loc 1 388 29 view .LVU317
 388:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1357               		.loc 1 388 32 is_stmt 0 view .LVU318
 1358 0252 FD81      		ldd r31,Y+5
 1359 0254 F933      		cpi r31,lo8(57)
 1360 0256 01F0      		breq .+2
 1361 0258 00C0      		rjmp .L131
 389:quantum/action.c ****                             } else {
 1362               		.loc 1 389 33 is_stmt 1 view .LVU319
 389:quantum/action.c ****                             } else {
 1363               		.loc 1 389 33 view .LVU320
 389:quantum/action.c ****                             } else {
 1364               		.loc 1 389 33 view .LVU321
 1365               	.LVL121:
 1366               	.LBB42:
 1367               	.LBI42:
 166:/usr/avr/include/util/delay.h **** {
 1368               		.loc 3 166 1 view .LVU322
 1369               	.LBB43:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1370               		.loc 3 168 2 view .LVU323
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1371               		.loc 3 172 2 view .LVU324
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1372               		.loc 3 173 2 view .LVU325
 174:/usr/avr/include/util/delay.h **** 
 1373               		.loc 3 174 2 view .LVU326
 184:/usr/avr/include/util/delay.h **** 	#endif
 1374               		.loc 3 184 3 view .LVU327
 1375               		.loc 3 187 2 view .LVU328
 1376 025a 2FEF      		ldi r18,lo8(255999)
 1377 025c 37EE      		ldi r19,hi8(255999)
 1378 025e 83E0      		ldi r24,hlo8(255999)
 1379 0260 2150      	1:	subi r18,1
 1380 0262 3040      		sbci r19,0
 1381 0264 8040      		sbci r24,0
 1382 0266 01F4      		brne 1b
 1383               	.LVL122:
 1384               	.L202:
 1385               		.loc 3 187 2 is_stmt 0 view .LVU329
 1386               	.LBE43:
 1387               	.LBE42:
 1388               	.LBE47:
 1389               	.LBB48:
 1390               	.LBB49:
 1391 0268 00C0      		rjmp .
 1392 026a 0000      		nop
 1393               	.LBE49:
 1394               	.LBE48:
 582:quantum/action.c ****                             }
 1395               		.loc 1 582 33 is_stmt 1 view .LVU330
 584:quantum/action.c ****                         } else {
 1396               		.loc 1 584 29 view .LVU331
 1397 026c 8D81      		ldd r24,Y+5
 1398 026e 0E94 0000 		call unregister_code
 1399               	.LVL123:
 1400 0272 00C0      		rjmp .L74
 1401               	.L68:
 450:quantum/action.c ****                 /* Default Layer Bitwise Operation */
 1402               		.loc 1 450 13 view .LVU332
 450:quantum/action.c ****                 /* Default Layer Bitwise Operation */
 1403               		.loc 1 450 39 is_stmt 0 view .LVU333
 1404 0274 802F      		mov r24,r16
 1405 0276 8370      		andi r24,lo8(3)
 450:quantum/action.c ****                 /* Default Layer Bitwise Operation */
 1406               		.loc 1 450 16 view .LVU334
 1407 0278 01F0      		breq .+2
 1408 027a 00C0      		rjmp .L104
 452:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1409               		.loc 1 452 17 is_stmt 1 view .LVU335
 452:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1410               		.loc 1 452 20 is_stmt 0 view .LVU336
 1411 027c 6E80      		ldd r6,Y+6
 1412 027e 6110      		cpse r6,__zero_reg__
 1413 0280 00C0      		rjmp .L74
 1414               	.LBB51:
 453:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1415               		.loc 1 453 21 is_stmt 1 view .LVU337
 1416               	.LVL124:
 454:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1417               		.loc 1 454 21 view .LVU338
 453:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1418               		.loc 1 453 61 is_stmt 0 view .LVU339
 1419 0282 2D81      		ldd r18,Y+5
 1420 0284 2295      		swap r18
 1421 0286 2695      		lsr r18
 1422 0288 2770      		andi r18,lo8(7)
 453:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1423               		.loc 1 453 35 view .LVU340
 1424 028a 220F      		lsl r18
 1425 028c 220F      		lsl r18
 454:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1426               		.loc 1 454 77 view .LVU341
 1427 028e 4D81      		ldd r20,Y+5
 1428 0290 4F70      		andi r20,lo8(15)
 454:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1429               		.loc 1 454 44 view .LVU342
 1430 0292 50E0      		ldi r21,0
 1431 0294 70E0      		ldi r23,0
 1432 0296 60E0      		ldi r22,0
 454:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1433               		.loc 1 454 35 view .LVU343
 1434 0298 022E      		mov r0,r18
 1435 029a 00C0      		rjmp 2f
 1436               		1:
 1437 029c 440F      		lsl r20
 1438 029e 551F      		rol r21
 1439 02a0 661F      		rol r22
 1440 02a2 771F      		rol r23
 1441               		2:
 1442 02a4 0A94      		dec r0
 1443 02a6 02F4      		brpl 1b
 1444               	.LVL125:
 455:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1445               		.loc 1 455 21 is_stmt 1 view .LVU344
 455:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1446               		.loc 1 455 104 is_stmt 0 view .LVU345
 1447 02a8 7D80      		ldd r7,Y+5
 1448 02aa 80E0      		ldi r24,0
 1449 02ac 90E0      		ldi r25,0
 1450 02ae DC01      		movw r26,r24
 1451 02b0 74FE      		sbrs r7,4
 1452 02b2 00C0      		rjmp .L105
 455:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1453               		.loc 1 455 94 discriminator 1 view .LVU346
 1454 02b4 8FE0      		ldi r24,lo8(15)
 1455 02b6 90E0      		ldi r25,0
 1456 02b8 A0E0      		ldi r26,0
 1457 02ba B0E0      		ldi r27,0
 1458 02bc 00C0      		rjmp 2f
 1459               		1:
 1460 02be 880F      		lsl r24
 1461 02c0 991F      		rol r25
 1462 02c2 AA1F      		rol r26
 1463 02c4 BB1F      		rol r27
 1464               		2:
 1465 02c6 2A95      		dec r18
 1466 02c8 02F4      		brpl 1b
 455:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1467               		.loc 1 455 104 discriminator 1 view .LVU347
 1468 02ca 8095      		com r24
 1469 02cc 9095      		com r25
 1470 02ce A095      		com r26
 1471 02d0 B095      		com r27
 1472               	.L105:
 1473               	.LVL126:
 456:quantum/action.c ****                         case OP_BIT_AND:
 1474               		.loc 1 456 21 is_stmt 1 discriminator 4 view .LVU348
 456:quantum/action.c ****                         case OP_BIT_AND:
 1475               		.loc 1 456 47 is_stmt 0 discriminator 4 view .LVU349
 1476 02d2 202F      		mov r18,r16
 1477 02d4 2695      		lsr r18
 1478 02d6 2695      		lsr r18
 1479 02d8 2370      		andi r18,lo8(3)
 458:quantum/action.c ****                             break;
 1480               		.loc 1 458 29 discriminator 4 view .LVU350
 1481 02da 3C01      		movw r6,r24
 1482 02dc 4D01      		movw r8,r26
 1483 02de 642A      		or r6,r20
 1484 02e0 752A      		or r7,r21
 1485 02e2 862A      		or r8,r22
 1486 02e4 972A      		or r9,r23
 1487 02e6 6982      		std Y+1,r6
 1488 02e8 7A82      		std Y+2,r7
 1489 02ea 8B82      		std Y+3,r8
 1490 02ec 9C82      		std Y+4,r9
 1491 02ee 2230      		cpi r18,lo8(2)
 1492 02f0 01F0      		breq .L106
 1493 02f2 2330      		cpi r18,lo8(3)
 1494 02f4 01F0      		breq .L107
 1495 02f6 2130      		cpi r18,lo8(1)
 1496 02f8 01F0      		breq .L108
 458:quantum/action.c ****                             break;
 1497               		.loc 1 458 29 is_stmt 1 view .LVU351
 1498 02fa C401      		movw r24,r8
 1499               	.LVL127:
 458:quantum/action.c ****                             break;
 1500               		.loc 1 458 29 is_stmt 0 view .LVU352
 1501 02fc B301      		movw r22,r6
 1502 02fe 0E94 0000 		call default_layer_and
 1503               	.LVL128:
 459:quantum/action.c ****                         case OP_BIT_OR:
 1504               		.loc 1 459 29 is_stmt 1 view .LVU353
 1505 0302 00C0      		rjmp .L74
 1506               	.LVL129:
 1507               	.L108:
 461:quantum/action.c ****                             break;
 1508               		.loc 1 461 29 view .LVU354
 1509 0304 6981      		ldd r22,Y+1
 1510 0306 7A81      		ldd r23,Y+2
 1511 0308 8B81      		ldd r24,Y+3
 1512 030a 9C81      		ldd r25,Y+4
 1513 030c 0E94 0000 		call default_layer_or
 1514               	.LVL130:
 462:quantum/action.c ****                         case OP_BIT_XOR:
 1515               		.loc 1 462 29 view .LVU355
 1516 0310 00C0      		rjmp .L74
 1517               	.LVL131:
 1518               	.L106:
 464:quantum/action.c ****                             break;
 1519               		.loc 1 464 29 view .LVU356
 1520 0312 6981      		ldd r22,Y+1
 1521 0314 7A81      		ldd r23,Y+2
 1522 0316 8B81      		ldd r24,Y+3
 1523 0318 9C81      		ldd r25,Y+4
 1524 031a 0E94 0000 		call default_layer_xor
 1525               	.LVL132:
 465:quantum/action.c ****                         case OP_BIT_SET:
 1526               		.loc 1 465 29 view .LVU357
 1527 031e 00C0      		rjmp .L74
 1528               	.LVL133:
 1529               	.L107:
 467:quantum/action.c ****                             break;
 1530               		.loc 1 467 29 view .LVU358
 1531 0320 6981      		ldd r22,Y+1
 1532 0322 7A81      		ldd r23,Y+2
 1533 0324 8B81      		ldd r24,Y+3
 1534 0326 9C81      		ldd r25,Y+4
 1535 0328 0E94 0000 		call default_layer_set
 1536               	.LVL134:
 468:quantum/action.c ****                     }
 1537               		.loc 1 468 29 view .LVU359
 1538 032c 00C0      		rjmp .L74
 1539               	.LVL135:
 1540               	.L104:
 468:quantum/action.c ****                     }
 1541               		.loc 1 468 29 is_stmt 0 view .LVU360
 1542               	.LBE51:
 473:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1543               		.loc 1 473 17 is_stmt 1 view .LVU361
 473:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1544               		.loc 1 473 21 is_stmt 0 view .LVU362
 1545 032e 7E80      		ldd r7,Y+6
 1546 0330 7720      		tst r7
 1547 0332 01F4      		brne .+2
 1548 0334 00C0      		rjmp .L109
 473:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1549               		.loc 1 473 20 discriminator 1 view .LVU363
 1550 0336 00FF      		sbrs r16,0
 1551 0338 00C0      		rjmp .L74
 1552               	.L110:
 1553               	.LBB52:
 474:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1554               		.loc 1 474 21 is_stmt 1 view .LVU364
 1555               	.LVL136:
 475:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1556               		.loc 1 475 21 view .LVU365
 474:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1557               		.loc 1 474 61 is_stmt 0 view .LVU366
 1558 033a 2D81      		ldd r18,Y+5
 1559 033c 2295      		swap r18
 1560 033e 2695      		lsr r18
 1561 0340 2770      		andi r18,lo8(7)
 474:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1562               		.loc 1 474 35 view .LVU367
 1563 0342 220F      		lsl r18
 1564 0344 220F      		lsl r18
 475:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1565               		.loc 1 475 77 view .LVU368
 1566 0346 4D81      		ldd r20,Y+5
 1567 0348 4F70      		andi r20,lo8(15)
 475:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1568               		.loc 1 475 44 view .LVU369
 1569 034a 50E0      		ldi r21,0
 1570 034c 70E0      		ldi r23,0
 1571 034e 60E0      		ldi r22,0
 475:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1572               		.loc 1 475 35 view .LVU370
 1573 0350 022E      		mov r0,r18
 1574 0352 00C0      		rjmp 2f
 1575               		1:
 1576 0354 440F      		lsl r20
 1577 0356 551F      		rol r21
 1578 0358 661F      		rol r22
 1579 035a 771F      		rol r23
 1580               		2:
 1581 035c 0A94      		dec r0
 1582 035e 02F4      		brpl 1b
 1583               	.LVL137:
 476:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1584               		.loc 1 476 21 is_stmt 1 view .LVU371
 476:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1585               		.loc 1 476 104 is_stmt 0 view .LVU372
 1586 0360 8D80      		ldd r8,Y+5
 1587 0362 80E0      		ldi r24,0
 1588 0364 90E0      		ldi r25,0
 1589 0366 DC01      		movw r26,r24
 1590 0368 84FE      		sbrs r8,4
 1591 036a 00C0      		rjmp .L111
 476:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1592               		.loc 1 476 94 discriminator 1 view .LVU373
 1593 036c 8FE0      		ldi r24,lo8(15)
 1594 036e 90E0      		ldi r25,0
 1595 0370 A0E0      		ldi r26,0
 1596 0372 B0E0      		ldi r27,0
 1597 0374 00C0      		rjmp 2f
 1598               		1:
 1599 0376 880F      		lsl r24
 1600 0378 991F      		rol r25
 1601 037a AA1F      		rol r26
 1602 037c BB1F      		rol r27
 1603               		2:
 1604 037e 2A95      		dec r18
 1605 0380 02F4      		brpl 1b
 476:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1606               		.loc 1 476 104 discriminator 1 view .LVU374
 1607 0382 8095      		com r24
 1608 0384 9095      		com r25
 1609 0386 A095      		com r26
 1610 0388 B095      		com r27
 1611               	.L111:
 1612               	.LVL138:
 477:quantum/action.c ****                         case OP_BIT_AND:
 1613               		.loc 1 477 21 is_stmt 1 discriminator 4 view .LVU375
 477:quantum/action.c ****                         case OP_BIT_AND:
 1614               		.loc 1 477 47 is_stmt 0 discriminator 4 view .LVU376
 1615 038a 202F      		mov r18,r16
 1616 038c 2695      		lsr r18
 1617 038e 2695      		lsr r18
 1618 0390 2370      		andi r18,lo8(3)
 479:quantum/action.c ****                             break;
 1619               		.loc 1 479 29 discriminator 4 view .LVU377
 1620 0392 3C01      		movw r6,r24
 1621 0394 4D01      		movw r8,r26
 1622 0396 642A      		or r6,r20
 1623 0398 752A      		or r7,r21
 1624 039a 862A      		or r8,r22
 1625 039c 972A      		or r9,r23
 1626 039e 6982      		std Y+1,r6
 1627 03a0 7A82      		std Y+2,r7
 1628 03a2 8B82      		std Y+3,r8
 1629 03a4 9C82      		std Y+4,r9
 1630 03a6 2230      		cpi r18,lo8(2)
 1631 03a8 01F0      		breq .L112
 1632 03aa 2330      		cpi r18,lo8(3)
 1633 03ac 01F0      		breq .L113
 1634 03ae 2130      		cpi r18,lo8(1)
 1635 03b0 01F0      		breq .L114
 479:quantum/action.c ****                             break;
 1636               		.loc 1 479 29 is_stmt 1 view .LVU378
 1637 03b2 C401      		movw r24,r8
 1638               	.LVL139:
 479:quantum/action.c ****                             break;
 1639               		.loc 1 479 29 is_stmt 0 view .LVU379
 1640 03b4 B301      		movw r22,r6
 1641 03b6 0E94 0000 		call layer_and
 1642               	.LVL140:
 480:quantum/action.c ****                         case OP_BIT_OR:
 1643               		.loc 1 480 29 is_stmt 1 view .LVU380
 1644 03ba 00C0      		rjmp .L74
 1645               	.LVL141:
 1646               	.L109:
 480:quantum/action.c ****                         case OP_BIT_OR:
 1647               		.loc 1 480 29 is_stmt 0 view .LVU381
 1648               	.LBE52:
 473:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1649               		.loc 1 473 20 discriminator 2 view .LVU382
 1650 03bc 01FF      		sbrs r16,1
 1651 03be 00C0      		rjmp .L74
 1652 03c0 00C0      		rjmp .L110
 1653               	.LVL142:
 1654               	.L114:
 1655               	.LBB53:
 482:quantum/action.c ****                             break;
 1656               		.loc 1 482 29 is_stmt 1 view .LVU383
 1657 03c2 6981      		ldd r22,Y+1
 1658 03c4 7A81      		ldd r23,Y+2
 1659 03c6 8B81      		ldd r24,Y+3
 1660 03c8 9C81      		ldd r25,Y+4
 1661 03ca 0E94 0000 		call layer_or
 1662               	.LVL143:
 483:quantum/action.c ****                         case OP_BIT_XOR:
 1663               		.loc 1 483 29 view .LVU384
 1664 03ce 00C0      		rjmp .L74
 1665               	.LVL144:
 1666               	.L112:
 485:quantum/action.c ****                             break;
 1667               		.loc 1 485 29 view .LVU385
 1668 03d0 6981      		ldd r22,Y+1
 1669 03d2 7A81      		ldd r23,Y+2
 1670 03d4 8B81      		ldd r24,Y+3
 1671 03d6 9C81      		ldd r25,Y+4
 1672 03d8 0E94 0000 		call layer_xor
 1673               	.LVL145:
 486:quantum/action.c ****                         case OP_BIT_SET:
 1674               		.loc 1 486 29 view .LVU386
 1675 03dc 00C0      		rjmp .L74
 1676               	.LVL146:
 1677               	.L113:
 488:quantum/action.c ****                             break;
 1678               		.loc 1 488 29 view .LVU387
 1679 03de 6981      		ldd r22,Y+1
 1680 03e0 7A81      		ldd r23,Y+2
 1681 03e2 8B81      		ldd r24,Y+3
 1682 03e4 9C81      		ldd r25,Y+4
 1683 03e6 0E94 0000 		call layer_state_set
 1684               	.LVL147:
 489:quantum/action.c ****                     }
 1685               		.loc 1 489 29 view .LVU388
 1686 03ea 00C0      		rjmp .L74
 1687               	.LVL148:
 1688               	.L75:
 489:quantum/action.c ****                     }
 1689               		.loc 1 489 29 is_stmt 0 view .LVU389
 1690               	.LBE53:
 495:quantum/action.c ****                 layer_on(action.layer_mods.layer);
 1691               		.loc 1 495 13 is_stmt 1 view .LVU390
 1692               	.LBB54:
 278:quantum/action.c ****             if (event.pressed) {
 1693               		.loc 1 278 70 is_stmt 0 view .LVU391
 1694 03ec 102F      		mov r17,r16
 1695 03ee 1F70      		andi r17,lo8(15)
 1696               	.LBE54:
 495:quantum/action.c ****                 layer_on(action.layer_mods.layer);
 1697               		.loc 1 495 16 view .LVU392
 1698 03f0 7E80      		ldd r7,Y+6
 1699 03f2 7720      		tst r7
 1700 03f4 01F0      		breq .L115
 496:quantum/action.c ****                 register_mods(action.layer_mods.mods);
 1701               		.loc 1 496 17 is_stmt 1 view .LVU393
 1702 03f6 812F      		mov r24,r17
 1703 03f8 0E94 0000 		call layer_on
 1704               	.LVL149:
 497:quantum/action.c ****             } else {
 1705               		.loc 1 497 17 view .LVU394
 1706 03fc 8D81      		ldd r24,Y+5
 1707 03fe 00C0      		rjmp .L204
 1708               	.L115:
 499:quantum/action.c ****                 layer_off(action.layer_mods.layer);
 1709               		.loc 1 499 17 view .LVU395
 1710 0400 8D81      		ldd r24,Y+5
 1711 0402 0E94 0000 		call unregister_mods
 1712               	.LVL150:
 500:quantum/action.c ****             }
 1713               		.loc 1 500 17 view .LVU396
 1714 0406 812F      		mov r24,r17
 1715               	.L209:
 587:quantum/action.c ****                         }
 1716               		.loc 1 587 29 is_stmt 0 view .LVU397
 1717 0408 0E94 0000 		call layer_off
 1718               	.LVL151:
 1719 040c 00C0      		rjmp .L74
 1720               	.L199:
 1721 040e 2D81      		ldd r18,Y+5
 1722 0410 233F      		cpi r18,lo8(-13)
 1723 0412 00F4      		brsh .L116
 1724 0414 203F      		cpi r18,lo8(-16)
 1725 0416 01F0      		breq .L117
 1726 0418 213F      		cpi r18,lo8(-15)
 1727 041a 01F0      		breq .L118
 1728               	.L119:
 568:quantum/action.c ****                         if (tap_count > 0) {
 1729               		.loc 1 568 21 is_stmt 1 view .LVU398
 568:quantum/action.c ****                         if (tap_count > 0) {
 1730               		.loc 1 568 24 is_stmt 0 view .LVU399
 1731 041c 6E80      		ldd r6,Y+6
 1732 041e 6620      		tst r6
 1733 0420 01F4      		brne .+2
 1734 0422 00C0      		rjmp .L128
 569:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1735               		.loc 1 569 25 is_stmt 1 view .LVU400
 569:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1736               		.loc 1 569 28 is_stmt 0 view .LVU401
 1737 0424 D110      		cpse r13,__zero_reg__
 1738 0426 00C0      		rjmp .L203
 573:quantum/action.c ****                             layer_on(action.layer_tap.val);
 1739               		.loc 1 573 76 is_stmt 1 view .LVU402
 574:quantum/action.c ****                         }
 1740               		.loc 1 574 29 view .LVU403
 1741 0428 802F      		mov r24,r16
 1742 042a 8F71      		andi r24,lo8(31)
 1743 042c 00C0      		rjmp .L208
 1744               	.L116:
 1745 042e 3D81      		ldd r19,Y+5
 1746 0430 333F      		cpi r19,lo8(-13)
 1747 0432 01F0      		breq .L120
 1748 0434 343F      		cpi r19,lo8(-12)
 1749 0436 01F4      		brne .L119
 554:quantum/action.c ****                         layer_on(action.layer_tap.val);
 1750               		.loc 1 554 21 view .LVU404
 554:quantum/action.c ****                         layer_on(action.layer_tap.val);
 1751               		.loc 1 554 24 is_stmt 0 view .LVU405
 1752 0438 8E80      		ldd r8,Y+6
 1753 043a 8820      		tst r8
 1754 043c 01F0      		breq .L127
 555:quantum/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1755               		.loc 1 555 25 is_stmt 1 view .LVU406
 555:quantum/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1756               		.loc 1 555 50 is_stmt 0 view .LVU407
 1757 043e 102F      		mov r17,r16
 1758 0440 1F71      		andi r17,lo8(31)
 555:quantum/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1759               		.loc 1 555 25 view .LVU408
 1760 0442 812F      		mov r24,r17
 1761 0444 0E94 0000 		call layer_on
 1762               	.LVL152:
 556:quantum/action.c ****                     } else {
 1763               		.loc 1 556 25 is_stmt 1 view .LVU409
 1764 0448 63E0      		ldi r22,lo8(3)
 1765 044a 812F      		mov r24,r17
 1766 044c 0E94 0000 		call set_oneshot_layer
 1767               	.LVL153:
 1768 0450 00C0      		rjmp .L74
 1769               	.L117:
 509:quantum/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1770               		.loc 1 509 21 view .LVU410
 509:quantum/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1771               		.loc 1 509 24 is_stmt 0 view .LVU411
 1772 0452 6E80      		ldd r6,Y+6
 1773 0454 6620      		tst r6
 1774 0456 01F0      		breq .L122
 510:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 1775               		.loc 1 510 25 is_stmt 1 view .LVU412
 510:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 1776               		.loc 1 510 28 is_stmt 0 view .LVU413
 1777 0458 24E0      		ldi r18,lo8(4)
 1778 045a 722E      		mov r7,r18
 1779 045c 7D14      		cp r7,r13
 1780 045e 00F4      		brsh .+2
 1781 0460 00C0      		rjmp .L74
 1782               	.L123:
 511:quantum/action.c ****                         }
 1783               		.loc 1 511 29 is_stmt 1 view .LVU414
 1784 0462 802F      		mov r24,r16
 1785 0464 8F71      		andi r24,lo8(31)
 1786 0466 0E94 0000 		call layer_invert
 1787               	.LVL154:
 1788 046a 00C0      		rjmp .L74
 1789               	.L122:
 514:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 1790               		.loc 1 514 25 view .LVU415
 514:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 1791               		.loc 1 514 28 is_stmt 0 view .LVU416
 1792 046c 95E0      		ldi r25,lo8(5)
 1793 046e 892E      		mov r8,r25
 1794 0470 8D14      		cp r8,r13
 1795 0472 00F4      		brsh .+2
 1796 0474 00C0      		rjmp .L74
 1797 0476 00C0      		rjmp .L123
 1798               	.L118:
 520:quantum/action.c ****                     break;
 1799               		.loc 1 520 21 is_stmt 1 view .LVU417
 511:quantum/action.c ****                         }
 1800               		.loc 1 511 58 is_stmt 0 view .LVU418
 1801 0478 802F      		mov r24,r16
 1802 047a 8F71      		andi r24,lo8(31)
 520:quantum/action.c ****                     break;
 1803               		.loc 1 520 68 view .LVU419
 1804 047c 9E80      		ldd r9,Y+6
 1805 047e 9920      		tst r9
 1806 0480 01F0      		breq .L209
 1807               	.L208:
 574:quantum/action.c ****                         }
 1808               		.loc 1 574 29 view .LVU420
 1809 0482 0E94 0000 		call layer_on
 1810               	.LVL155:
 1811 0486 00C0      		rjmp .L74
 1812               	.L120:
 526:quantum/action.c ****                     break;
 1813               		.loc 1 526 21 is_stmt 1 view .LVU421
 526:quantum/action.c ****                     break;
 1814               		.loc 1 526 70 is_stmt 0 view .LVU422
 1815 0488 7E80      		ldd r7,Y+6
 1816 048a 7720      		tst r7
 1817 048c 01F0      		breq .L126
 526:quantum/action.c ****                     break;
 1818               		.loc 1 526 37 discriminator 1 view .LVU423
 1819 048e 802F      		mov r24,r16
 1820 0490 8F71      		andi r24,lo8(31)
 1821 0492 0E94 0000 		call layer_move
 1822               	.LVL156:
 1823 0496 00C0      		rjmp .L74
 1824               	.L126:
 526:quantum/action.c ****                     break;
 1825               		.loc 1 526 72 discriminator 2 view .LVU424
 1826 0498 0E94 0000 		call layer_clear
 1827               	.LVL157:
 1828 049c 00C0      		rjmp .L74
 1829               	.L127:
 558:quantum/action.c ****                         if (tap_count > 1) {
 1830               		.loc 1 558 25 is_stmt 1 view .LVU425
 1831 049e 81E0      		ldi r24,lo8(1)
 1832 04a0 0E94 0000 		call clear_oneshot_layer_state
 1833               	.LVL158:
 559:quantum/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1834               		.loc 1 559 25 view .LVU426
 559:quantum/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1835               		.loc 1 559 28 is_stmt 0 view .LVU427
 1836 04a4 9924      		clr r9
 1837 04a6 9394      		inc r9
 1838 04a8 9D14      		cp r9,r13
 1839 04aa 00F0      		brlo .+2
 1840 04ac 00C0      		rjmp .L74
 560:quantum/action.c ****                         }
 1841               		.loc 1 560 29 is_stmt 1 view .LVU428
 1842 04ae 82E0      		ldi r24,lo8(2)
 1843 04b0 0E94 0000 		call clear_oneshot_layer_state
 1844               	.LVL159:
 1845 04b4 00C0      		rjmp .L74
 1846               	.L128:
 577:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1847               		.loc 1 577 25 view .LVU429
 577:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1848               		.loc 1 577 28 is_stmt 0 view .LVU430
 1849 04b6 DD20      		tst r13
 1850 04b8 01F0      		breq .L130
 578:quantum/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1851               		.loc 1 578 77 is_stmt 1 view .LVU431
 579:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1852               		.loc 1 579 29 view .LVU432
 579:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1853               		.loc 1 579 32 is_stmt 0 view .LVU433
 1854 04ba 2D81      		ldd r18,Y+5
 1855 04bc 2933      		cpi r18,lo8(57)
 1856 04be 01F4      		brne .L131
 580:quantum/action.c ****                             } else {
 1857               		.loc 1 580 33 is_stmt 1 view .LVU434
 580:quantum/action.c ****                             } else {
 1858               		.loc 1 580 33 view .LVU435
 580:quantum/action.c ****                             } else {
 1859               		.loc 1 580 33 view .LVU436
 1860               	.LVL160:
 1861               	.LBB55:
 1862               	.LBI55:
 166:/usr/avr/include/util/delay.h **** {
 1863               		.loc 3 166 1 view .LVU437
 1864               	.LBB56:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1865               		.loc 3 168 2 view .LVU438
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1866               		.loc 3 172 2 view .LVU439
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1867               		.loc 3 173 2 view .LVU440
 174:/usr/avr/include/util/delay.h **** 
 1868               		.loc 3 174 2 view .LVU441
 184:/usr/avr/include/util/delay.h **** 	#endif
 1869               		.loc 3 184 3 view .LVU442
 1870               		.loc 3 187 2 view .LVU443
 1871 04c0 3FEF      		ldi r19,lo8(255999)
 1872 04c2 87EE      		ldi r24,hi8(255999)
 1873 04c4 93E0      		ldi r25,hlo8(255999)
 1874 04c6 3150      	1:	subi r19,1
 1875 04c8 8040      		sbci r24,0
 1876 04ca 9040      		sbci r25,0
 1877 04cc 01F4      		brne 1b
 1878 04ce 00C0      		rjmp .L202
 1879               	.LVL161:
 1880               	.L131:
 1881               		.loc 3 187 2 is_stmt 0 view .LVU444
 1882               	.LBE56:
 1883               	.LBE55:
 582:quantum/action.c ****                             }
 1884               		.loc 1 582 33 is_stmt 1 view .LVU445
 582:quantum/action.c ****                             }
 1885               		.loc 1 582 33 view .LVU446
 582:quantum/action.c ****                             }
 1886               		.loc 1 582 33 view .LVU447
 1887               	.LBB57:
 1888               	.LBI48:
 166:/usr/avr/include/util/delay.h **** {
 1889               		.loc 3 166 1 view .LVU448
 1890               	.LBB50:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1891               		.loc 3 168 2 view .LVU449
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1892               		.loc 3 172 2 view .LVU450
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1893               		.loc 3 173 2 view .LVU451
 174:/usr/avr/include/util/delay.h **** 
 1894               		.loc 3 174 2 view .LVU452
 184:/usr/avr/include/util/delay.h **** 	#endif
 1895               		.loc 3 184 3 view .LVU453
 1896               		.loc 3 187 2 view .LVU454
 1897 04d0 EFE3      		ldi r30,lo8(-25537)
 1898 04d2 FCE9      		ldi r31,hi8(-25537)
 1899 04d4 3197      	1:	sbiw r30,1
 1900 04d6 01F4      		brne 1b
 1901 04d8 00C0      		rjmp .L202
 1902               	.LVL162:
 1903               	.L130:
 1904               		.loc 3 187 2 is_stmt 0 view .LVU455
 1905               	.LBE50:
 1906               	.LBE57:
 586:quantum/action.c ****                             layer_off(action.layer_tap.val);
 1907               		.loc 1 586 79 is_stmt 1 view .LVU456
 587:quantum/action.c ****                         }
 1908               		.loc 1 587 29 view .LVU457
 1909 04da 802F      		mov r24,r16
 1910 04dc 8F71      		andi r24,lo8(31)
 1911 04de 00C0      		rjmp .L209
 1912               	.L73:
 603:quantum/action.c ****                 case OP_SH_TOGGLE:
 1913               		.loc 1 603 13 view .LVU458
 1914 04e0 ED81      		ldd r30,Y+5
 1915 04e2 E05F      		subi r30,lo8(-(16))
 1916 04e4 E730      		cpi r30,lo8(7)
 1917 04e6 00F4      		brsh .L133
 1918 04e8 F0E0      		ldi r31,0
 1919 04ea E050      		subi r30,lo8(-(gs(.L135)))
 1920 04ec F040      		sbci r31,hi8(-(gs(.L135)))
 1921 04ee 0C94 0000 		jmp __tablejump2__
 1922               		.section	.jumptables.gcc.process_action,"a",@progbits
 1923               		.p2align	1
 1924               	.L135:
 1925 0000 0000      		.word gs(.L141)
 1926 0002 0000      		.word gs(.L140)
 1927 0004 0000      		.word gs(.L139)
 1928 0006 0000      		.word gs(.L138)
 1929 0008 0000      		.word gs(.L137)
 1930 000a 0000      		.word gs(.L136)
 1931 000c 0000      		.word gs(.L134)
 1932               		.section	.text.process_action
 1933               	.L141:
 605:quantum/action.c ****                         swap_hands = !swap_hands;
 1934               		.loc 1 605 21 view .LVU459
 605:quantum/action.c ****                         swap_hands = !swap_hands;
 1935               		.loc 1 605 24 is_stmt 0 view .LVU460
 1936 04f2 6E80      		ldd r6,Y+6
 1937 04f4 6620      		tst r6
 1938 04f6 01F4      		brne .+2
 1939 04f8 00C0      		rjmp .L74
 1940               	.L144:
 606:quantum/action.c ****                     }
 1941               		.loc 1 606 25 is_stmt 1 view .LVU461
 1942 04fa 8091 0000 		lds r24,swap_hands
 1943 04fe 91E0      		ldi r25,lo8(1)
 1944 0500 8927      		eor r24,r25
 1945               	.L207:
 617:quantum/action.c ****                     }
 1946               		.loc 1 617 36 is_stmt 0 view .LVU462
 1947 0502 8093 0000 		sts swap_hands,r24
 1948 0506 00C0      		rjmp .L74
 1949               	.L139:
 610:quantum/action.c ****                     break;
 1950               		.loc 1 610 21 is_stmt 1 view .LVU463
 610:quantum/action.c ****                     break;
 1951               		.loc 1 610 32 is_stmt 0 view .LVU464
 1952 0508 7E80      		ldd r7,Y+6
 1953 050a 7092 0000 		sts swap_hands,r7
 611:quantum/action.c ****                 case OP_SH_OFF_ON:
 1954               		.loc 1 611 21 is_stmt 1 view .LVU465
 1955 050e 00C0      		rjmp .L74
 1956               	.L138:
 613:quantum/action.c ****                     break;
 1957               		.loc 1 613 21 view .LVU466
 1958 0510 81E0      		ldi r24,lo8(1)
 1959 0512 8E80      		ldd r8,Y+6
 1960 0514 8825      		eor r24,r8
 1961 0516 00C0      		rjmp .L207
 1962               	.L136:
 616:quantum/action.c ****                         swap_hands = true;
 1963               		.loc 1 616 21 view .LVU467
 616:quantum/action.c ****                         swap_hands = true;
 1964               		.loc 1 616 24 is_stmt 0 view .LVU468
 1965 0518 9E80      		ldd r9,Y+6
 1966 051a 9110      		cpse r9,__zero_reg__
 1967 051c 00C0      		rjmp .L74
 617:quantum/action.c ****                     }
 1968               		.loc 1 617 25 is_stmt 1 view .LVU469
 617:quantum/action.c ****                     }
 1969               		.loc 1 617 36 is_stmt 0 view .LVU470
 1970 051e 81E0      		ldi r24,lo8(1)
 1971 0520 00C0      		rjmp .L207
 1972               	.L137:
 621:quantum/action.c ****                         swap_hands = false;
 1973               		.loc 1 621 21 is_stmt 1 view .LVU471
 621:quantum/action.c ****                         swap_hands = false;
 1974               		.loc 1 621 24 is_stmt 0 view .LVU472
 1975 0522 6E80      		ldd r6,Y+6
 1976 0524 6110      		cpse r6,__zero_reg__
 1977 0526 00C0      		rjmp .L74
 622:quantum/action.c ****                     }
 1978               		.loc 1 622 25 is_stmt 1 view .LVU473
 622:quantum/action.c ****                     }
 1979               		.loc 1 622 36 is_stmt 0 view .LVU474
 1980 0528 1092 0000 		sts swap_hands,__zero_reg__
 1981 052c 00C0      		rjmp .L74
 1982               	.L134:
 627:quantum/action.c ****                         set_oneshot_swaphands();
 1983               		.loc 1 627 21 is_stmt 1 view .LVU475
 627:quantum/action.c ****                         set_oneshot_swaphands();
 1984               		.loc 1 627 24 is_stmt 0 view .LVU476
 1985 052e 7E80      		ldd r7,Y+6
 1986 0530 7720      		tst r7
 1987 0532 01F0      		breq .L142
 628:quantum/action.c ****                     } else {
 1988               		.loc 1 628 25 is_stmt 1 view .LVU477
 1989 0534 0E94 0000 		call set_oneshot_swaphands
 1990               	.LVL163:
 1991 0538 00C0      		rjmp .L74
 1992               	.L142:
 630:quantum/action.c ****                     }
 1993               		.loc 1 630 25 view .LVU478
 1994 053a 0E94 0000 		call release_oneshot_swaphands
 1995               	.LVL164:
 1996 053e 00C0      		rjmp .L74
 1997               	.L140:
 639:quantum/action.c ****                         if (swap_held) {
 1998               		.loc 1 639 21 view .LVU479
 639:quantum/action.c ****                         if (swap_held) {
 1999               		.loc 1 639 24 is_stmt 0 view .LVU480
 2000 0540 8E80      		ldd r8,Y+6
 2001 0542 8820      		tst r8
 2002 0544 01F0      		breq .L143
 640:quantum/action.c ****                             swap_held = false;
 2003               		.loc 1 640 25 is_stmt 1 view .LVU481
 640:quantum/action.c ****                             swap_held = false;
 2004               		.loc 1 640 28 is_stmt 0 view .LVU482
 2005 0546 8091 0000 		lds r24,swap_held
 2006 054a 8823      		tst r24
 2007 054c 01F0      		breq .L144
 2008               	.L205:
 668:quantum/action.c ****                         }
 2009               		.loc 1 668 29 is_stmt 1 view .LVU483
 668:quantum/action.c ****                         }
 2010               		.loc 1 668 40 is_stmt 0 view .LVU484
 2011 054e 1092 0000 		sts swap_held,__zero_reg__
 2012 0552 00C0      		rjmp .L74
 2013               	.L143:
 646:quantum/action.c ****                             swap_hands = !swap_hands;
 2014               		.loc 1 646 25 is_stmt 1 view .LVU485
 646:quantum/action.c ****                             swap_hands = !swap_hands;
 2015               		.loc 1 646 28 is_stmt 0 view .LVU486
 2016 0554 84E0      		ldi r24,lo8(4)
 2017 0556 982E      		mov r9,r24
 2018 0558 9D14      		cp r9,r13
 2019 055a 00F4      		brsh .L144
 2020 055c 00C0      		rjmp .L74
 2021               	.L133:
 653:quantum/action.c ****                         if (swap_held) {
 2022               		.loc 1 653 21 is_stmt 1 view .LVU487
 640:quantum/action.c ****                             swap_held = false;
 2023               		.loc 1 640 29 is_stmt 0 view .LVU488
 2024 055e 8091 0000 		lds r24,swap_held
 653:quantum/action.c ****                         if (swap_held) {
 2025               		.loc 1 653 24 view .LVU489
 2026 0562 DD20      		tst r13
 2027 0564 01F0      		breq .L145
 654:quantum/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 2028               		.loc 1 654 25 is_stmt 1 view .LVU490
 654:quantum/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 2029               		.loc 1 654 28 is_stmt 0 view .LVU491
 2030 0566 8823      		tst r24
 2031 0568 01F0      		breq .L146
 655:quantum/action.c ****                             swap_held  = false;
 2032               		.loc 1 655 29 is_stmt 1 view .LVU492
 2033 056a 8091 0000 		lds r24,swap_hands
 2034 056e 91E0      		ldi r25,lo8(1)
 2035 0570 8927      		eor r24,r25
 655:quantum/action.c ****                             swap_held  = false;
 2036               		.loc 1 655 40 is_stmt 0 view .LVU493
 2037 0572 8093 0000 		sts swap_hands,r24
 656:quantum/action.c ****                         }
 2038               		.loc 1 656 29 is_stmt 1 view .LVU494
 656:quantum/action.c ****                         }
 2039               		.loc 1 656 40 is_stmt 0 view .LVU495
 2040 0576 1092 0000 		sts swap_held,__zero_reg__
 2041               	.L146:
 658:quantum/action.c ****                             register_code(action.swap.code);
 2042               		.loc 1 658 25 is_stmt 1 view .LVU496
 658:quantum/action.c ****                             register_code(action.swap.code);
 2043               		.loc 1 658 28 is_stmt 0 view .LVU497
 2044 057a 6E80      		ldd r6,Y+6
 2045 057c 6110      		cpse r6,__zero_reg__
 2046 057e 00C0      		rjmp .L203
 2047               	.LBB58:
 661:quantum/action.c ****                             unregister_code(action.swap.code);
 2048               		.loc 1 661 29 is_stmt 1 view .LVU498
 661:quantum/action.c ****                             unregister_code(action.swap.code);
 2049               		.loc 1 661 29 view .LVU499
 661:quantum/action.c ****                             unregister_code(action.swap.code);
 2050               		.loc 1 661 29 view .LVU500
 2051               	.LVL165:
 2052               	.LBB59:
 2053               	.LBI59:
 166:/usr/avr/include/util/delay.h **** {
 2054               		.loc 3 166 1 view .LVU501
 2055               	.LBB60:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 2056               		.loc 3 168 2 view .LVU502
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 2057               		.loc 3 172 2 view .LVU503
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 2058               		.loc 3 173 2 view .LVU504
 174:/usr/avr/include/util/delay.h **** 
 2059               		.loc 3 174 2 view .LVU505
 184:/usr/avr/include/util/delay.h **** 	#endif
 2060               		.loc 3 184 3 view .LVU506
 2061               		.loc 3 187 2 view .LVU507
 2062 0580 8FE3      		ldi r24,lo8(-25537)
 2063 0582 9CE9      		ldi r25,hi8(-25537)
 2064 0584 0197      	1:	sbiw r24,1
 2065 0586 01F4      		brne 1b
 2066 0588 00C0      		rjmp .
 2067 058a 0000      		nop
 2068               	.LVL166:
 2069               		.loc 3 187 2 is_stmt 0 view .LVU508
 2070               	.LBE60:
 2071               	.LBE59:
 661:quantum/action.c ****                             unregister_code(action.swap.code);
 2072               		.loc 1 661 29 is_stmt 1 view .LVU509
 662:quantum/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 2073               		.loc 1 662 29 view .LVU510
 2074 058c 8D81      		ldd r24,Y+5
 2075 058e 0E94 0000 		call unregister_code
 2076               	.LVL167:
 663:quantum/action.c ****                         }
 2077               		.loc 1 663 29 view .LVU511
 663:quantum/action.c ****                         }
 2078               		.loc 1 663 37 is_stmt 0 view .LVU512
 2079 0592 86E0      		ldi r24,lo8(6)
 2080 0594 F701      		movw r30,r14
 2081               		0:
 2082 0596 1192      		st Z+,__zero_reg__
 2083 0598 8A95      		dec r24
 2084 059a 01F4      		brne 0b
 2085 059c 00C0      		rjmp .L74
 2086               	.L145:
 663:quantum/action.c ****                         }
 2087               		.loc 1 663 37 view .LVU513
 2088               	.LBE58:
 666:quantum/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 2089               		.loc 1 666 25 is_stmt 1 view .LVU514
 666:quantum/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 2090               		.loc 1 666 28 is_stmt 0 view .LVU515
 2091 059e 8823      		tst r24
 2092 05a0 01F4      		brne .+2
 2093 05a2 00C0      		rjmp .L74
 666:quantum/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 2094               		.loc 1 666 39 discriminator 1 view .LVU516
 2095 05a4 6E80      		ldd r6,Y+6
 2096 05a6 6110      		cpse r6,__zero_reg__
 2097 05a8 00C0      		rjmp .L74
 667:quantum/action.c ****                             swap_held  = false;
 2098               		.loc 1 667 29 is_stmt 1 view .LVU517
 2099 05aa 8091 0000 		lds r24,swap_hands
 2100 05ae 91E0      		ldi r25,lo8(1)
 2101 05b0 8927      		eor r24,r25
 667:quantum/action.c ****                             swap_held  = false;
 2102               		.loc 1 667 40 is_stmt 0 view .LVU518
 2103 05b2 8093 0000 		sts swap_hands,r24
 2104 05b6 00C0      		rjmp .L205
 2105               	.L65:
 2106               	/* epilogue start */
 745:quantum/action.c **** 
 2107               		.loc 1 745 1 view .LVU519
 2108 05b8 2696      		adiw r28,6
 2109 05ba 0FB6      		in __tmp_reg__,__SREG__
 2110 05bc F894      		cli
 2111 05be DEBF      		out __SP_H__,r29
 2112 05c0 0FBE      		out __SREG__,__tmp_reg__
 2113 05c2 CDBF      		out __SP_L__,r28
 2114 05c4 DF91      		pop r29
 2115 05c6 CF91      		pop r28
 2116 05c8 1F91      		pop r17
 2117 05ca 0F91      		pop r16
 745:quantum/action.c **** 
 2118               		.loc 1 745 1 view .LVU520
 2119 05cc FF90      		pop r15
 2120 05ce EF90      		pop r14
 2121               	.LVL168:
 745:quantum/action.c **** 
 2122               		.loc 1 745 1 view .LVU521
 2123 05d0 DF90      		pop r13
 2124               	.LVL169:
 745:quantum/action.c **** 
 2125               		.loc 1 745 1 view .LVU522
 2126 05d2 CF90      		pop r12
 2127               	.LVL170:
 745:quantum/action.c **** 
 2128               		.loc 1 745 1 view .LVU523
 2129 05d4 BF90      		pop r11
 2130 05d6 9F90      		pop r9
 2131 05d8 8F90      		pop r8
 2132 05da 7F90      		pop r7
 2133 05dc 6F90      		pop r6
 2134 05de 0895      		ret
 2135               		.cfi_endproc
 2136               	.LFE24:
 2138               		.section	.text.process_record_handler,"ax",@progbits
 2139               	.global	process_record_handler
 2141               	process_record_handler:
 2142               	.LVL171:
 2143               	.LFB23:
 214:quantum/action.c **** #ifdef COMBO_ENABLE
 2144               		.loc 1 214 50 is_stmt 1 view -0
 2145               		.cfi_startproc
 214:quantum/action.c **** #ifdef COMBO_ENABLE
 2146               		.loc 1 214 50 is_stmt 0 view .LVU525
 2147 0000 0F93      		push r16
 2148               	.LCFI29:
 2149               		.cfi_def_cfa_offset 3
 2150               		.cfi_offset 16, -2
 2151 0002 1F93      		push r17
 2152               	.LCFI30:
 2153               		.cfi_def_cfa_offset 4
 2154               		.cfi_offset 17, -3
 2155 0004 CF93      		push r28
 2156               	.LCFI31:
 2157               		.cfi_def_cfa_offset 5
 2158               		.cfi_offset 28, -4
 2159 0006 DF93      		push r29
 2160               	.LCFI32:
 2161               		.cfi_def_cfa_offset 6
 2162               		.cfi_offset 29, -5
 2163               	/* prologue: function */
 2164               	/* frame size = 0 */
 2165               	/* stack size = 4 */
 2166               	.L__stack_usage = 4
 2167 0008 EC01      		movw r28,r24
 223:quantum/action.c **** #endif
 2168               		.loc 1 223 5 is_stmt 1 view .LVU526
 223:quantum/action.c **** #endif
 2169               		.loc 1 223 23 is_stmt 0 view .LVU527
 2170 000a 6881      		ld r22,Y
 2171 000c 7981      		ldd r23,Y+1
 2172 000e 8A81      		ldd r24,Y+2
 2173               	.LVL172:
 223:quantum/action.c **** #endif
 2174               		.loc 1 223 23 view .LVU528
 2175 0010 0E94 0000 		call store_or_get_action
 2176               	.LVL173:
 2177 0014 8C01      		movw r16,r24
 225:quantum/action.c ****     debug_action(action);
 2178               		.loc 1 225 23 is_stmt 1 view .LVU529
 226:quantum/action.c **** #ifndef NO_ACTION_LAYER
 2179               		.loc 1 226 5 view .LVU530
 228:quantum/action.c ****     layer_debug();
 2180               		.loc 1 228 29 view .LVU531
 229:quantum/action.c ****     dprint(" default_layer_state: ");
 2181               		.loc 1 229 5 view .LVU532
 2182 0016 0E94 0000 		call layer_debug
 2183               	.LVL174:
 230:quantum/action.c ****     default_layer_debug();
 2184               		.loc 1 230 37 view .LVU533
 231:quantum/action.c **** #endif
 2185               		.loc 1 231 5 view .LVU534
 2186 001a 0E94 0000 		call default_layer_debug
 2187               	.LVL175:
 233:quantum/action.c **** 
 2188               		.loc 1 233 15 view .LVU535
 235:quantum/action.c **** }
 2189               		.loc 1 235 5 view .LVU536
 2190 001e B801      		movw r22,r16
 2191 0020 CE01      		movw r24,r28
 2192               	/* epilogue start */
 236:quantum/action.c **** 
 2193               		.loc 1 236 1 is_stmt 0 view .LVU537
 2194 0022 DF91      		pop r29
 2195 0024 CF91      		pop r28
 2196               	.LVL176:
 236:quantum/action.c **** 
 2197               		.loc 1 236 1 view .LVU538
 2198 0026 1F91      		pop r17
 2199 0028 0F91      		pop r16
 235:quantum/action.c **** }
 2200               		.loc 1 235 5 view .LVU539
 2201 002a 0C94 0000 		jmp process_action
 2202               	.LVL177:
 235:quantum/action.c **** }
 2203               		.loc 1 235 5 view .LVU540
 2204               		.cfi_endproc
 2205               	.LFE23:
 2207               		.section	.text.process_record,"ax",@progbits
 2208               	.global	process_record
 2210               	process_record:
 2211               	.LVL178:
 2212               	.LFB22:
 196:quantum/action.c ****     if (IS_NOEVENT(record->event)) {
 2213               		.loc 1 196 42 is_stmt 1 view -0
 2214               		.cfi_startproc
 196:quantum/action.c ****     if (IS_NOEVENT(record->event)) {
 2215               		.loc 1 196 42 is_stmt 0 view .LVU542
 2216 0000 CF93      		push r28
 2217               	.LCFI33:
 2218               		.cfi_def_cfa_offset 3
 2219               		.cfi_offset 28, -2
 2220 0002 DF93      		push r29
 2221               	.LCFI34:
 2222               		.cfi_def_cfa_offset 4
 2223               		.cfi_offset 29, -3
 2224               	/* prologue: function */
 2225               	/* frame size = 0 */
 2226               	/* stack size = 2 */
 2227               	.L__stack_usage = 2
 2228 0004 EC01      		movw r28,r24
 197:quantum/action.c ****         return;
 2229               		.loc 1 197 5 is_stmt 1 view .LVU543
 2230 0006 9881      		ld r25,Y
 2231               	.LVL179:
 197:quantum/action.c ****         return;
 2232               		.loc 1 197 5 is_stmt 0 view .LVU544
 2233 0008 8981      		ldd r24,Y+1
 2234               	.LVL180:
 2235               	.LBB61:
 2236               	.LBI61:
 2237               		.loc 2 47 20 is_stmt 1 view .LVU545
 2238               	.LBB62:
 2239               		.loc 2 47 51 view .LVU546
 2240               		.loc 2 47 74 is_stmt 0 view .LVU547
 2241 000a 2B81      		ldd r18,Y+3
 2242 000c 3C81      		ldd r19,Y+4
 2243 000e 232B      		or r18,r19
 2244 0010 01F0      		breq .L212
 2245 0012 8923      		and r24,r25
 2246               	.LVL181:
 2247               		.loc 2 47 74 view .LVU548
 2248 0014 8F3F      		cpi r24,lo8(-1)
 2249 0016 01F4      		brne .L228
 2250               	.LVL182:
 2251               	.L212:
 2252               	/* epilogue start */
 2253               		.loc 2 47 74 view .LVU549
 2254               	.LBE62:
 2255               	.LBE61:
 212:quantum/action.c **** 
 2256               		.loc 1 212 1 view .LVU550
 2257 0018 DF91      		pop r29
 2258 001a CF91      		pop r28
 2259               	.LVL183:
 212:quantum/action.c **** 
 2260               		.loc 1 212 1 view .LVU551
 2261 001c 0895      		ret
 2262               	.LVL184:
 2263               	.L217:
 210:quantum/action.c ****     post_process_record_quantum(record);
 2264               		.loc 1 210 5 is_stmt 1 view .LVU552
 2265 001e CE01      		movw r24,r28
 2266 0020 0E94 0000 		call process_record_handler
 2267               	.LVL185:
 211:quantum/action.c **** }
 2268               		.loc 1 211 5 view .LVU553
 2269 0024 CE01      		movw r24,r28
 2270               	/* epilogue start */
 212:quantum/action.c **** 
 2271               		.loc 1 212 1 is_stmt 0 view .LVU554
 2272 0026 DF91      		pop r29
 2273 0028 CF91      		pop r28
 2274               	.LVL186:
 211:quantum/action.c **** }
 2275               		.loc 1 211 5 view .LVU555
 2276 002a 0C94 0000 		jmp post_process_record_quantum
 2277               	.LVL187:
 2278               	.L228:
 201:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 2279               		.loc 1 201 5 is_stmt 1 view .LVU556
 201:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 2280               		.loc 1 201 10 is_stmt 0 view .LVU557
 2281 002e CE01      		movw r24,r28
 2282 0030 0E94 0000 		call process_record_quantum
 2283               	.LVL188:
 201:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 2284               		.loc 1 201 8 view .LVU558
 2285 0034 8111      		cpse r24,__zero_reg__
 2286 0036 00C0      		rjmp .L217
 203:quantum/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 2287               		.loc 1 203 9 is_stmt 1 view .LVU559
 203:quantum/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 2288               		.loc 1 203 13 is_stmt 0 view .LVU560
 2289 0038 0E94 0000 		call is_oneshot_layer_active
 2290               	.LVL189:
 203:quantum/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 2291               		.loc 1 203 12 view .LVU561
 2292 003c 8823      		tst r24
 2293 003e 01F0      		breq .L212
 203:quantum/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 2294               		.loc 1 203 39 discriminator 1 view .LVU562
 2295 0040 8A81      		ldd r24,Y+2
 2296 0042 8823      		tst r24
 2297 0044 01F0      		breq .L212
 204:quantum/action.c ****         }
 2298               		.loc 1 204 13 is_stmt 1 view .LVU563
 2299 0046 82E0      		ldi r24,lo8(2)
 2300               	/* epilogue start */
 212:quantum/action.c **** 
 2301               		.loc 1 212 1 is_stmt 0 view .LVU564
 2302 0048 DF91      		pop r29
 2303 004a CF91      		pop r28
 2304               	.LVL190:
 204:quantum/action.c ****         }
 2305               		.loc 1 204 13 view .LVU565
 2306 004c 0C94 0000 		jmp clear_oneshot_layer_state
 2307               	.LVL191:
 2308               		.cfi_endproc
 2309               	.LFE22:
 2311               		.section	.text.process_record_nocache,"ax",@progbits
 2312               	.global	process_record_nocache
 2314               	process_record_nocache:
 2315               	.LVL192:
 2316               	.LFB18:
 154:quantum/action.c ****     disable_action_cache = true;
 2317               		.loc 1 154 50 is_stmt 1 view -0
 2318               		.cfi_startproc
 2319               	/* prologue: function */
 2320               	/* frame size = 0 */
 2321               	/* stack size = 0 */
 2322               	.L__stack_usage = 0
 155:quantum/action.c ****     process_record(record);
 2323               		.loc 1 155 5 view .LVU567
 155:quantum/action.c ****     process_record(record);
 2324               		.loc 1 155 26 is_stmt 0 view .LVU568
 2325 0000 21E0      		ldi r18,lo8(1)
 2326 0002 2093 0000 		sts disable_action_cache,r18
 156:quantum/action.c ****     disable_action_cache = false;
 2327               		.loc 1 156 5 is_stmt 1 view .LVU569
 2328 0006 0E94 0000 		call process_record
 2329               	.LVL193:
 157:quantum/action.c **** }
 2330               		.loc 1 157 5 view .LVU570
 157:quantum/action.c **** }
 2331               		.loc 1 157 26 is_stmt 0 view .LVU571
 2332 000a 1092 0000 		sts disable_action_cache,__zero_reg__
 2333               	/* epilogue start */
 158:quantum/action.c **** #else
 2334               		.loc 1 158 1 view .LVU572
 2335 000e 0895      		ret
 2336               		.cfi_endproc
 2337               	.LFE18:
 2339               		.section	.text.register_weak_mods,"ax",@progbits
 2340               	.global	register_weak_mods
 2342               	register_weak_mods:
 2343               	.LVL194:
 2344               	.LFB31:
 940:quantum/action.c **** 
 941:quantum/action.c **** /** \brief Adds the given weak modifiers and sends a keyboard report immediately.
 942:quantum/action.c ****  *
 943:quantum/action.c ****  * \param mods A bitfield of modifiers to register.
 944:quantum/action.c ****  */
 945:quantum/action.c **** void register_weak_mods(uint8_t mods) {
 2345               		.loc 1 945 39 is_stmt 1 view -0
 2346               		.cfi_startproc
 2347               	/* prologue: function */
 2348               	/* frame size = 0 */
 2349               	/* stack size = 0 */
 2350               	.L__stack_usage = 0
 946:quantum/action.c ****     if (mods) {
 2351               		.loc 1 946 5 view .LVU574
 2352               		.loc 1 946 8 is_stmt 0 view .LVU575
 2353 0000 8823      		tst r24
 2354 0002 01F0      		breq .L231
 947:quantum/action.c ****         add_weak_mods(mods);
 2355               		.loc 1 947 9 is_stmt 1 view .LVU576
 2356 0004 0E94 0000 		call add_weak_mods
 2357               	.LVL195:
 948:quantum/action.c ****         send_keyboard_report();
 2358               		.loc 1 948 9 view .LVU577
 2359 0008 0C94 0000 		jmp send_keyboard_report
 2360               	.LVL196:
 2361               	.L231:
 2362               	/* epilogue start */
 949:quantum/action.c ****     }
 950:quantum/action.c **** }
 2363               		.loc 1 950 1 is_stmt 0 view .LVU578
 2364 000c 0895      		ret
 2365               		.cfi_endproc
 2366               	.LFE31:
 2368               		.section	.text.unregister_weak_mods,"ax",@progbits
 2369               	.global	unregister_weak_mods
 2371               	unregister_weak_mods:
 2372               	.LVL197:
 2373               	.LFB32:
 951:quantum/action.c **** 
 952:quantum/action.c **** /** \brief Removes the given weak modifiers and sends a keyboard report immediately.
 953:quantum/action.c ****  *
 954:quantum/action.c ****  * \param mods A bitfield of modifiers to unregister.
 955:quantum/action.c ****  */
 956:quantum/action.c **** void unregister_weak_mods(uint8_t mods) {
 2374               		.loc 1 956 41 is_stmt 1 view -0
 2375               		.cfi_startproc
 2376               	/* prologue: function */
 2377               	/* frame size = 0 */
 2378               	/* stack size = 0 */
 2379               	.L__stack_usage = 0
 957:quantum/action.c ****     if (mods) {
 2380               		.loc 1 957 5 view .LVU580
 2381               		.loc 1 957 8 is_stmt 0 view .LVU581
 2382 0000 8823      		tst r24
 2383 0002 01F0      		breq .L233
 958:quantum/action.c ****         del_weak_mods(mods);
 2384               		.loc 1 958 9 is_stmt 1 view .LVU582
 2385 0004 0E94 0000 		call del_weak_mods
 2386               	.LVL198:
 959:quantum/action.c ****         send_keyboard_report();
 2387               		.loc 1 959 9 view .LVU583
 2388 0008 0C94 0000 		jmp send_keyboard_report
 2389               	.LVL199:
 2390               	.L233:
 2391               	/* epilogue start */
 960:quantum/action.c ****     }
 961:quantum/action.c **** }
 2392               		.loc 1 961 1 is_stmt 0 view .LVU584
 2393 000c 0895      		ret
 2394               		.cfi_endproc
 2395               	.LFE32:
 2397               		.section	.text.clear_keyboard_but_mods_and_keys,"ax",@progbits
 2398               	.global	clear_keyboard_but_mods_and_keys
 2400               	clear_keyboard_but_mods_and_keys:
 2401               	.LFB35:
 962:quantum/action.c **** 
 963:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 964:quantum/action.c ****  *
 965:quantum/action.c ****  * FIXME: Needs documentation.
 966:quantum/action.c ****  */
 967:quantum/action.c **** void clear_keyboard(void) {
 968:quantum/action.c ****     clear_mods();
 969:quantum/action.c ****     clear_keyboard_but_mods();
 970:quantum/action.c **** }
 971:quantum/action.c **** 
 972:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 973:quantum/action.c ****  *
 974:quantum/action.c ****  * FIXME: Needs documentation.
 975:quantum/action.c ****  */
 976:quantum/action.c **** void clear_keyboard_but_mods(void) {
 977:quantum/action.c ****     clear_keys();
 978:quantum/action.c ****     clear_keyboard_but_mods_and_keys();
 979:quantum/action.c **** }
 980:quantum/action.c **** 
 981:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 982:quantum/action.c ****  *
 983:quantum/action.c ****  * FIXME: Needs documentation.
 984:quantum/action.c ****  */
 985:quantum/action.c **** void clear_keyboard_but_mods_and_keys() {
 2402               		.loc 1 985 41 is_stmt 1 view -0
 2403               		.cfi_startproc
 2404               	/* prologue: function */
 2405               	/* frame size = 0 */
 2406               	/* stack size = 0 */
 2407               	.L__stack_usage = 0
 986:quantum/action.c **** #ifdef EXTRAKEY_ENABLE
 987:quantum/action.c ****     host_system_send(0);
 988:quantum/action.c ****     host_consumer_send(0);
 989:quantum/action.c **** #endif
 990:quantum/action.c ****     clear_weak_mods();
 2408               		.loc 1 990 5 view .LVU586
 2409 0000 0E94 0000 		call clear_weak_mods
 2410               	.LVL200:
 991:quantum/action.c ****     clear_macro_mods();
 2411               		.loc 1 991 5 view .LVU587
 2412 0004 0E94 0000 		call clear_macro_mods
 2413               	.LVL201:
 992:quantum/action.c ****     send_keyboard_report();
 2414               		.loc 1 992 5 view .LVU588
 2415 0008 0C94 0000 		jmp send_keyboard_report
 2416               	.LVL202:
 2417               		.cfi_endproc
 2418               	.LFE35:
 2420               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 2421               	.global	clear_keyboard_but_mods
 2423               	clear_keyboard_but_mods:
 2424               	.LFB34:
 976:quantum/action.c ****     clear_keys();
 2425               		.loc 1 976 36 view -0
 2426               		.cfi_startproc
 2427               	/* prologue: function */
 2428               	/* frame size = 0 */
 2429               	/* stack size = 0 */
 2430               	.L__stack_usage = 0
 977:quantum/action.c ****     clear_keyboard_but_mods_and_keys();
 2431               		.loc 1 977 5 view .LVU590
 2432 0000 0E94 0000 		call clear_keys
 2433               	.LVL203:
 978:quantum/action.c **** }
 2434               		.loc 1 978 5 view .LVU591
 2435 0004 0C94 0000 		jmp clear_keyboard_but_mods_and_keys
 2436               	.LVL204:
 2437               		.cfi_endproc
 2438               	.LFE34:
 2440               		.section	.text.clear_keyboard,"ax",@progbits
 2441               	.global	clear_keyboard
 2443               	clear_keyboard:
 2444               	.LFB33:
 967:quantum/action.c ****     clear_mods();
 2445               		.loc 1 967 27 view -0
 2446               		.cfi_startproc
 2447               	/* prologue: function */
 2448               	/* frame size = 0 */
 2449               	/* stack size = 0 */
 2450               	.L__stack_usage = 0
 968:quantum/action.c ****     clear_keyboard_but_mods();
 2451               		.loc 1 968 5 view .LVU593
 2452 0000 0E94 0000 		call clear_mods
 2453               	.LVL205:
 969:quantum/action.c **** }
 2454               		.loc 1 969 5 view .LVU594
 2455 0004 0C94 0000 		jmp clear_keyboard_but_mods
 2456               	.LVL206:
 2457               		.cfi_endproc
 2458               	.LFE33:
 2460               		.section	.text.is_tap_action,"ax",@progbits
 2461               	.global	is_tap_action
 2463               	is_tap_action:
 2464               	.LVL207:
 2465               	.LFB38:
 993:quantum/action.c **** #ifdef MOUSEKEY_ENABLE
 994:quantum/action.c ****     mousekey_clear();
 995:quantum/action.c ****     mousekey_send();
 996:quantum/action.c **** #endif
 997:quantum/action.c **** }
 998:quantum/action.c **** 
 999:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1000:quantum/action.c ****  *
1001:quantum/action.c ****  * FIXME: Needs documentation.
1002:quantum/action.c ****  */
1003:quantum/action.c **** bool is_tap_key(keypos_t key) {
1004:quantum/action.c ****     action_t action = layer_switch_get_action(key);
1005:quantum/action.c ****     return is_tap_action(action);
1006:quantum/action.c **** }
1007:quantum/action.c **** 
1008:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1009:quantum/action.c ****  *
1010:quantum/action.c ****  * FIXME: Needs documentation.
1011:quantum/action.c ****  */
1012:quantum/action.c **** bool is_tap_record(keyrecord_t *record) {
1013:quantum/action.c **** #ifdef COMBO_ENABLE
1014:quantum/action.c ****     action_t action;
1015:quantum/action.c ****     if (record->keycode) {
1016:quantum/action.c ****         action = action_for_keycode(record->keycode);
1017:quantum/action.c ****     } else {
1018:quantum/action.c ****         action = layer_switch_get_action(record->event.key);
1019:quantum/action.c ****     }
1020:quantum/action.c **** #else
1021:quantum/action.c ****     action_t action = layer_switch_get_action(record->event.key);
1022:quantum/action.c **** #endif
1023:quantum/action.c ****     return is_tap_action(action);
1024:quantum/action.c **** }
1025:quantum/action.c **** 
1026:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1027:quantum/action.c ****  *
1028:quantum/action.c ****  * FIXME: Needs documentation.
1029:quantum/action.c ****  */
1030:quantum/action.c **** bool is_tap_action(action_t action) {
 2466               		.loc 1 1030 37 view -0
 2467               		.cfi_startproc
 2468               	/* prologue: function */
 2469               	/* frame size = 0 */
 2470               	/* stack size = 0 */
 2471               	.L__stack_usage = 0
 2472               		.loc 1 1030 37 is_stmt 0 view .LVU596
 2473 0000 282F      		mov r18,r24
 2474               	.LVL208:
1031:quantum/action.c ****     switch (action.kind.id) {
 2475               		.loc 1 1031 5 is_stmt 1 view .LVU597
 2476               		.loc 1 1031 24 is_stmt 0 view .LVU598
 2477 0002 892F      		mov r24,r25
 2478 0004 8295      		swap r24
 2479 0006 8F70      		andi r24,lo8(15)
 2480               		.loc 1 1031 5 view .LVU599
 2481 0008 903C      		cpi r25,lo8(-64)
 2482 000a 00F4      		brsh .L239
 2483 000c 8A30      		cpi r24,lo8(10)
 2484 000e 00F4      		brsh .L240
 2485 0010 8430      		cpi r24,lo8(4)
 2486 0012 00F4      		brsh .L241
 2487 0014 8230      		cpi r24,lo8(2)
 2488 0016 00F4      		brsh .L240
 2489               	.L266:
 2490 0018 80E0      		ldi r24,0
 2491 001a 0895      		ret
 2492               	.L241:
 2493 001c 8630      		cpi r24,lo8(6)
 2494 001e 01F4      		brne .L266
1032:quantum/action.c ****         case ACT_LMODS_TAP:
1033:quantum/action.c ****         case ACT_RMODS_TAP:
1034:quantum/action.c ****         case ACT_LAYER_TAP:
1035:quantum/action.c ****         case ACT_LAYER_TAP_EXT:
1036:quantum/action.c ****             switch (action.layer_tap.code) {
1037:quantum/action.c ****                 case KC_NO ... KC_RGUI:
1038:quantum/action.c ****                 case OP_TAP_TOGGLE:
1039:quantum/action.c ****                 case OP_ONESHOT:
1040:quantum/action.c ****                     return true;
1041:quantum/action.c ****             }
1042:quantum/action.c ****             return false;
1043:quantum/action.c ****         case ACT_SWAP_HANDS:
1044:quantum/action.c ****             switch (action.swap.code) {
 2495               		.loc 1 1044 13 is_stmt 1 view .LVU600
1040:quantum/action.c ****             }
 2496               		.loc 1 1040 28 is_stmt 0 view .LVU601
 2497 0020 81E0      		ldi r24,lo8(1)
 2498 0022 283E      		cpi r18,lo8(-24)
 2499 0024 00F0      		brlo .L238
 2500 0026 213F      		cpi r18,lo8(-15)
 2501 0028 01F4      		brne .L266
 2502 002a 00C0      		rjmp .L238
 2503               	.L239:
1031:quantum/action.c ****     switch (action.kind.id) {
 2504               		.loc 1 1031 5 view .LVU602
 2505 002c 8C30      		cpi r24,lo8(12)
 2506 002e 01F0      		breq .L244
 2507 0030 8F30      		cpi r24,lo8(15)
 2508 0032 01F4      		brne .L266
 2509               	.L244:
1045:quantum/action.c ****                 case KC_NO ... KC_RGUI:
1046:quantum/action.c ****                 case OP_SH_TAP_TOGGLE:
1047:quantum/action.c ****                     return true;
1048:quantum/action.c ****             }
1049:quantum/action.c ****             return false;
1050:quantum/action.c ****         case ACT_MACRO:
1051:quantum/action.c ****         case ACT_FUNCTION:
1052:quantum/action.c ****             if (action.func.opt & FUNC_TAP) {
 2510               		.loc 1 1052 13 is_stmt 1 view .LVU603
 2511               		.loc 1 1052 16 is_stmt 0 view .LVU604
 2512 0034 93FB      		bst r25,3
 2513 0036 8827      		clr r24
 2514 0038 80F9      		bld r24,0
 2515 003a 0895      		ret
 2516               	.L240:
1036:quantum/action.c ****                 case KC_NO ... KC_RGUI:
 2517               		.loc 1 1036 13 is_stmt 1 view .LVU605
 2518 003c 81E0      		ldi r24,lo8(1)
 2519 003e 203F      		cpi r18,lo8(-16)
 2520 0040 01F0      		breq .L249
 2521 0042 00F4      		brsh .L245
 2522 0044 283E      		cpi r18,lo8(-24)
 2523 0046 00F4      		brsh .L266
 2524               	.L238:
 2525               	/* epilogue start */
1053:quantum/action.c ****                 return true;
1054:quantum/action.c ****             }
1055:quantum/action.c ****             return false;
1056:quantum/action.c ****     }
1057:quantum/action.c ****     return false;
1058:quantum/action.c **** }
 2526               		.loc 1 1058 1 is_stmt 0 view .LVU606
 2527 0048 0895      		ret
 2528               	.L245:
 2529 004a 243F      		cpi r18,lo8(-12)
 2530 004c 01F4      		brne .L266
 2531 004e 00C0      		rjmp .L238
 2532               	.L249:
 2533 0050 0895      		ret
 2534               		.cfi_endproc
 2535               	.LFE38:
 2537               		.section	.text.is_tap_key,"ax",@progbits
 2538               	.global	is_tap_key
 2540               	is_tap_key:
 2541               	.LVL209:
 2542               	.LFB36:
1003:quantum/action.c ****     action_t action = layer_switch_get_action(key);
 2543               		.loc 1 1003 31 is_stmt 1 view -0
 2544               		.cfi_startproc
 2545               	/* prologue: function */
 2546               	/* frame size = 0 */
 2547               	/* stack size = 0 */
 2548               	.L__stack_usage = 0
1004:quantum/action.c ****     return is_tap_action(action);
 2549               		.loc 1 1004 5 view .LVU608
1004:quantum/action.c ****     return is_tap_action(action);
 2550               		.loc 1 1004 23 is_stmt 0 view .LVU609
 2551 0000 0E94 0000 		call layer_switch_get_action
 2552               	.LVL210:
1005:quantum/action.c **** }
 2553               		.loc 1 1005 5 is_stmt 1 view .LVU610
1005:quantum/action.c **** }
 2554               		.loc 1 1005 12 is_stmt 0 view .LVU611
 2555 0004 0C94 0000 		jmp is_tap_action
 2556               	.LVL211:
 2557               		.cfi_endproc
 2558               	.LFE36:
 2560               		.section	.text.is_tap_record,"ax",@progbits
 2561               	.global	is_tap_record
 2563               	is_tap_record:
 2564               	.LVL212:
 2565               	.LFB37:
1012:quantum/action.c **** #ifdef COMBO_ENABLE
 2566               		.loc 1 1012 41 is_stmt 1 view -0
 2567               		.cfi_startproc
 2568               	/* prologue: function */
 2569               	/* frame size = 0 */
 2570               	/* stack size = 0 */
 2571               	.L__stack_usage = 0
1021:quantum/action.c **** #endif
 2572               		.loc 1 1021 5 view .LVU613
1021:quantum/action.c **** #endif
 2573               		.loc 1 1021 23 is_stmt 0 view .LVU614
 2574 0000 FC01      		movw r30,r24
 2575 0002 8081      		ld r24,Z
 2576 0004 9181      		ldd r25,Z+1
 2577               	.LVL213:
1021:quantum/action.c **** #endif
 2578               		.loc 1 1021 23 view .LVU615
 2579 0006 0E94 0000 		call layer_switch_get_action
 2580               	.LVL214:
1023:quantum/action.c **** }
 2581               		.loc 1 1023 5 is_stmt 1 view .LVU616
1023:quantum/action.c **** }
 2582               		.loc 1 1023 12 is_stmt 0 view .LVU617
 2583 000a 0C94 0000 		jmp is_tap_action
 2584               	.LVL215:
 2585               		.cfi_endproc
 2586               	.LFE37:
 2588               		.section	.text.debug_event,"ax",@progbits
 2589               	.global	debug_event
 2591               	debug_event:
 2592               	.LFB39:
1059:quantum/action.c **** 
1060:quantum/action.c **** /** \brief Debug print (FIXME: Needs better description)
1061:quantum/action.c ****  *
1062:quantum/action.c ****  * FIXME: Needs documentation.
1063:quantum/action.c ****  */
1064:quantum/action.c **** void debug_event(keyevent_t event) { dprintf("%04X%c(%u)", (event.key.row << 8 | event.key.col), (e
 2593               		.loc 1 1064 36 is_stmt 1 view -0
 2594               		.cfi_startproc
 2595 0000 CF93      		push r28
 2596               	.LCFI35:
 2597               		.cfi_def_cfa_offset 3
 2598               		.cfi_offset 28, -2
 2599 0002 DF93      		push r29
 2600               	.LCFI36:
 2601               		.cfi_def_cfa_offset 4
 2602               		.cfi_offset 29, -3
 2603 0004 00D0      		rcall .
 2604 0006 00D0      		rcall .
 2605 0008 0F92      		push __tmp_reg__
 2606               	.LCFI37:
 2607               		.cfi_def_cfa_offset 9
 2608 000a CDB7      		in r28,__SP_L__
 2609 000c DEB7      		in r29,__SP_H__
 2610               	.LCFI38:
 2611               		.cfi_def_cfa_register 28
 2612               	/* prologue: function */
 2613               	/* frame size = 5 */
 2614               	/* stack size = 7 */
 2615               	.L__stack_usage = 7
 2616               		.loc 1 1064 138 view .LVU619
 2617               	/* epilogue start */
 2618               		.loc 1 1064 140 is_stmt 0 view .LVU620
 2619 000e 0F90      		pop __tmp_reg__
 2620 0010 0F90      		pop __tmp_reg__
 2621 0012 0F90      		pop __tmp_reg__
 2622 0014 0F90      		pop __tmp_reg__
 2623 0016 0F90      		pop __tmp_reg__
 2624 0018 DF91      		pop r29
 2625 001a CF91      		pop r28
 2626 001c 0895      		ret
 2627               		.cfi_endproc
 2628               	.LFE39:
 2630               		.section	.text.debug_record,"ax",@progbits
 2631               	.global	debug_record
 2633               	debug_record:
 2634               	.LFB40:
1065:quantum/action.c **** /** \brief Debug print (FIXME: Needs better description)
1066:quantum/action.c ****  *
1067:quantum/action.c ****  * FIXME: Needs documentation.
1068:quantum/action.c ****  */
1069:quantum/action.c **** void debug_record(keyrecord_t record) {
 2635               		.loc 1 1069 39 is_stmt 1 view -0
 2636               		.cfi_startproc
 2637 0000 CF93      		push r28
 2638               	.LCFI39:
 2639               		.cfi_def_cfa_offset 3
 2640               		.cfi_offset 28, -2
 2641 0002 DF93      		push r29
 2642               	.LCFI40:
 2643               		.cfi_def_cfa_offset 4
 2644               		.cfi_offset 29, -3
 2645 0004 00D0      		rcall .
 2646 0006 00D0      		rcall .
 2647 0008 00D0      		rcall .
 2648               	.LCFI41:
 2649               		.cfi_def_cfa_offset 10
 2650 000a CDB7      		in r28,__SP_L__
 2651 000c DEB7      		in r29,__SP_H__
 2652               	.LCFI42:
 2653               		.cfi_def_cfa_register 28
 2654               	/* prologue: function */
 2655               	/* frame size = 6 */
 2656               	/* stack size = 8 */
 2657               	.L__stack_usage = 8
1070:quantum/action.c ****     debug_event(record.event);
 2658               		.loc 1 1070 5 view .LVU622
1071:quantum/action.c **** #ifndef NO_ACTION_TAPPING
1072:quantum/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 2659               		.loc 1 1072 77 view .LVU623
 2660               	/* epilogue start */
1073:quantum/action.c **** #endif
1074:quantum/action.c **** }
 2661               		.loc 1 1074 1 is_stmt 0 view .LVU624
 2662 000e 2696      		adiw r28,6
 2663 0010 0FB6      		in __tmp_reg__,__SREG__
 2664 0012 F894      		cli
 2665 0014 DEBF      		out __SP_H__,r29
 2666 0016 0FBE      		out __SREG__,__tmp_reg__
 2667 0018 CDBF      		out __SP_L__,r28
 2668 001a DF91      		pop r29
 2669 001c CF91      		pop r28
 2670 001e 0895      		ret
 2671               		.cfi_endproc
 2672               	.LFE40:
 2674               		.section	.text.debug_action,"ax",@progbits
 2675               	.global	debug_action
 2677               	debug_action:
 2678               	.LVL216:
 2679               	.LFB41:
1075:quantum/action.c **** 
1076:quantum/action.c **** /** \brief Debug print (FIXME: Needs better description)
1077:quantum/action.c ****  *
1078:quantum/action.c ****  * FIXME: Needs documentation.
1079:quantum/action.c ****  */
1080:quantum/action.c **** void debug_action(action_t action) {
 2680               		.loc 1 1080 36 is_stmt 1 view -0
 2681               		.cfi_startproc
 2682               	/* prologue: function */
 2683               	/* frame size = 0 */
 2684               	/* stack size = 0 */
 2685               	.L__stack_usage = 0
1081:quantum/action.c ****     switch (action.kind.id) {
 2686               		.loc 1 1081 5 view .LVU626
1082:quantum/action.c ****         case ACT_LMODS:
1083:quantum/action.c ****             dprint("ACT_LMODS");
1084:quantum/action.c ****             break;
1085:quantum/action.c ****         case ACT_RMODS:
1086:quantum/action.c ****             dprint("ACT_RMODS");
1087:quantum/action.c ****             break;
1088:quantum/action.c ****         case ACT_LMODS_TAP:
1089:quantum/action.c ****             dprint("ACT_LMODS_TAP");
1090:quantum/action.c ****             break;
1091:quantum/action.c ****         case ACT_RMODS_TAP:
1092:quantum/action.c ****             dprint("ACT_RMODS_TAP");
1093:quantum/action.c ****             break;
1094:quantum/action.c ****         case ACT_USAGE:
1095:quantum/action.c ****             dprint("ACT_USAGE");
1096:quantum/action.c ****             break;
1097:quantum/action.c ****         case ACT_MOUSEKEY:
1098:quantum/action.c ****             dprint("ACT_MOUSEKEY");
1099:quantum/action.c ****             break;
1100:quantum/action.c ****         case ACT_LAYER:
1101:quantum/action.c ****             dprint("ACT_LAYER");
1102:quantum/action.c ****             break;
1103:quantum/action.c ****         case ACT_LAYER_MODS:
1104:quantum/action.c ****             dprint("ACT_LAYER_MODS");
1105:quantum/action.c ****             break;
1106:quantum/action.c ****         case ACT_LAYER_TAP:
1107:quantum/action.c ****             dprint("ACT_LAYER_TAP");
1108:quantum/action.c ****             break;
1109:quantum/action.c ****         case ACT_LAYER_TAP_EXT:
1110:quantum/action.c ****             dprint("ACT_LAYER_TAP_EXT");
1111:quantum/action.c ****             break;
1112:quantum/action.c ****         case ACT_MACRO:
1113:quantum/action.c ****             dprint("ACT_MACRO");
1114:quantum/action.c ****             break;
1115:quantum/action.c ****         case ACT_FUNCTION:
1116:quantum/action.c ****             dprint("ACT_FUNCTION");
1117:quantum/action.c ****             break;
1118:quantum/action.c ****         case ACT_SWAP_HANDS:
1119:quantum/action.c ****             dprint("ACT_SWAP_HANDS");
1120:quantum/action.c ****             break;
1121:quantum/action.c ****         default:
1122:quantum/action.c ****             dprint("UNKNOWN");
1123:quantum/action.c ****             break;
1124:quantum/action.c ****     }
1125:quantum/action.c ****     dprintf("[%X:%02X]", action.kind.param >> 8, action.kind.param & 0xff);
 2687               		.loc 1 1125 75 view .LVU627
 2688               	/* epilogue start */
1126:quantum/action.c **** }
 2689               		.loc 1 1126 1 is_stmt 0 view .LVU628
 2690 0000 0895      		ret
 2691               		.cfi_endproc
 2692               	.LFE41:
 2694               		.section	.bss.swap_state.0,"aw",@nobits
 2697               	swap_state.0:
 2698 0000 0000 0000 		.zero	10
 2698      0000 0000 
 2698      0000 
 2699               	.global	disable_action_cache
 2700               		.section	.bss.disable_action_cache,"aw",@nobits
 2703               	disable_action_cache:
 2704 0000 00        		.zero	1
 2705               	.global	swap_held
 2706               		.section	.bss.swap_held,"aw",@nobits
 2709               	swap_held:
 2710 0000 00        		.zero	1
 2711               	.global	swap_hands
 2712               		.section	.bss.swap_hands,"aw",@nobits
 2715               	swap_hands:
 2716 0000 00        		.zero	1
 2717               		.comm	tp_buttons,2,1
 2718               		.text
 2719               	.Letext0:
 2720               		.file 4 "/usr/avr/include/stdint.h"
 2721               		.file 5 "quantum/keycode.h"
 2722               		.file 6 "tmk_core/common/report.h"
 2723               		.file 7 "quantum/action_code.h"
 2724               		.file 8 "quantum/action.h"
 2725               		.file 9 "quantum/action_layer.h"
 2726               		.file 10 "quantum/action_util.h"
 2727               		.file 11 "tmk_core/common/host.h"
 2728               		.file 12 "/usr/avr/include/math.h"
 2729               		.file 13 "quantum/led.h"
 2730               		.file 14 "quantum/action_tapping.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
     /tmp/cckZHCjD.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cckZHCjD.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cckZHCjD.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cckZHCjD.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cckZHCjD.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cckZHCjD.s:13     .text.process_hand_swap:0000000000000000 process_hand_swap
     /tmp/cckZHCjD.s:2697   .bss.swap_state.0:0000000000000000 swap_state.0
     /tmp/cckZHCjD.s:2715   .bss.swap_hands:0000000000000000 swap_hands
     /tmp/cckZHCjD.s:168    .text.process_record_quantum:0000000000000000 process_record_quantum
     /tmp/cckZHCjD.s:168    .text.process_record_quantum:0000000000000000 process_record_quantum.localalias
     /tmp/cckZHCjD.s:191    .text.pre_process_record_quantum:0000000000000000 pre_process_record_quantum
     /tmp/cckZHCjD.s:205    .text.action_exec:0000000000000000 action_exec
     /tmp/cckZHCjD.s:392    .text.post_process_record_quantum:0000000000000000 post_process_record_quantum
     /tmp/cckZHCjD.s:410    .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
     /tmp/cckZHCjD.s:2709   .bss.swap_held:0000000000000000 swap_held
     /tmp/cckZHCjD.s:460    .text.register_code:0000000000000000 register_code
     /tmp/cckZHCjD.s:555    .text.unregister_code:0000000000000000 unregister_code
     /tmp/cckZHCjD.s:645    .text.tap_code_delay:0000000000000000 tap_code_delay
     /tmp/cckZHCjD.s:733    .text.tap_code:0000000000000000 tap_code
     /tmp/cckZHCjD.s:760    .text.register_mods:0000000000000000 register_mods
     /tmp/cckZHCjD.s:789    .text.unregister_mods:0000000000000000 unregister_mods
     /tmp/cckZHCjD.s:818    .text.process_action:0000000000000000 process_action
     /tmp/cckZHCjD.s:2210   .text.process_record:0000000000000000 process_record
     /tmp/cckZHCjD.s:2141   .text.process_record_handler:0000000000000000 process_record_handler
     /tmp/cckZHCjD.s:2314   .text.process_record_nocache:0000000000000000 process_record_nocache
     /tmp/cckZHCjD.s:2703   .bss.disable_action_cache:0000000000000000 disable_action_cache
     /tmp/cckZHCjD.s:2342   .text.register_weak_mods:0000000000000000 register_weak_mods
     /tmp/cckZHCjD.s:2371   .text.unregister_weak_mods:0000000000000000 unregister_weak_mods
     /tmp/cckZHCjD.s:2400   .text.clear_keyboard_but_mods_and_keys:0000000000000000 clear_keyboard_but_mods_and_keys
     /tmp/cckZHCjD.s:2423   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
     /tmp/cckZHCjD.s:2443   .text.clear_keyboard:0000000000000000 clear_keyboard
     /tmp/cckZHCjD.s:2463   .text.is_tap_action:0000000000000000 is_tap_action
     /tmp/cckZHCjD.s:2540   .text.is_tap_key:0000000000000000 is_tap_key
     /tmp/cckZHCjD.s:2563   .text.is_tap_record:0000000000000000 is_tap_record
     /tmp/cckZHCjD.s:2591   .text.debug_event:0000000000000000 debug_event
     /tmp/cckZHCjD.s:2633   .text.debug_record:0000000000000000 debug_record
     /tmp/cckZHCjD.s:2677   .text.debug_action:0000000000000000 debug_action
                            *COM*:0000000000000002 tp_buttons

UNDEFINED SYMBOLS
hand_swap_config
clear_weak_mods
action_tapping_process
layer_switch_get_action
keyboard_report
is_key_pressed
del_key
send_keyboard_report
add_key
add_mods
del_mods
host_system_send
host_consumer_send
is_oneshot_layer_active
clear_oneshot_layer_state
host_keyboard_leds
led_set
use_oneshot_swaphands
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
add_weak_mods
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
default_layer_or
default_layer_xor
default_layer_set
layer_and
layer_or
layer_xor
layer_state_set
set_oneshot_layer
layer_invert
layer_move
layer_clear
__tablejump2__
set_oneshot_swaphands
release_oneshot_swaphands
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
clear_keys
clear_mods
__do_clear_bss
