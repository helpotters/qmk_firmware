   1               		.file	"transactions.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.sync_timer_handlers_master,"ax",@progbits
  12               	sync_timer_handlers_master:
  13               	.LVL0:
  14               	.LFB35:
  15               		.file 1 "quantum/split_common/transactions.c"
   1:quantum/split_common/transactions.c **** /* Copyright 2021 QMK
   2:quantum/split_common/transactions.c ****  *
   3:quantum/split_common/transactions.c ****  * This program is free software: you can redistribute it and/or modify
   4:quantum/split_common/transactions.c ****  * it under the terms of the GNU General Public License as published by
   5:quantum/split_common/transactions.c ****  * the Free Software Foundation, either version 2 of the License, or
   6:quantum/split_common/transactions.c ****  * (at your option) any later version.
   7:quantum/split_common/transactions.c ****  *
   8:quantum/split_common/transactions.c ****  * This program is distributed in the hope that it will be useful,
   9:quantum/split_common/transactions.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  10:quantum/split_common/transactions.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11:quantum/split_common/transactions.c ****  * GNU General Public License for more details.
  12:quantum/split_common/transactions.c ****  *
  13:quantum/split_common/transactions.c ****  * You should have received a copy of the GNU General Public License
  14:quantum/split_common/transactions.c ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15:quantum/split_common/transactions.c ****  */
  16:quantum/split_common/transactions.c **** 
  17:quantum/split_common/transactions.c **** #include <string.h>
  18:quantum/split_common/transactions.c **** #include <stddef.h>
  19:quantum/split_common/transactions.c **** 
  20:quantum/split_common/transactions.c **** #include "crc.h"
  21:quantum/split_common/transactions.c **** #include "debug.h"
  22:quantum/split_common/transactions.c **** #include "matrix.h"
  23:quantum/split_common/transactions.c **** #include "quantum.h"
  24:quantum/split_common/transactions.c **** #include "transactions.h"
  25:quantum/split_common/transactions.c **** #include "transport.h"
  26:quantum/split_common/transactions.c **** #include "split_util.h"
  27:quantum/split_common/transactions.c **** #include "transaction_id_define.h"
  28:quantum/split_common/transactions.c **** 
  29:quantum/split_common/transactions.c **** #define SYNC_TIMER_OFFSET 2
  30:quantum/split_common/transactions.c **** 
  31:quantum/split_common/transactions.c **** #ifndef FORCED_SYNC_THROTTLE_MS
  32:quantum/split_common/transactions.c **** #    define FORCED_SYNC_THROTTLE_MS 100
  33:quantum/split_common/transactions.c **** #endif  // FORCED_SYNC_THROTTLE_MS
  34:quantum/split_common/transactions.c **** 
  35:quantum/split_common/transactions.c **** #define sizeof_member(type, member) sizeof(((type *)NULL)->member)
  36:quantum/split_common/transactions.c **** 
  37:quantum/split_common/transactions.c **** #define trans_initiator2target_initializer_cb(member, cb) \
  38:quantum/split_common/transactions.c ****     { &dummy, sizeof_member(split_shared_memory_t, member), offsetof(split_shared_memory_t, member)
  39:quantum/split_common/transactions.c **** #define trans_initiator2target_initializer(member) trans_initiator2target_initializer_cb(member, NU
  40:quantum/split_common/transactions.c **** 
  41:quantum/split_common/transactions.c **** #define trans_target2initiator_initializer_cb(member, cb) \
  42:quantum/split_common/transactions.c ****     { &dummy, 0, 0, sizeof_member(split_shared_memory_t, member), offsetof(split_shared_memory_t, m
  43:quantum/split_common/transactions.c **** #define trans_target2initiator_initializer(member) trans_target2initiator_initializer_cb(member, NU
  44:quantum/split_common/transactions.c **** 
  45:quantum/split_common/transactions.c **** #define transport_write(id, data, length)          transport_execute_transaction(id, data, length, 
  46:quantum/split_common/transactions.c **** #define transport_read(id, data, length)           transport_execute_transaction(id, NULL, 0, data,
  47:quantum/split_common/transactions.c **** 
  48:quantum/split_common/transactions.c **** #if defined(SPLIT_TRANSACTION_IDS_KB) || defined(SPLIT_TRANSACTION_IDS_USER)
  49:quantum/split_common/transactions.c **** // Forward-declare the RPC callback handlers
  50:quantum/split_common/transactions.c **** void slave_rpc_info_callback(uint8_t initiator2target_buffer_size, const void *initiator2target_buf
  51:quantum/split_common/transactions.c **** void slave_rpc_exec_callback(uint8_t initiator2target_buffer_size, const void *initiator2target_buf
  52:quantum/split_common/transactions.c **** #endif  // defined(SPLIT_TRANSACTION_IDS_KB) || defined(SPLIT_TRANSACTION_IDS_USER)
  53:quantum/split_common/transactions.c **** 
  54:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
  55:quantum/split_common/transactions.c **** // Helpers
  56:quantum/split_common/transactions.c **** 
  57:quantum/split_common/transactions.c **** static bool transaction_handler_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[], c
  58:quantum/split_common/transactions.c ****     int num_retries = is_transport_connected() ? 10 : 1;
  59:quantum/split_common/transactions.c ****     for (int iter = 1; iter <= num_retries; ++iter) {
  60:quantum/split_common/transactions.c ****         if (iter > 1) {
  61:quantum/split_common/transactions.c ****             for (int i = 0; i < iter * iter; ++i) {
  62:quantum/split_common/transactions.c ****                 wait_us(10);
  63:quantum/split_common/transactions.c ****             }
  64:quantum/split_common/transactions.c ****         }
  65:quantum/split_common/transactions.c ****         bool this_okay = true;
  66:quantum/split_common/transactions.c ****         ATOMIC_BLOCK_FORCEON { this_okay = handler(master_matrix, slave_matrix); };
  67:quantum/split_common/transactions.c ****         if (this_okay) return true;
  68:quantum/split_common/transactions.c ****     }
  69:quantum/split_common/transactions.c ****     dprintf("Failed to execute %s\n", prefix);
  70:quantum/split_common/transactions.c ****     return false;
  71:quantum/split_common/transactions.c **** }
  72:quantum/split_common/transactions.c **** 
  73:quantum/split_common/transactions.c **** #define TRANSACTION_HANDLER_MASTER(prefix)                                                         
  74:quantum/split_common/transactions.c ****     do {                                                                                           
  75:quantum/split_common/transactions.c ****         if (!transaction_handler_master(master_matrix, slave_matrix, #prefix, &prefix##_handlers_ma
  76:quantum/split_common/transactions.c ****     } while (0)
  77:quantum/split_common/transactions.c **** 
  78:quantum/split_common/transactions.c **** #define TRANSACTION_HANDLER_SLAVE(prefix)                                               \
  79:quantum/split_common/transactions.c ****     do {                                                                                \
  80:quantum/split_common/transactions.c ****         ATOMIC_BLOCK_FORCEON { prefix##_handlers_slave(master_matrix, slave_matrix); }; \
  81:quantum/split_common/transactions.c ****     } while (0)
  82:quantum/split_common/transactions.c **** 
  83:quantum/split_common/transactions.c **** inline static bool read_if_checksum_mismatch(int8_t trans_id_checksum, int8_t trans_id_retrieve, ui
  84:quantum/split_common/transactions.c ****     uint8_t curr_checksum;
  85:quantum/split_common/transactions.c ****     bool    okay = transport_read(trans_id_checksum, &curr_checksum, sizeof(curr_checksum));
  86:quantum/split_common/transactions.c ****     if (okay && (timer_elapsed32(*last_update) >= FORCED_SYNC_THROTTLE_MS || curr_checksum != crc8(
  87:quantum/split_common/transactions.c ****         okay &= transport_read(trans_id_retrieve, destination, length);
  88:quantum/split_common/transactions.c ****         okay &= curr_checksum == crc8(equiv_shmem, length);
  89:quantum/split_common/transactions.c ****         if (okay) {
  90:quantum/split_common/transactions.c ****             *last_update = timer_read32();
  91:quantum/split_common/transactions.c ****         }
  92:quantum/split_common/transactions.c ****     } else {
  93:quantum/split_common/transactions.c ****         memcpy(destination, equiv_shmem, length);
  94:quantum/split_common/transactions.c ****     }
  95:quantum/split_common/transactions.c ****     return okay;
  96:quantum/split_common/transactions.c **** }
  97:quantum/split_common/transactions.c **** 
  98:quantum/split_common/transactions.c **** inline static bool send_if_condition(int8_t trans_id, uint32_t *last_update, bool condition, void *
  99:quantum/split_common/transactions.c ****     bool okay = true;
 100:quantum/split_common/transactions.c ****     if (timer_elapsed32(*last_update) >= FORCED_SYNC_THROTTLE_MS || condition) {
 101:quantum/split_common/transactions.c ****         okay &= transport_write(trans_id, source, length);
 102:quantum/split_common/transactions.c ****         if (okay) {
 103:quantum/split_common/transactions.c ****             *last_update = timer_read32();
 104:quantum/split_common/transactions.c ****         }
 105:quantum/split_common/transactions.c ****     }
 106:quantum/split_common/transactions.c ****     return okay;
 107:quantum/split_common/transactions.c **** }
 108:quantum/split_common/transactions.c **** 
 109:quantum/split_common/transactions.c **** inline static bool send_if_data_mismatch(int8_t trans_id, uint32_t *last_update, void *source, cons
 110:quantum/split_common/transactions.c ****     // Just run a memcmp to compare the source and equivalent shmem location
 111:quantum/split_common/transactions.c ****     return send_if_condition(trans_id, last_update, (memcmp(source, equiv_shmem, length) != 0), sou
 112:quantum/split_common/transactions.c **** }
 113:quantum/split_common/transactions.c **** 
 114:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
 115:quantum/split_common/transactions.c **** // Slave matrix
 116:quantum/split_common/transactions.c **** 
 117:quantum/split_common/transactions.c **** static bool slave_matrix_handlers_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[])
 118:quantum/split_common/transactions.c ****     static uint32_t     last_update                    = 0;
 119:quantum/split_common/transactions.c ****     static matrix_row_t last_matrix[(MATRIX_ROWS) / 2] = {0};  // last successfully-read matrix, so
 120:quantum/split_common/transactions.c ****     matrix_row_t        temp_matrix[(MATRIX_ROWS) / 2];        // holding area while we test whethe
 121:quantum/split_common/transactions.c **** 
 122:quantum/split_common/transactions.c ****     bool okay = read_if_checksum_mismatch(GET_SLAVE_MATRIX_CHECKSUM, GET_SLAVE_MATRIX_DATA, &last_u
 123:quantum/split_common/transactions.c ****     if (okay) {
 124:quantum/split_common/transactions.c ****         // Checksum matches the received data, save as the last matrix state
 125:quantum/split_common/transactions.c ****         memcpy(last_matrix, temp_matrix, sizeof(temp_matrix));
 126:quantum/split_common/transactions.c ****     }
 127:quantum/split_common/transactions.c ****     // Copy out the last-known-good matrix state to the slave matrix
 128:quantum/split_common/transactions.c ****     memcpy(slave_matrix, last_matrix, sizeof(last_matrix));
 129:quantum/split_common/transactions.c ****     return okay;
 130:quantum/split_common/transactions.c **** }
 131:quantum/split_common/transactions.c **** 
 132:quantum/split_common/transactions.c **** static void slave_matrix_handlers_slave(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) 
 133:quantum/split_common/transactions.c ****     memcpy(split_shmem->smatrix.matrix, slave_matrix, sizeof(split_shmem->smatrix.matrix));
 134:quantum/split_common/transactions.c ****     split_shmem->smatrix.checksum = crc8(split_shmem->smatrix.matrix, sizeof(split_shmem->smatrix.m
 135:quantum/split_common/transactions.c **** }
 136:quantum/split_common/transactions.c **** 
 137:quantum/split_common/transactions.c **** // clang-format off
 138:quantum/split_common/transactions.c **** #define TRANSACTIONS_SLAVE_MATRIX_MASTER() TRANSACTION_HANDLER_MASTER(slave_matrix)
 139:quantum/split_common/transactions.c **** #define TRANSACTIONS_SLAVE_MATRIX_SLAVE() TRANSACTION_HANDLER_SLAVE(slave_matrix)
 140:quantum/split_common/transactions.c **** #define TRANSACTIONS_SLAVE_MATRIX_REGISTRATIONS \
 141:quantum/split_common/transactions.c ****     [GET_SLAVE_MATRIX_CHECKSUM] = trans_target2initiator_initializer(smatrix.checksum), \
 142:quantum/split_common/transactions.c ****     [GET_SLAVE_MATRIX_DATA]     = trans_target2initiator_initializer(smatrix.matrix),
 143:quantum/split_common/transactions.c **** // clang-format on
 144:quantum/split_common/transactions.c **** 
 145:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
 146:quantum/split_common/transactions.c **** // Master matrix
 147:quantum/split_common/transactions.c **** 
 148:quantum/split_common/transactions.c **** #ifdef SPLIT_TRANSPORT_MIRROR
 149:quantum/split_common/transactions.c **** 
 150:quantum/split_common/transactions.c **** static bool master_matrix_handlers_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]
 151:quantum/split_common/transactions.c ****     static uint32_t last_update = 0;
 152:quantum/split_common/transactions.c ****     return send_if_data_mismatch(PUT_MASTER_MATRIX, &last_update, master_matrix, split_shmem->mmatr
 153:quantum/split_common/transactions.c **** }
 154:quantum/split_common/transactions.c **** 
 155:quantum/split_common/transactions.c **** static void master_matrix_handlers_slave(matrix_row_t master_matrix[], matrix_row_t slave_matrix[])
 156:quantum/split_common/transactions.c ****     // Always copy to the master matrix
 157:quantum/split_common/transactions.c ****     memcpy(master_matrix, split_shmem->mmatrix.matrix, sizeof(split_shmem->mmatrix.matrix));
 158:quantum/split_common/transactions.c **** }
 159:quantum/split_common/transactions.c **** 
 160:quantum/split_common/transactions.c **** #    define TRANSACTIONS_MASTER_MATRIX_MASTER()      TRANSACTION_HANDLER_MASTER(master_matrix)
 161:quantum/split_common/transactions.c **** #    define TRANSACTIONS_MASTER_MATRIX_SLAVE()       TRANSACTION_HANDLER_SLAVE(master_matrix)
 162:quantum/split_common/transactions.c **** #    define TRANSACTIONS_MASTER_MATRIX_REGISTRATIONS [PUT_MASTER_MATRIX] = trans_initiator2target_i
 163:quantum/split_common/transactions.c **** 
 164:quantum/split_common/transactions.c **** #else  // SPLIT_TRANSPORT_MIRROR
 165:quantum/split_common/transactions.c **** 
 166:quantum/split_common/transactions.c **** #    define TRANSACTIONS_MASTER_MATRIX_MASTER()
 167:quantum/split_common/transactions.c **** #    define TRANSACTIONS_MASTER_MATRIX_SLAVE()
 168:quantum/split_common/transactions.c **** #    define TRANSACTIONS_MASTER_MATRIX_REGISTRATIONS
 169:quantum/split_common/transactions.c **** 
 170:quantum/split_common/transactions.c **** #endif  // SPLIT_TRANSPORT_MIRROR
 171:quantum/split_common/transactions.c **** 
 172:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
 173:quantum/split_common/transactions.c **** // Encoders
 174:quantum/split_common/transactions.c **** 
 175:quantum/split_common/transactions.c **** #ifdef ENCODER_ENABLE
 176:quantum/split_common/transactions.c **** 
 177:quantum/split_common/transactions.c **** static bool encoder_handlers_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 178:quantum/split_common/transactions.c ****     static uint32_t last_update = 0;
 179:quantum/split_common/transactions.c ****     uint8_t         temp_state[NUMBER_OF_ENCODERS];
 180:quantum/split_common/transactions.c **** 
 181:quantum/split_common/transactions.c ****     bool okay = read_if_checksum_mismatch(GET_ENCODERS_CHECKSUM, GET_ENCODERS_DATA, &last_update, t
 182:quantum/split_common/transactions.c ****     if (okay) encoder_update_raw(temp_state);
 183:quantum/split_common/transactions.c ****     return okay;
 184:quantum/split_common/transactions.c **** }
 185:quantum/split_common/transactions.c **** 
 186:quantum/split_common/transactions.c **** static void encoder_handlers_slave(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 187:quantum/split_common/transactions.c ****     uint8_t encoder_state[NUMBER_OF_ENCODERS];
 188:quantum/split_common/transactions.c ****     encoder_state_raw(encoder_state);
 189:quantum/split_common/transactions.c ****     // Always prepare the encoder state for read.
 190:quantum/split_common/transactions.c ****     memcpy(split_shmem->encoders.state, encoder_state, sizeof(encoder_state));
 191:quantum/split_common/transactions.c ****     // Now update the checksum given that the encoders has been written to
 192:quantum/split_common/transactions.c ****     split_shmem->encoders.checksum = crc8(encoder_state, sizeof(encoder_state));
 193:quantum/split_common/transactions.c **** }
 194:quantum/split_common/transactions.c **** 
 195:quantum/split_common/transactions.c **** // clang-format off
 196:quantum/split_common/transactions.c **** #    define TRANSACTIONS_ENCODERS_MASTER() TRANSACTION_HANDLER_MASTER(encoder)
 197:quantum/split_common/transactions.c **** #    define TRANSACTIONS_ENCODERS_SLAVE() TRANSACTION_HANDLER_SLAVE(encoder)
 198:quantum/split_common/transactions.c **** #    define TRANSACTIONS_ENCODERS_REGISTRATIONS \
 199:quantum/split_common/transactions.c ****     [GET_ENCODERS_CHECKSUM] = trans_target2initiator_initializer(encoders.checksum), \
 200:quantum/split_common/transactions.c ****     [GET_ENCODERS_DATA]     = trans_target2initiator_initializer(encoders.state),
 201:quantum/split_common/transactions.c **** // clang-format on
 202:quantum/split_common/transactions.c **** 
 203:quantum/split_common/transactions.c **** #else  // ENCODER_ENABLE
 204:quantum/split_common/transactions.c **** 
 205:quantum/split_common/transactions.c **** #    define TRANSACTIONS_ENCODERS_MASTER()
 206:quantum/split_common/transactions.c **** #    define TRANSACTIONS_ENCODERS_SLAVE()
 207:quantum/split_common/transactions.c **** #    define TRANSACTIONS_ENCODERS_REGISTRATIONS
 208:quantum/split_common/transactions.c **** 
 209:quantum/split_common/transactions.c **** #endif  // ENCODER_ENABLE
 210:quantum/split_common/transactions.c **** 
 211:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
 212:quantum/split_common/transactions.c **** // Sync timer
 213:quantum/split_common/transactions.c **** 
 214:quantum/split_common/transactions.c **** #ifndef DISABLE_SYNC_TIMER
 215:quantum/split_common/transactions.c **** 
 216:quantum/split_common/transactions.c **** static bool sync_timer_handlers_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
  16               		.loc 1 216 99 view -0
  17               		.cfi_startproc
  18               		.loc 1 216 99 is_stmt 0 view .LVU1
  19 0000 0F93      		push r16
  20               	.LCFI0:
  21               		.cfi_def_cfa_offset 3
  22               		.cfi_offset 16, -2
  23 0002 1F93      		push r17
  24               	.LCFI1:
  25               		.cfi_def_cfa_offset 4
  26               		.cfi_offset 17, -3
  27 0004 CF93      		push r28
  28               	.LCFI2:
  29               		.cfi_def_cfa_offset 5
  30               		.cfi_offset 28, -4
  31 0006 DF93      		push r29
  32               	.LCFI3:
  33               		.cfi_def_cfa_offset 6
  34               		.cfi_offset 29, -5
  35 0008 CDB7      		in r28,__SP_L__
  36 000a DEB7      		in r29,__SP_H__
  37               	.LCFI4:
  38               		.cfi_def_cfa_register 28
  39 000c 2897      		sbiw r28,8
  40               	.LCFI5:
  41               		.cfi_def_cfa_offset 14
  42 000e 0FB6      		in __tmp_reg__,__SREG__
  43 0010 F894      		cli
  44 0012 DEBF      		out __SP_H__,r29
  45 0014 0FBE      		out __SREG__,__tmp_reg__
  46 0016 CDBF      		out __SP_L__,r28
  47               	/* prologue: function */
  48               	/* frame size = 8 */
  49               	/* stack size = 12 */
  50               	.L__stack_usage = 12
 217:quantum/split_common/transactions.c ****     static uint32_t last_update = 0;
  51               		.loc 1 217 5 is_stmt 1 view .LVU2
 218:quantum/split_common/transactions.c **** 
 219:quantum/split_common/transactions.c ****     bool okay = true;
  52               		.loc 1 219 5 view .LVU3
  53               	.LVL1:
 220:quantum/split_common/transactions.c ****     if (timer_elapsed32(last_update) >= FORCED_SYNC_THROTTLE_MS) {
  54               		.loc 1 220 5 view .LVU4
  55               		.loc 1 220 9 is_stmt 0 view .LVU5
  56 0018 8091 0000 		lds r24,last_update.5
  57 001c 9091 0000 		lds r25,last_update.5+1
  58 0020 A091 0000 		lds r26,last_update.5+2
  59 0024 B091 0000 		lds r27,last_update.5+3
  60               	.LVL2:
  61               		.loc 1 220 9 view .LVU6
  62 0028 BC01      		movw r22,r24
  63               	.LVL3:
  64               		.loc 1 220 9 view .LVU7
  65 002a CD01      		movw r24,r26
  66 002c 0E94 0000 		call timer_elapsed32
  67               	.LVL4:
 219:quantum/split_common/transactions.c ****     if (timer_elapsed32(last_update) >= FORCED_SYNC_THROTTLE_MS) {
  68               		.loc 1 219 10 view .LVU8
  69 0030 11E0      		ldi r17,lo8(1)
  70               		.loc 1 220 8 view .LVU9
  71 0032 6436      		cpi r22,100
  72 0034 7105      		cpc r23,__zero_reg__
  73 0036 8105      		cpc r24,__zero_reg__
  74 0038 9105      		cpc r25,__zero_reg__
  75 003a 00F0      		brlo .L1
  76               	.LBB45:
 221:quantum/split_common/transactions.c ****         uint32_t sync_timer = sync_timer_read32() + SYNC_TIMER_OFFSET;
  77               		.loc 1 221 9 is_stmt 1 view .LVU10
  78               		.loc 1 221 31 is_stmt 0 view .LVU11
  79 003c 0E94 0000 		call sync_timer_read32
  80               	.LVL5:
  81               		.loc 1 221 51 view .LVU12
  82 0040 DC01      		movw r26,r24
  83 0042 CB01      		movw r24,r22
  84 0044 0296      		adiw r24,2
  85 0046 A11D      		adc r26,__zero_reg__
  86 0048 B11D      		adc r27,__zero_reg__
  87               		.loc 1 221 18 view .LVU13
  88 004a 8983      		std Y+1,r24
  89 004c 9A83      		std Y+2,r25
  90 004e AB83      		std Y+3,r26
  91 0050 BC83      		std Y+4,r27
 222:quantum/split_common/transactions.c ****         okay &= transport_write(PUT_SYNC_TIMER, &sync_timer, sizeof(sync_timer));
  92               		.loc 1 222 9 is_stmt 1 view .LVU14
  93               		.loc 1 222 17 is_stmt 0 view .LVU15
  94 0052 10E0      		ldi r17,0
  95 0054 00E0      		ldi r16,0
  96 0056 30E0      		ldi r19,0
  97 0058 20E0      		ldi r18,0
  98 005a 44E0      		ldi r20,lo8(4)
  99 005c 50E0      		ldi r21,0
 100 005e BE01      		movw r22,r28
 101 0060 6F5F      		subi r22,-1
 102 0062 7F4F      		sbci r23,-1
 103 0064 84E0      		ldi r24,lo8(4)
 104 0066 0E94 0000 		call transport_execute_transaction
 105               	.LVL6:
 106 006a 182F      		mov r17,r24
 107               	.LVL7:
 223:quantum/split_common/transactions.c ****         if (okay) {
 108               		.loc 1 223 9 is_stmt 1 view .LVU16
 109               		.loc 1 223 12 is_stmt 0 view .LVU17
 110 006c 8823      		tst r24
 111 006e 01F0      		breq .L1
 224:quantum/split_common/transactions.c ****             last_update = timer_read32();
 112               		.loc 1 224 13 is_stmt 1 view .LVU18
 113               		.loc 1 224 27 is_stmt 0 view .LVU19
 114 0070 0E94 0000 		call timer_read32
 115               	.LVL8:
 116 0074 6093 0000 		sts last_update.5,r22
 117 0078 7093 0000 		sts last_update.5+1,r23
 118 007c 8093 0000 		sts last_update.5+2,r24
 119 0080 9093 0000 		sts last_update.5+3,r25
 120               	.LVL9:
 121               	.L1:
 122               		.loc 1 224 27 view .LVU20
 123               	.LBE45:
 225:quantum/split_common/transactions.c ****         }
 226:quantum/split_common/transactions.c ****     }
 227:quantum/split_common/transactions.c ****     return okay;
 228:quantum/split_common/transactions.c **** }
 124               		.loc 1 228 1 view .LVU21
 125 0084 812F      		mov r24,r17
 126               	/* epilogue start */
 127 0086 2896      		adiw r28,8
 128 0088 0FB6      		in __tmp_reg__,__SREG__
 129 008a F894      		cli
 130 008c DEBF      		out __SP_H__,r29
 131 008e 0FBE      		out __SREG__,__tmp_reg__
 132 0090 CDBF      		out __SP_L__,r28
 133 0092 DF91      		pop r29
 134 0094 CF91      		pop r28
 135 0096 1F91      		pop r17
 136 0098 0F91      		pop r16
 137 009a 0895      		ret
 138               		.cfi_endproc
 139               	.LFE35:
 141               		.section	.text.transaction_handler_master,"ax",@progbits
 143               	transaction_handler_master:
 144               	.LVL10:
 145               	.LFB27:
  57:quantum/split_common/transactions.c ****     int num_retries = is_transport_connected() ? 10 : 1;
 146               		.loc 1 57 195 is_stmt 1 view -0
 147               		.cfi_startproc
  57:quantum/split_common/transactions.c ****     int num_retries = is_transport_connected() ? 10 : 1;
 148               		.loc 1 57 195 is_stmt 0 view .LVU23
 149 0000 7F92      		push r7
 150               	.LCFI6:
 151               		.cfi_def_cfa_offset 3
 152               		.cfi_offset 7, -2
 153 0002 8F92      		push r8
 154               	.LCFI7:
 155               		.cfi_def_cfa_offset 4
 156               		.cfi_offset 8, -3
 157 0004 9F92      		push r9
 158               	.LCFI8:
 159               		.cfi_def_cfa_offset 5
 160               		.cfi_offset 9, -4
 161 0006 AF92      		push r10
 162               	.LCFI9:
 163               		.cfi_def_cfa_offset 6
 164               		.cfi_offset 10, -5
 165 0008 BF92      		push r11
 166               	.LCFI10:
 167               		.cfi_def_cfa_offset 7
 168               		.cfi_offset 11, -6
 169 000a CF92      		push r12
 170               	.LCFI11:
 171               		.cfi_def_cfa_offset 8
 172               		.cfi_offset 12, -7
 173 000c DF92      		push r13
 174               	.LCFI12:
 175               		.cfi_def_cfa_offset 9
 176               		.cfi_offset 13, -8
 177 000e EF92      		push r14
 178               	.LCFI13:
 179               		.cfi_def_cfa_offset 10
 180               		.cfi_offset 14, -9
 181 0010 FF92      		push r15
 182               	.LCFI14:
 183               		.cfi_def_cfa_offset 11
 184               		.cfi_offset 15, -10
 185 0012 0F93      		push r16
 186               	.LCFI15:
 187               		.cfi_def_cfa_offset 12
 188               		.cfi_offset 16, -11
 189 0014 1F93      		push r17
 190               	.LCFI16:
 191               		.cfi_def_cfa_offset 13
 192               		.cfi_offset 17, -12
 193 0016 CF93      		push r28
 194               	.LCFI17:
 195               		.cfi_def_cfa_offset 14
 196               		.cfi_offset 28, -13
 197 0018 DF93      		push r29
 198               	.LCFI18:
 199               		.cfi_def_cfa_offset 15
 200               		.cfi_offset 29, -14
 201               	/* prologue: function */
 202               	/* frame size = 0 */
 203               	/* stack size = 13 */
 204               	.L__stack_usage = 13
 205 001a E82E      		mov r14,r24
 206 001c 992E      		mov r9,r25
 207 001e 862E      		mov r8,r22
 208 0020 772E      		mov r7,r23
 209 0022 042F      		mov r16,r20
 210 0024 F52E      		mov r15,r21
 211 0026 6901      		movw r12,r18
  58:quantum/split_common/transactions.c ****     for (int iter = 1; iter <= num_retries; ++iter) {
 212               		.loc 1 58 5 is_stmt 1 view .LVU24
  58:quantum/split_common/transactions.c ****     for (int iter = 1; iter <= num_retries; ++iter) {
 213               		.loc 1 58 23 is_stmt 0 view .LVU25
 214 0028 0E94 0000 		call is_transport_connected
 215               	.LVL11:
  58:quantum/split_common/transactions.c ****     for (int iter = 1; iter <= num_retries; ++iter) {
 216               		.loc 1 58 53 view .LVU26
 217 002c AA24      		clr r10
 218 002e A394      		inc r10
 219 0030 B12C      		mov r11,__zero_reg__
 220 0032 8823      		tst r24
 221 0034 01F0      		breq .L9
 222 0036 8AE0      		ldi r24,lo8(10)
 223 0038 A82E      		mov r10,r24
 224 003a B12C      		mov r11,__zero_reg__
 225               	.L9:
 226               	.LVL12:
  59:quantum/split_common/transactions.c ****         if (iter > 1) {
 227               		.loc 1 59 5 is_stmt 1 discriminator 4 view .LVU27
 228               	.LBB46:
  59:quantum/split_common/transactions.c ****         if (iter > 1) {
 229               		.loc 1 59 10 discriminator 4 view .LVU28
  59:quantum/split_common/transactions.c ****         if (iter > 1) {
 230               		.loc 1 59 29 discriminator 4 view .LVU29
 231               	.LBB47:
  60:quantum/split_common/transactions.c ****             for (int i = 0; i < iter * iter; ++i) {
 232               		.loc 1 60 9 discriminator 4 view .LVU30
 233               	.LBE47:
  59:quantum/split_common/transactions.c ****         if (iter > 1) {
 234               		.loc 1 59 14 is_stmt 0 discriminator 4 view .LVU31
 235 003c C1E0      		ldi r28,lo8(1)
 236 003e D0E0      		ldi r29,0
 237               	.LVL13:
 238               	.L10:
 239               	.LBB56:
  65:quantum/split_common/transactions.c ****         ATOMIC_BLOCK_FORCEON { this_okay = handler(master_matrix, slave_matrix); };
 240               		.loc 1 65 9 is_stmt 1 view .LVU32
  66:quantum/split_common/transactions.c ****         if (this_okay) return true;
 241               		.loc 1 66 9 view .LVU33
 242               	.LBB48:
  66:quantum/split_common/transactions.c ****         if (this_okay) return true;
 243               		.loc 1 66 9 view .LVU34
 244               	.LBB49:
 245               	.LBI49:
 246               		.file 2 "/usr/avr/include/util/atomic.h"
   1:/usr/avr/include/util/atomic.h **** /* Copyright (c) 2007 Dean Camera
   2:/usr/avr/include/util/atomic.h ****    All rights reserved.
   3:/usr/avr/include/util/atomic.h **** 
   4:/usr/avr/include/util/atomic.h ****    Redistribution and use in source and binary forms, with or without
   5:/usr/avr/include/util/atomic.h ****    modification, are permitted provided that the following conditions are met:
   6:/usr/avr/include/util/atomic.h **** 
   7:/usr/avr/include/util/atomic.h ****    * Redistributions of source code must retain the above copyright
   8:/usr/avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer.
   9:/usr/avr/include/util/atomic.h **** 
  10:/usr/avr/include/util/atomic.h ****    * Redistributions in binary form must reproduce the above copyright
  11:/usr/avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer in
  12:/usr/avr/include/util/atomic.h ****      the documentation and/or other materials provided with the
  13:/usr/avr/include/util/atomic.h ****      distribution.
  14:/usr/avr/include/util/atomic.h **** 
  15:/usr/avr/include/util/atomic.h ****    * Neither the name of the copyright holders nor the names of
  16:/usr/avr/include/util/atomic.h ****      contributors may be used to endorse or promote products derived
  17:/usr/avr/include/util/atomic.h ****      from this software without specific prior written permission.
  18:/usr/avr/include/util/atomic.h **** 
  19:/usr/avr/include/util/atomic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20:/usr/avr/include/util/atomic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21:/usr/avr/include/util/atomic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22:/usr/avr/include/util/atomic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23:/usr/avr/include/util/atomic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24:/usr/avr/include/util/atomic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25:/usr/avr/include/util/atomic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26:/usr/avr/include/util/atomic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27:/usr/avr/include/util/atomic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28:/usr/avr/include/util/atomic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29:/usr/avr/include/util/atomic.h ****   POSSIBILITY OF SUCH DAMAGE.
  30:/usr/avr/include/util/atomic.h **** */
  31:/usr/avr/include/util/atomic.h **** 
  32:/usr/avr/include/util/atomic.h **** /* $Id: atomic.h 2158 2010-06-10 15:48:28Z joerg_wunsch $ */
  33:/usr/avr/include/util/atomic.h **** 
  34:/usr/avr/include/util/atomic.h **** #ifndef _UTIL_ATOMIC_H_
  35:/usr/avr/include/util/atomic.h **** #define _UTIL_ATOMIC_H_ 1
  36:/usr/avr/include/util/atomic.h **** 
  37:/usr/avr/include/util/atomic.h **** #include <avr/io.h>
  38:/usr/avr/include/util/atomic.h **** #include <avr/interrupt.h>
  39:/usr/avr/include/util/atomic.h **** 
  40:/usr/avr/include/util/atomic.h **** #if !defined(__DOXYGEN__)
  41:/usr/avr/include/util/atomic.h **** /* Internal helper functions. */
  42:/usr/avr/include/util/atomic.h **** static __inline__ uint8_t __iSeiRetVal(void)
  43:/usr/avr/include/util/atomic.h **** {
  44:/usr/avr/include/util/atomic.h ****     sei();
  45:/usr/avr/include/util/atomic.h ****     return 1;
  46:/usr/avr/include/util/atomic.h **** }
  47:/usr/avr/include/util/atomic.h **** 
  48:/usr/avr/include/util/atomic.h **** static __inline__ uint8_t __iCliRetVal(void)
 247               		.loc 2 48 27 view .LVU35
 248               	.LBB50:
  49:/usr/avr/include/util/atomic.h **** {
  50:/usr/avr/include/util/atomic.h ****     cli();
 249               		.loc 2 50 5 view .LVU36
 250               	/* #APP */
 251               	 ;  50 "/usr/avr/include/util/atomic.h" 1
 252 0040 F894      		cli
 253               	 ;  0 "" 2
  51:/usr/avr/include/util/atomic.h ****     return 1;
 254               		.loc 2 51 5 view .LVU37
 255               	.LVL14:
 256               		.loc 2 51 5 is_stmt 0 view .LVU38
 257               	/* #NOAPP */
 258               	.LBE50:
 259               	.LBE49:
  66:quantum/split_common/transactions.c ****         if (this_okay) return true;
 260               		.loc 1 66 9 is_stmt 1 view .LVU39
  66:quantum/split_common/transactions.c ****         if (this_okay) return true;
 261               		.loc 1 66 32 view .LVU40
  66:quantum/split_common/transactions.c ****         if (this_okay) return true;
 262               		.loc 1 66 44 is_stmt 0 view .LVU41
 263 0042 682D      		mov r22,r8
 264 0044 772D      		mov r23,r7
 265 0046 8E2D      		mov r24,r14
 266 0048 992D      		mov r25,r9
 267 004a F601      		movw r30,r12
 268 004c 0995      		icall
 269               	.LVL15:
 270 004e 182F      		mov r17,r24
 271               	.LVL16:
  66:quantum/split_common/transactions.c ****         if (this_okay) return true;
 272               		.loc 1 66 9 is_stmt 1 view .LVU42
  66:quantum/split_common/transactions.c ****         if (this_okay) return true;
 273               		.loc 1 66 9 view .LVU43
 274               	.LBB51:
 275               	.LBI51:
  52:/usr/avr/include/util/atomic.h **** }
  53:/usr/avr/include/util/atomic.h **** 
  54:/usr/avr/include/util/atomic.h **** static __inline__ void __iSeiParam(const uint8_t *__s)
 276               		.loc 2 54 24 view .LVU44
 277               	.LBB52:
  55:/usr/avr/include/util/atomic.h **** {
  56:/usr/avr/include/util/atomic.h ****     sei();
 278               		.loc 2 56 5 view .LVU45
 279               	/* #APP */
 280               	 ;  56 "/usr/avr/include/util/atomic.h" 1
 281 0050 7894      		sei
 282               	 ;  0 "" 2
  57:/usr/avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
 283               		.loc 2 57 5 view .LVU46
  58:/usr/avr/include/util/atomic.h ****     (void)__s;
 284               		.loc 2 58 5 view .LVU47
 285               	.LVL17:
 286               		.loc 2 58 5 is_stmt 0 view .LVU48
 287               	/* #NOAPP */
 288               	.LBE52:
 289               	.LBE51:
 290               	.LBE48:
  66:quantum/split_common/transactions.c ****         if (this_okay) return true;
 291               		.loc 1 66 83 is_stmt 1 view .LVU49
  67:quantum/split_common/transactions.c ****     }
 292               		.loc 1 67 9 view .LVU50
  67:quantum/split_common/transactions.c ****     }
 293               		.loc 1 67 12 is_stmt 0 view .LVU51
 294 0052 8111      		cpse r24,__zero_reg__
 295 0054 00C0      		rjmp .L8
 296               	.LBE56:
  59:quantum/split_common/transactions.c ****         if (iter > 1) {
 297               		.loc 1 59 45 is_stmt 1 discriminator 2 view .LVU52
 298 0056 2196      		adiw r28,1
 299               	.LVL18:
  59:quantum/split_common/transactions.c ****         if (iter > 1) {
 300               		.loc 1 59 29 discriminator 2 view .LVU53
 301 0058 AC16      		cp r10,r28
 302 005a BD06      		cpc r11,r29
 303 005c 04F4      		brge .L13
 304               	.LBE46:
  69:quantum/split_common/transactions.c ****     return false;
 305               		.loc 1 69 5 view .LVU54
  69:quantum/split_common/transactions.c ****     return false;
 306               		.loc 1 69 5 view .LVU55
 307 005e 8091 0000 		lds r24,debug_config
 308 0062 80FF      		sbrs r24,0
 309 0064 00C0      		rjmp .L8
  69:quantum/split_common/transactions.c ****     return false;
 310               		.loc 1 69 5 discriminator 1 view .LVU56
 311               	.LBB58:
  69:quantum/split_common/transactions.c ****     return false;
 312               		.loc 1 69 5 discriminator 1 view .LVU57
  69:quantum/split_common/transactions.c ****     return false;
 313               		.loc 1 69 5 discriminator 1 view .LVU58
 314               	.LBE58:
 315 0066 FF92      		push r15
 316               	.LCFI19:
 317               		.cfi_def_cfa_offset 16
 318 0068 0F93      		push r16
 319               	.LCFI20:
 320               		.cfi_def_cfa_offset 17
 321 006a 80E0      		ldi r24,lo8(__c.1)
 322 006c 90E0      		ldi r25,hi8(__c.1)
 323 006e 9F93      		push r25
 324               	.LCFI21:
 325               		.cfi_def_cfa_offset 18
 326 0070 8F93      		push r24
 327               	.LCFI22:
 328               		.cfi_def_cfa_offset 19
 329 0072 0E94 0000 		call __xprintf
 330               	.LVL19:
 331 0076 0F90      		pop __tmp_reg__
 332 0078 0F90      		pop __tmp_reg__
 333 007a 0F90      		pop __tmp_reg__
 334 007c 0F90      		pop __tmp_reg__
 335               	.LCFI23:
 336               		.cfi_def_cfa_offset 15
 337               	.LVL20:
 338               	.L8:
  71:quantum/split_common/transactions.c **** 
 339               		.loc 1 71 1 is_stmt 0 view .LVU59
 340 007e 812F      		mov r24,r17
 341               	/* epilogue start */
 342 0080 DF91      		pop r29
 343 0082 CF91      		pop r28
 344 0084 1F91      		pop r17
 345               	.LVL21:
  71:quantum/split_common/transactions.c **** 
 346               		.loc 1 71 1 view .LVU60
 347 0086 0F91      		pop r16
 348 0088 FF90      		pop r15
 349 008a EF90      		pop r14
 350 008c DF90      		pop r13
 351 008e CF90      		pop r12
 352               	.LVL22:
  71:quantum/split_common/transactions.c **** 
 353               		.loc 1 71 1 view .LVU61
 354 0090 BF90      		pop r11
 355 0092 AF90      		pop r10
 356               	.LVL23:
  71:quantum/split_common/transactions.c **** 
 357               		.loc 1 71 1 view .LVU62
 358 0094 9F90      		pop r9
 359 0096 8F90      		pop r8
 360 0098 7F90      		pop r7
 361 009a 0895      		ret
 362               	.LVL24:
 363               	.L13:
 364               	.LBB59:
 365               	.LBB57:
 366               	.LBB53:
  61:quantum/split_common/transactions.c ****                 wait_us(10);
 367               		.loc 1 61 38 view .LVU63
 368 009c CC9F      		mul r28,r28
 369 009e 9001      		movw r18,r0
 370 00a0 CD9F      		mul r28,r29
 371 00a2 300D      		add r19,r0
 372 00a4 300D      		add r19,r0
 373 00a6 1124      		clr r1
  61:quantum/split_common/transactions.c ****                 wait_us(10);
 374               		.loc 1 61 22 view .LVU64
 375 00a8 90E0      		ldi r25,0
 376 00aa 80E0      		ldi r24,0
 377               	.LVL25:
 378               	.L11:
  62:quantum/split_common/transactions.c ****             }
 379               		.loc 1 62 17 is_stmt 1 view .LVU65
  62:quantum/split_common/transactions.c ****             }
 380               		.loc 1 62 17 view .LVU66
  62:quantum/split_common/transactions.c ****             }
 381               		.loc 1 62 17 view .LVU67
 382               	.LBB54:
 383               	.LBI54:
 384               		.file 3 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/avr/include/util/delay.h **** 
 189:/usr/avr/include/util/delay.h **** #else
 190:/usr/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/avr/include/util/delay.h **** 	{
 196:/usr/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/avr/include/util/delay.h **** 		{
 200:/usr/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/avr/include/util/delay.h **** 		}
 204:/usr/avr/include/util/delay.h **** 		return;
 205:/usr/avr/include/util/delay.h **** 	}
 206:/usr/avr/include/util/delay.h **** 	else
 207:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/avr/include/util/delay.h **** #endif
 210:/usr/avr/include/util/delay.h **** }
 211:/usr/avr/include/util/delay.h **** 
 212:/usr/avr/include/util/delay.h **** /**
 213:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/avr/include/util/delay.h **** 
 215:/usr/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/avr/include/util/delay.h **** 
 217:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/avr/include/util/delay.h **** 
 220:/usr/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/avr/include/util/delay.h **** 
 222:/usr/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/avr/include/util/delay.h **** 
 226:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/avr/include/util/delay.h **** 
 231:/usr/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/avr/include/util/delay.h **** 
 236:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/avr/include/util/delay.h ****    respectively.
 240:/usr/avr/include/util/delay.h **** 
 241:/usr/avr/include/util/delay.h ****    \note
 242:/usr/avr/include/util/delay.h **** 
 243:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/avr/include/util/delay.h **** 
 253:/usr/avr/include/util/delay.h ****  */
 254:/usr/avr/include/util/delay.h **** void
 255:/usr/avr/include/util/delay.h **** _delay_us(double __us)
 385               		.loc 3 255 1 view .LVU68
 386               	.LBB55:
 256:/usr/avr/include/util/delay.h **** {
 257:/usr/avr/include/util/delay.h **** 	double __tmp ;
 387               		.loc 3 257 2 view .LVU69
 258:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 388               		.loc 3 261 2 view .LVU70
 262:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 389               		.loc 3 262 2 view .LVU71
 263:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 390               		.loc 3 263 2 view .LVU72
 264:/usr/avr/include/util/delay.h **** 
 265:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/avr/include/util/delay.h **** 
 268:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/avr/include/util/delay.h **** 
 271:/usr/avr/include/util/delay.h **** 	#else
 272:/usr/avr/include/util/delay.h **** 		//round up by default
 273:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 391               		.loc 3 273 3 view .LVU73
 274:/usr/avr/include/util/delay.h **** 	#endif
 275:/usr/avr/include/util/delay.h **** 
 276:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 392               		.loc 3 276 2 view .LVU74
 393 00ac 45E3      		ldi r20,lo8(53)
 394 00ae 4A95      	1:	dec r20
 395 00b0 01F4      		brne 1b
 396 00b2 0000      		nop
 397               	.LVL26:
 398               		.loc 3 276 2 is_stmt 0 view .LVU75
 399               	.LBE55:
 400               	.LBE54:
  62:quantum/split_common/transactions.c ****             }
 401               		.loc 1 62 17 is_stmt 1 view .LVU76
  61:quantum/split_common/transactions.c ****                 wait_us(10);
 402               		.loc 1 61 46 view .LVU77
 403 00b4 0196      		adiw r24,1
 404               	.LVL27:
  61:quantum/split_common/transactions.c ****                 wait_us(10);
 405               		.loc 1 61 31 view .LVU78
 406 00b6 2817      		cp r18,r24
 407 00b8 3907      		cpc r19,r25
 408 00ba 01F4      		brne .L11
 409 00bc 00C0      		rjmp .L10
 410               	.LBE53:
 411               	.LBE57:
 412               	.LBE59:
 413               		.cfi_endproc
 414               	.LFE27:
 416               		.section	.text.send_if_condition,"ax",@progbits
 418               	send_if_condition:
 419               	.LVL28:
 420               	.LFB29:
  98:quantum/split_common/transactions.c ****     bool okay = true;
 421               		.loc 1 98 123 view -0
 422               		.cfi_startproc
  98:quantum/split_common/transactions.c ****     bool okay = true;
 423               		.loc 1 98 123 is_stmt 0 view .LVU80
 424 0000 AF92      		push r10
 425               	.LCFI24:
 426               		.cfi_def_cfa_offset 3
 427               		.cfi_offset 10, -2
 428 0002 BF92      		push r11
 429               	.LCFI25:
 430               		.cfi_def_cfa_offset 4
 431               		.cfi_offset 11, -3
 432 0004 CF92      		push r12
 433               	.LCFI26:
 434               		.cfi_def_cfa_offset 5
 435               		.cfi_offset 12, -4
 436 0006 DF92      		push r13
 437               	.LCFI27:
 438               		.cfi_def_cfa_offset 6
 439               		.cfi_offset 13, -5
 440 0008 EF92      		push r14
 441               	.LCFI28:
 442               		.cfi_def_cfa_offset 7
 443               		.cfi_offset 14, -6
 444 000a FF92      		push r15
 445               	.LCFI29:
 446               		.cfi_def_cfa_offset 8
 447               		.cfi_offset 15, -7
 448 000c 0F93      		push r16
 449               	.LCFI30:
 450               		.cfi_def_cfa_offset 9
 451               		.cfi_offset 16, -8
 452 000e 1F93      		push r17
 453               	.LCFI31:
 454               		.cfi_def_cfa_offset 10
 455               		.cfi_offset 17, -9
 456 0010 CF93      		push r28
 457               	.LCFI32:
 458               		.cfi_def_cfa_offset 11
 459               		.cfi_offset 28, -10
 460 0012 DF93      		push r29
 461               	.LCFI33:
 462               		.cfi_def_cfa_offset 12
 463               		.cfi_offset 29, -11
 464 0014 00D0      		rcall .
 465 0016 00D0      		rcall .
 466 0018 00D0      		rcall .
 467               	.LCFI34:
 468               		.cfi_def_cfa_offset 18
 469 001a CDB7      		in r28,__SP_L__
 470 001c DEB7      		in r29,__SP_H__
 471               	.LCFI35:
 472               		.cfi_def_cfa_register 28
 473               	/* prologue: function */
 474               	/* frame size = 6 */
 475               	/* stack size = 16 */
 476               	.L__stack_usage = 16
 477 001e 8D83      		std Y+5,r24
 478 0020 7B01      		movw r14,r22
 479 0022 A42E      		mov r10,r20
 480 0024 D22E      		mov r13,r18
 481 0026 3E83      		std Y+6,r19
 482 0028 B02E      		mov r11,r16
 483 002a C12E      		mov r12,r17
  99:quantum/split_common/transactions.c ****     if (timer_elapsed32(*last_update) >= FORCED_SYNC_THROTTLE_MS || condition) {
 484               		.loc 1 99 5 is_stmt 1 view .LVU81
 485               	.LVL29:
 100:quantum/split_common/transactions.c ****         okay &= transport_write(trans_id, source, length);
 486               		.loc 1 100 5 view .LVU82
 100:quantum/split_common/transactions.c ****         okay &= transport_write(trans_id, source, length);
 487               		.loc 1 100 9 is_stmt 0 view .LVU83
 488 002c DB01      		movw r26,r22
 489 002e 8D91      		ld r24,X+
 490 0030 9D91      		ld r25,X+
 491 0032 0D90      		ld __tmp_reg__,X+
 492 0034 BC91      		ld r27,X
 493 0036 A02D      		mov r26,__tmp_reg__
 494               	.LVL30:
 100:quantum/split_common/transactions.c ****         okay &= transport_write(trans_id, source, length);
 495               		.loc 1 100 9 view .LVU84
 496 0038 BC01      		movw r22,r24
 497               	.LVL31:
 100:quantum/split_common/transactions.c ****         okay &= transport_write(trans_id, source, length);
 498               		.loc 1 100 9 view .LVU85
 499 003a CD01      		movw r24,r26
 500 003c 0E94 0000 		call timer_elapsed32
 501               	.LVL32:
 100:quantum/split_common/transactions.c ****         okay &= transport_write(trans_id, source, length);
 502               		.loc 1 100 8 view .LVU86
 503 0040 6436      		cpi r22,100
 504 0042 7105      		cpc r23,__zero_reg__
 505 0044 8105      		cpc r24,__zero_reg__
 506 0046 9105      		cpc r25,__zero_reg__
 507 0048 00F4      		brsh .L20
 100:quantum/split_common/transactions.c ****         okay &= transport_write(trans_id, source, length);
 508               		.loc 1 100 66 discriminator 1 view .LVU87
 509 004a AA20      		tst r10
 510 004c 01F0      		breq .L22
 511               	.L20:
 101:quantum/split_common/transactions.c ****         if (okay) {
 512               		.loc 1 101 9 is_stmt 1 view .LVU88
 101:quantum/split_common/transactions.c ****         if (okay) {
 513               		.loc 1 101 17 is_stmt 0 view .LVU89
 514 004e 10E0      		ldi r17,0
 515 0050 00E0      		ldi r16,0
 516               	.LVL33:
 101:quantum/split_common/transactions.c ****         if (okay) {
 517               		.loc 1 101 17 view .LVU90
 518 0052 30E0      		ldi r19,0
 519 0054 20E0      		ldi r18,0
 520 0056 4B2D      		mov r20,r11
 521 0058 5C2D      		mov r21,r12
 522 005a 6D2D      		mov r22,r13
 523 005c 7E81      		ldd r23,Y+6
 524 005e 8D81      		ldd r24,Y+5
 525 0060 0E94 0000 		call transport_execute_transaction
 526               	.LVL34:
 527 0064 8983      		std Y+1,r24
 528               	.LVL35:
 102:quantum/split_common/transactions.c ****             *last_update = timer_read32();
 529               		.loc 1 102 9 is_stmt 1 view .LVU91
 102:quantum/split_common/transactions.c ****             *last_update = timer_read32();
 530               		.loc 1 102 12 is_stmt 0 view .LVU92
 531 0066 8823      		tst r24
 532 0068 01F0      		breq .L19
 533               	.LVL36:
 534               	.LBB62:
 535               	.LBI62:
  98:quantum/split_common/transactions.c ****     bool okay = true;
 536               		.loc 1 98 20 is_stmt 1 view .LVU93
 537               	.LBB63:
 103:quantum/split_common/transactions.c ****         }
 538               		.loc 1 103 13 view .LVU94
 103:quantum/split_common/transactions.c ****         }
 539               		.loc 1 103 28 is_stmt 0 view .LVU95
 540 006a 0E94 0000 		call timer_read32
 541               	.LVL37:
 103:quantum/split_common/transactions.c ****         }
 542               		.loc 1 103 28 view .LVU96
 543 006e F701      		movw r30,r14
 544 0070 6083      		st Z,r22
 545 0072 7183      		std Z+1,r23
 546 0074 8283      		std Z+2,r24
 547 0076 9383      		std Z+3,r25
 548               	.LVL38:
 106:quantum/split_common/transactions.c **** }
 549               		.loc 1 106 5 is_stmt 1 view .LVU97
 550               	.L19:
 106:quantum/split_common/transactions.c **** }
 551               		.loc 1 106 5 is_stmt 0 view .LVU98
 552               	.LBE63:
 553               	.LBE62:
 107:quantum/split_common/transactions.c **** 
 554               		.loc 1 107 1 view .LVU99
 555 0078 8981      		ldd r24,Y+1
 556               	/* epilogue start */
 557 007a 2696      		adiw r28,6
 558 007c 0FB6      		in __tmp_reg__,__SREG__
 559 007e F894      		cli
 560 0080 DEBF      		out __SP_H__,r29
 561 0082 0FBE      		out __SREG__,__tmp_reg__
 562 0084 CDBF      		out __SP_L__,r28
 563 0086 DF91      		pop r29
 564 0088 CF91      		pop r28
 565 008a 1F91      		pop r17
 566 008c 0F91      		pop r16
 567 008e FF90      		pop r15
 568 0090 EF90      		pop r14
 569               	.LVL39:
 107:quantum/split_common/transactions.c **** 
 570               		.loc 1 107 1 view .LVU100
 571 0092 DF90      		pop r13
 572 0094 CF90      		pop r12
 573 0096 BF90      		pop r11
 574 0098 AF90      		pop r10
 575               	.LVL40:
 107:quantum/split_common/transactions.c **** 
 576               		.loc 1 107 1 view .LVU101
 577 009a 0895      		ret
 578               	.LVL41:
 579               	.L22:
  99:quantum/split_common/transactions.c ****     if (timer_elapsed32(*last_update) >= FORCED_SYNC_THROTTLE_MS || condition) {
 580               		.loc 1 99 10 view .LVU102
 581 009c F1E0      		ldi r31,lo8(1)
 582 009e F983      		std Y+1,r31
 106:quantum/split_common/transactions.c **** }
 583               		.loc 1 106 5 is_stmt 1 view .LVU103
 106:quantum/split_common/transactions.c **** }
 584               		.loc 1 106 12 is_stmt 0 view .LVU104
 585 00a0 00C0      		rjmp .L19
 586               		.cfi_endproc
 587               	.LFE29:
 589               		.section	.text.oled_handlers_master,"ax",@progbits
 591               	oled_handlers_master:
 592               	.LVL42:
 593               	.LFB39:
 229:quantum/split_common/transactions.c **** 
 230:quantum/split_common/transactions.c **** static void sync_timer_handlers_slave(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 231:quantum/split_common/transactions.c ****     static uint32_t last_sync_timer = 0;
 232:quantum/split_common/transactions.c ****     if (last_sync_timer != split_shmem->sync_timer) {
 233:quantum/split_common/transactions.c ****         last_sync_timer = split_shmem->sync_timer;
 234:quantum/split_common/transactions.c ****         sync_timer_update(last_sync_timer);
 235:quantum/split_common/transactions.c ****     }
 236:quantum/split_common/transactions.c **** }
 237:quantum/split_common/transactions.c **** 
 238:quantum/split_common/transactions.c **** #    define TRANSACTIONS_SYNC_TIMER_MASTER()      TRANSACTION_HANDLER_MASTER(sync_timer)
 239:quantum/split_common/transactions.c **** #    define TRANSACTIONS_SYNC_TIMER_SLAVE()       TRANSACTION_HANDLER_SLAVE(sync_timer)
 240:quantum/split_common/transactions.c **** #    define TRANSACTIONS_SYNC_TIMER_REGISTRATIONS [PUT_SYNC_TIMER] = trans_initiator2target_initial
 241:quantum/split_common/transactions.c **** 
 242:quantum/split_common/transactions.c **** #else  // DISABLE_SYNC_TIMER
 243:quantum/split_common/transactions.c **** 
 244:quantum/split_common/transactions.c **** #    define TRANSACTIONS_SYNC_TIMER_MASTER()
 245:quantum/split_common/transactions.c **** #    define TRANSACTIONS_SYNC_TIMER_SLAVE()
 246:quantum/split_common/transactions.c **** #    define TRANSACTIONS_SYNC_TIMER_REGISTRATIONS
 247:quantum/split_common/transactions.c **** 
 248:quantum/split_common/transactions.c **** #endif  // DISABLE_SYNC_TIMER
 249:quantum/split_common/transactions.c **** 
 250:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
 251:quantum/split_common/transactions.c **** // Layer state
 252:quantum/split_common/transactions.c **** 
 253:quantum/split_common/transactions.c **** #if !defined(NO_ACTION_LAYER) && defined(SPLIT_LAYER_STATE_ENABLE)
 254:quantum/split_common/transactions.c **** 
 255:quantum/split_common/transactions.c **** static bool layer_state_handlers_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) 
 256:quantum/split_common/transactions.c ****     static uint32_t last_layer_state_update         = 0;
 257:quantum/split_common/transactions.c ****     static uint32_t last_default_layer_state_update = 0;
 258:quantum/split_common/transactions.c **** 
 259:quantum/split_common/transactions.c ****     bool okay = send_if_condition(PUT_LAYER_STATE, &last_layer_state_update, (layer_state != split_
 260:quantum/split_common/transactions.c ****     if (okay) {
 261:quantum/split_common/transactions.c ****         okay &= send_if_condition(PUT_DEFAULT_LAYER_STATE, &last_default_layer_state_update, (defau
 262:quantum/split_common/transactions.c ****     }
 263:quantum/split_common/transactions.c ****     return okay;
 264:quantum/split_common/transactions.c **** }
 265:quantum/split_common/transactions.c **** 
 266:quantum/split_common/transactions.c **** static void layer_state_handlers_slave(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 267:quantum/split_common/transactions.c ****     layer_state         = split_shmem->layers.layer_state;
 268:quantum/split_common/transactions.c ****     default_layer_state = split_shmem->layers.default_layer_state;
 269:quantum/split_common/transactions.c **** }
 270:quantum/split_common/transactions.c **** 
 271:quantum/split_common/transactions.c **** // clang-format off
 272:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LAYER_STATE_MASTER() TRANSACTION_HANDLER_MASTER(layer_state)
 273:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LAYER_STATE_SLAVE() TRANSACTION_HANDLER_SLAVE(layer_state)
 274:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LAYER_STATE_REGISTRATIONS \
 275:quantum/split_common/transactions.c ****     [PUT_LAYER_STATE]         = trans_initiator2target_initializer(layers.layer_state), \
 276:quantum/split_common/transactions.c ****     [PUT_DEFAULT_LAYER_STATE] = trans_initiator2target_initializer(layers.default_layer_state),
 277:quantum/split_common/transactions.c **** // clang-format on
 278:quantum/split_common/transactions.c **** 
 279:quantum/split_common/transactions.c **** #else  // !defined(NO_ACTION_LAYER) && defined(SPLIT_LAYER_STATE_ENABLE)
 280:quantum/split_common/transactions.c **** 
 281:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LAYER_STATE_MASTER()
 282:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LAYER_STATE_SLAVE()
 283:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LAYER_STATE_REGISTRATIONS
 284:quantum/split_common/transactions.c **** 
 285:quantum/split_common/transactions.c **** #endif  // !defined(NO_ACTION_LAYER) && defined(SPLIT_LAYER_STATE_ENABLE)
 286:quantum/split_common/transactions.c **** 
 287:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
 288:quantum/split_common/transactions.c **** // LED state
 289:quantum/split_common/transactions.c **** 
 290:quantum/split_common/transactions.c **** #ifdef SPLIT_LED_STATE_ENABLE
 291:quantum/split_common/transactions.c **** 
 292:quantum/split_common/transactions.c **** static bool led_state_handlers_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 293:quantum/split_common/transactions.c ****     static uint32_t last_update = 0;
 294:quantum/split_common/transactions.c ****     uint8_t         led_state   = host_keyboard_leds();
 295:quantum/split_common/transactions.c ****     return send_if_data_mismatch(PUT_LED_STATE, &last_update, &led_state, &split_shmem->led_state, 
 296:quantum/split_common/transactions.c **** }
 297:quantum/split_common/transactions.c **** 
 298:quantum/split_common/transactions.c **** static void led_state_handlers_slave(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 299:quantum/split_common/transactions.c ****     void set_split_host_keyboard_leds(uint8_t led_state);
 300:quantum/split_common/transactions.c ****     set_split_host_keyboard_leds(split_shmem->led_state);
 301:quantum/split_common/transactions.c **** }
 302:quantum/split_common/transactions.c **** 
 303:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LED_STATE_MASTER()      TRANSACTION_HANDLER_MASTER(led_state)
 304:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LED_STATE_SLAVE()       TRANSACTION_HANDLER_SLAVE(led_state)
 305:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LED_STATE_REGISTRATIONS [PUT_LED_STATE] = trans_initiator2target_initializ
 306:quantum/split_common/transactions.c **** 
 307:quantum/split_common/transactions.c **** #else  // SPLIT_LED_STATE_ENABLE
 308:quantum/split_common/transactions.c **** 
 309:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LED_STATE_MASTER()
 310:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LED_STATE_SLAVE()
 311:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LED_STATE_REGISTRATIONS
 312:quantum/split_common/transactions.c **** 
 313:quantum/split_common/transactions.c **** #endif  // SPLIT_LED_STATE_ENABLE
 314:quantum/split_common/transactions.c **** 
 315:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
 316:quantum/split_common/transactions.c **** // Mods
 317:quantum/split_common/transactions.c **** 
 318:quantum/split_common/transactions.c **** #ifdef SPLIT_MODS_ENABLE
 319:quantum/split_common/transactions.c **** 
 320:quantum/split_common/transactions.c **** static bool mods_handlers_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 321:quantum/split_common/transactions.c ****     static uint32_t   last_update    = 0;
 322:quantum/split_common/transactions.c ****     bool              mods_need_sync = timer_elapsed32(last_update) >= FORCED_SYNC_THROTTLE_MS;
 323:quantum/split_common/transactions.c ****     split_mods_sync_t new_mods;
 324:quantum/split_common/transactions.c ****     new_mods.real_mods = get_mods();
 325:quantum/split_common/transactions.c ****     if (!mods_need_sync && new_mods.real_mods != split_shmem->mods.real_mods) {
 326:quantum/split_common/transactions.c ****         mods_need_sync = true;
 327:quantum/split_common/transactions.c ****     }
 328:quantum/split_common/transactions.c **** 
 329:quantum/split_common/transactions.c ****     new_mods.weak_mods = get_weak_mods();
 330:quantum/split_common/transactions.c ****     if (!mods_need_sync && new_mods.weak_mods != split_shmem->mods.weak_mods) {
 331:quantum/split_common/transactions.c ****         mods_need_sync = true;
 332:quantum/split_common/transactions.c ****     }
 333:quantum/split_common/transactions.c **** 
 334:quantum/split_common/transactions.c **** #    ifndef NO_ACTION_ONESHOT
 335:quantum/split_common/transactions.c ****     new_mods.oneshot_mods = get_oneshot_mods();
 336:quantum/split_common/transactions.c ****     if (!mods_need_sync && new_mods.oneshot_mods != split_shmem->mods.oneshot_mods) {
 337:quantum/split_common/transactions.c ****         mods_need_sync = true;
 338:quantum/split_common/transactions.c ****     }
 339:quantum/split_common/transactions.c **** #    endif  // NO_ACTION_ONESHOT
 340:quantum/split_common/transactions.c **** 
 341:quantum/split_common/transactions.c ****     bool okay = true;
 342:quantum/split_common/transactions.c ****     if (mods_need_sync) {
 343:quantum/split_common/transactions.c ****         okay &= transport_write(PUT_MODS, &new_mods, sizeof(new_mods));
 344:quantum/split_common/transactions.c ****         if (okay) {
 345:quantum/split_common/transactions.c ****             last_update = timer_read32();
 346:quantum/split_common/transactions.c ****         }
 347:quantum/split_common/transactions.c ****     }
 348:quantum/split_common/transactions.c **** 
 349:quantum/split_common/transactions.c ****     return okay;
 350:quantum/split_common/transactions.c **** }
 351:quantum/split_common/transactions.c **** 
 352:quantum/split_common/transactions.c **** static void mods_handlers_slave(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 353:quantum/split_common/transactions.c ****     set_mods(split_shmem->mods.real_mods);
 354:quantum/split_common/transactions.c ****     set_weak_mods(split_shmem->mods.weak_mods);
 355:quantum/split_common/transactions.c **** #    ifndef NO_ACTION_ONESHOT
 356:quantum/split_common/transactions.c ****     set_oneshot_mods(split_shmem->mods.oneshot_mods);
 357:quantum/split_common/transactions.c **** #    endif
 358:quantum/split_common/transactions.c **** }
 359:quantum/split_common/transactions.c **** 
 360:quantum/split_common/transactions.c **** #    define TRANSACTIONS_MODS_MASTER()      TRANSACTION_HANDLER_MASTER(mods)
 361:quantum/split_common/transactions.c **** #    define TRANSACTIONS_MODS_SLAVE()       TRANSACTION_HANDLER_SLAVE(mods)
 362:quantum/split_common/transactions.c **** #    define TRANSACTIONS_MODS_REGISTRATIONS [PUT_MODS] = trans_initiator2target_initializer(mods),
 363:quantum/split_common/transactions.c **** 
 364:quantum/split_common/transactions.c **** #else  // SPLIT_MODS_ENABLE
 365:quantum/split_common/transactions.c **** 
 366:quantum/split_common/transactions.c **** #    define TRANSACTIONS_MODS_MASTER()
 367:quantum/split_common/transactions.c **** #    define TRANSACTIONS_MODS_SLAVE()
 368:quantum/split_common/transactions.c **** #    define TRANSACTIONS_MODS_REGISTRATIONS
 369:quantum/split_common/transactions.c **** 
 370:quantum/split_common/transactions.c **** #endif  // SPLIT_MODS_ENABLE
 371:quantum/split_common/transactions.c **** 
 372:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
 373:quantum/split_common/transactions.c **** // Backlight
 374:quantum/split_common/transactions.c **** 
 375:quantum/split_common/transactions.c **** #ifdef BACKLIGHT_ENABLE
 376:quantum/split_common/transactions.c **** 
 377:quantum/split_common/transactions.c **** static bool backlight_handlers_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 378:quantum/split_common/transactions.c ****     static uint32_t last_update = 0;
 379:quantum/split_common/transactions.c ****     uint8_t         level       = is_backlight_enabled() ? get_backlight_level() : 0;
 380:quantum/split_common/transactions.c ****     return send_if_condition(PUT_BACKLIGHT, &last_update, (level != split_shmem->backlight_level), 
 381:quantum/split_common/transactions.c **** }
 382:quantum/split_common/transactions.c **** 
 383:quantum/split_common/transactions.c **** static void backlight_handlers_slave(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) { b
 384:quantum/split_common/transactions.c **** 
 385:quantum/split_common/transactions.c **** #    define TRANSACTIONS_BACKLIGHT_MASTER()      TRANSACTION_HANDLER_MASTER(backlight)
 386:quantum/split_common/transactions.c **** #    define TRANSACTIONS_BACKLIGHT_SLAVE()       TRANSACTION_HANDLER_SLAVE(backlight)
 387:quantum/split_common/transactions.c **** #    define TRANSACTIONS_BACKLIGHT_REGISTRATIONS [PUT_BACKLIGHT] = trans_initiator2target_initializ
 388:quantum/split_common/transactions.c **** 
 389:quantum/split_common/transactions.c **** #else  // BACKLIGHT_ENABLE
 390:quantum/split_common/transactions.c **** 
 391:quantum/split_common/transactions.c **** #    define TRANSACTIONS_BACKLIGHT_MASTER()
 392:quantum/split_common/transactions.c **** #    define TRANSACTIONS_BACKLIGHT_SLAVE()
 393:quantum/split_common/transactions.c **** #    define TRANSACTIONS_BACKLIGHT_REGISTRATIONS
 394:quantum/split_common/transactions.c **** 
 395:quantum/split_common/transactions.c **** #endif  // BACKLIGHT_ENABLE
 396:quantum/split_common/transactions.c **** 
 397:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
 398:quantum/split_common/transactions.c **** // RGBLIGHT
 399:quantum/split_common/transactions.c **** 
 400:quantum/split_common/transactions.c **** #if defined(RGBLIGHT_ENABLE) && defined(RGBLIGHT_SPLIT)
 401:quantum/split_common/transactions.c **** 
 402:quantum/split_common/transactions.c **** static bool rgblight_handlers_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 403:quantum/split_common/transactions.c ****     static uint32_t     last_update = 0;
 404:quantum/split_common/transactions.c ****     rgblight_syncinfo_t rgblight_sync;
 405:quantum/split_common/transactions.c ****     rgblight_get_syncinfo(&rgblight_sync);
 406:quantum/split_common/transactions.c ****     if (send_if_condition(PUT_RGBLIGHT, &last_update, (rgblight_sync.status.change_flags != 0), &rg
 407:quantum/split_common/transactions.c ****         rgblight_clear_change_flags();
 408:quantum/split_common/transactions.c ****     } else {
 409:quantum/split_common/transactions.c ****         return false;
 410:quantum/split_common/transactions.c ****     }
 411:quantum/split_common/transactions.c ****     return true;
 412:quantum/split_common/transactions.c **** }
 413:quantum/split_common/transactions.c **** 
 414:quantum/split_common/transactions.c **** static void rgblight_handlers_slave(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 415:quantum/split_common/transactions.c ****     // Update the RGB with the new data
 416:quantum/split_common/transactions.c ****     if (split_shmem->rgblight_sync.status.change_flags != 0) {
 417:quantum/split_common/transactions.c ****         rgblight_update_sync(&split_shmem->rgblight_sync, false);
 418:quantum/split_common/transactions.c ****         split_shmem->rgblight_sync.status.change_flags = 0;
 419:quantum/split_common/transactions.c ****     }
 420:quantum/split_common/transactions.c **** }
 421:quantum/split_common/transactions.c **** 
 422:quantum/split_common/transactions.c **** #    define TRANSACTIONS_RGBLIGHT_MASTER()      TRANSACTION_HANDLER_MASTER(rgblight)
 423:quantum/split_common/transactions.c **** #    define TRANSACTIONS_RGBLIGHT_SLAVE()       TRANSACTION_HANDLER_SLAVE(rgblight)
 424:quantum/split_common/transactions.c **** #    define TRANSACTIONS_RGBLIGHT_REGISTRATIONS [PUT_RGBLIGHT] = trans_initiator2target_initializer
 425:quantum/split_common/transactions.c **** 
 426:quantum/split_common/transactions.c **** #else  // defined(RGBLIGHT_ENABLE) && defined(RGBLIGHT_SPLIT)
 427:quantum/split_common/transactions.c **** 
 428:quantum/split_common/transactions.c **** #    define TRANSACTIONS_RGBLIGHT_MASTER()
 429:quantum/split_common/transactions.c **** #    define TRANSACTIONS_RGBLIGHT_SLAVE()
 430:quantum/split_common/transactions.c **** #    define TRANSACTIONS_RGBLIGHT_REGISTRATIONS
 431:quantum/split_common/transactions.c **** 
 432:quantum/split_common/transactions.c **** #endif  // defined(RGBLIGHT_ENABLE) && defined(RGBLIGHT_SPLIT)
 433:quantum/split_common/transactions.c **** 
 434:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
 435:quantum/split_common/transactions.c **** // LED Matrix
 436:quantum/split_common/transactions.c **** 
 437:quantum/split_common/transactions.c **** #if defined(LED_MATRIX_ENABLE) && defined(LED_MATRIX_SPLIT)
 438:quantum/split_common/transactions.c **** 
 439:quantum/split_common/transactions.c **** static bool led_matrix_handlers_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 440:quantum/split_common/transactions.c ****     static uint32_t   last_update = 0;
 441:quantum/split_common/transactions.c ****     led_matrix_sync_t led_matrix_sync;
 442:quantum/split_common/transactions.c ****     memcpy(&led_matrix_sync.led_matrix, &led_matrix_eeconfig, sizeof(led_eeconfig_t));
 443:quantum/split_common/transactions.c ****     led_matrix_sync.led_suspend_state = led_matrix_get_suspend_state();
 444:quantum/split_common/transactions.c ****     return send_if_data_mismatch(PUT_LED_MATRIX, &last_update, &led_matrix_sync, &split_shmem->led_
 445:quantum/split_common/transactions.c **** }
 446:quantum/split_common/transactions.c **** 
 447:quantum/split_common/transactions.c **** static void led_matrix_handlers_slave(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 448:quantum/split_common/transactions.c ****     memcpy(&led_matrix_eeconfig, &split_shmem->led_matrix_sync.led_matrix, sizeof(led_eeconfig_t));
 449:quantum/split_common/transactions.c ****     led_matrix_set_suspend_state(split_shmem->led_matrix_sync.led_suspend_state);
 450:quantum/split_common/transactions.c **** }
 451:quantum/split_common/transactions.c **** 
 452:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LED_MATRIX_MASTER()      TRANSACTION_HANDLER_MASTER(led_matrix)
 453:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LED_MATRIX_SLAVE()       TRANSACTION_HANDLER_SLAVE(led_matrix)
 454:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LED_MATRIX_REGISTRATIONS [PUT_LED_MATRIX] = trans_initiator2target_initial
 455:quantum/split_common/transactions.c **** 
 456:quantum/split_common/transactions.c **** #else  // defined(LED_MATRIX_ENABLE) && defined(LED_MATRIX_SPLIT)
 457:quantum/split_common/transactions.c **** 
 458:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LED_MATRIX_MASTER()
 459:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LED_MATRIX_SLAVE()
 460:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LED_MATRIX_REGISTRATIONS
 461:quantum/split_common/transactions.c **** 
 462:quantum/split_common/transactions.c **** #endif  // defined(LED_MATRIX_ENABLE) && defined(LED_MATRIX_SPLIT)
 463:quantum/split_common/transactions.c **** 
 464:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
 465:quantum/split_common/transactions.c **** // RGB Matrix
 466:quantum/split_common/transactions.c **** 
 467:quantum/split_common/transactions.c **** #if defined(RGB_MATRIX_ENABLE) && defined(RGB_MATRIX_SPLIT)
 468:quantum/split_common/transactions.c **** 
 469:quantum/split_common/transactions.c **** static bool rgb_matrix_handlers_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 470:quantum/split_common/transactions.c ****     static uint32_t   last_update = 0;
 471:quantum/split_common/transactions.c ****     rgb_matrix_sync_t rgb_matrix_sync;
 472:quantum/split_common/transactions.c ****     memcpy(&rgb_matrix_sync.rgb_matrix, &rgb_matrix_config, sizeof(rgb_config_t));
 473:quantum/split_common/transactions.c ****     rgb_matrix_sync.rgb_suspend_state = rgb_matrix_get_suspend_state();
 474:quantum/split_common/transactions.c ****     return send_if_data_mismatch(PUT_RGB_MATRIX, &last_update, &rgb_matrix_sync, &split_shmem->rgb_
 475:quantum/split_common/transactions.c **** }
 476:quantum/split_common/transactions.c **** 
 477:quantum/split_common/transactions.c **** static void rgb_matrix_handlers_slave(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 478:quantum/split_common/transactions.c ****     memcpy(&rgb_matrix_config, &split_shmem->rgb_matrix_sync.rgb_matrix, sizeof(rgb_config_t));
 479:quantum/split_common/transactions.c ****     rgb_matrix_set_suspend_state(split_shmem->rgb_matrix_sync.rgb_suspend_state);
 480:quantum/split_common/transactions.c **** }
 481:quantum/split_common/transactions.c **** 
 482:quantum/split_common/transactions.c **** #    define TRANSACTIONS_RGB_MATRIX_MASTER()      TRANSACTION_HANDLER_MASTER(rgb_matrix)
 483:quantum/split_common/transactions.c **** #    define TRANSACTIONS_RGB_MATRIX_SLAVE()       TRANSACTION_HANDLER_SLAVE(rgb_matrix)
 484:quantum/split_common/transactions.c **** #    define TRANSACTIONS_RGB_MATRIX_REGISTRATIONS [PUT_RGB_MATRIX] = trans_initiator2target_initial
 485:quantum/split_common/transactions.c **** 
 486:quantum/split_common/transactions.c **** #else  // defined(RGB_MATRIX_ENABLE) && defined(RGB_MATRIX_SPLIT)
 487:quantum/split_common/transactions.c **** 
 488:quantum/split_common/transactions.c **** #    define TRANSACTIONS_RGB_MATRIX_MASTER()
 489:quantum/split_common/transactions.c **** #    define TRANSACTIONS_RGB_MATRIX_SLAVE()
 490:quantum/split_common/transactions.c **** #    define TRANSACTIONS_RGB_MATRIX_REGISTRATIONS
 491:quantum/split_common/transactions.c **** 
 492:quantum/split_common/transactions.c **** #endif  // defined(RGB_MATRIX_ENABLE) && defined(RGB_MATRIX_SPLIT)
 493:quantum/split_common/transactions.c **** 
 494:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
 495:quantum/split_common/transactions.c **** // WPM
 496:quantum/split_common/transactions.c **** 
 497:quantum/split_common/transactions.c **** #if defined(WPM_ENABLE) && defined(SPLIT_WPM_ENABLE)
 498:quantum/split_common/transactions.c **** 
 499:quantum/split_common/transactions.c **** static bool wpm_handlers_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 500:quantum/split_common/transactions.c ****     static uint32_t last_update = 0;
 501:quantum/split_common/transactions.c ****     uint8_t         current_wpm = get_current_wpm();
 502:quantum/split_common/transactions.c ****     return send_if_condition(PUT_WPM, &last_update, (current_wpm != split_shmem->current_wpm), &cur
 503:quantum/split_common/transactions.c **** }
 504:quantum/split_common/transactions.c **** 
 505:quantum/split_common/transactions.c **** static void wpm_handlers_slave(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) { set_cur
 506:quantum/split_common/transactions.c **** 
 507:quantum/split_common/transactions.c **** #    define TRANSACTIONS_WPM_MASTER()      TRANSACTION_HANDLER_MASTER(wpm)
 508:quantum/split_common/transactions.c **** #    define TRANSACTIONS_WPM_SLAVE()       TRANSACTION_HANDLER_SLAVE(wpm)
 509:quantum/split_common/transactions.c **** #    define TRANSACTIONS_WPM_REGISTRATIONS [PUT_WPM] = trans_initiator2target_initializer(current_w
 510:quantum/split_common/transactions.c **** 
 511:quantum/split_common/transactions.c **** #else  // defined(WPM_ENABLE) && defined(SPLIT_WPM_ENABLE)
 512:quantum/split_common/transactions.c **** 
 513:quantum/split_common/transactions.c **** #    define TRANSACTIONS_WPM_MASTER()
 514:quantum/split_common/transactions.c **** #    define TRANSACTIONS_WPM_SLAVE()
 515:quantum/split_common/transactions.c **** #    define TRANSACTIONS_WPM_REGISTRATIONS
 516:quantum/split_common/transactions.c **** 
 517:quantum/split_common/transactions.c **** #endif  // defined(WPM_ENABLE) && defined(SPLIT_WPM_ENABLE)
 518:quantum/split_common/transactions.c **** 
 519:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
 520:quantum/split_common/transactions.c **** // OLED
 521:quantum/split_common/transactions.c **** 
 522:quantum/split_common/transactions.c **** #if defined(OLED_ENABLE) && defined(SPLIT_OLED_ENABLE)
 523:quantum/split_common/transactions.c **** 
 524:quantum/split_common/transactions.c **** static bool oled_handlers_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 594               		.loc 1 524 93 is_stmt 1 view -0
 595               		.cfi_startproc
 596               		.loc 1 524 93 is_stmt 0 view .LVU106
 597 0000 0F93      		push r16
 598               	.LCFI36:
 599               		.cfi_def_cfa_offset 3
 600               		.cfi_offset 16, -2
 601 0002 1F93      		push r17
 602               	.LCFI37:
 603               		.cfi_def_cfa_offset 4
 604               		.cfi_offset 17, -3
 605 0004 CF93      		push r28
 606               	.LCFI38:
 607               		.cfi_def_cfa_offset 5
 608               		.cfi_offset 28, -4
 609 0006 DF93      		push r29
 610               	.LCFI39:
 611               		.cfi_def_cfa_offset 6
 612               		.cfi_offset 29, -5
 613 0008 0F92      		push __tmp_reg__
 614               	.LCFI40:
 615               		.cfi_def_cfa_offset 7
 616 000a CDB7      		in r28,__SP_L__
 617 000c DEB7      		in r29,__SP_H__
 618               	.LCFI41:
 619               		.cfi_def_cfa_register 28
 620               	/* prologue: function */
 621               	/* frame size = 1 */
 622               	/* stack size = 5 */
 623               	.L__stack_usage = 5
 525:quantum/split_common/transactions.c ****     static uint32_t last_update        = 0;
 624               		.loc 1 525 5 is_stmt 1 view .LVU107
 526:quantum/split_common/transactions.c ****     bool            current_oled_state = is_oled_on();
 625               		.loc 1 526 5 view .LVU108
 626               		.loc 1 526 42 is_stmt 0 view .LVU109
 627 000e 0E94 0000 		call is_oled_on
 628               	.LVL43:
 629               		.loc 1 526 21 view .LVU110
 630 0012 8983      		std Y+1,r24
 527:quantum/split_common/transactions.c ****     return send_if_condition(PUT_OLED, &last_update, (current_oled_state != split_shmem->current_ol
 631               		.loc 1 527 5 is_stmt 1 view .LVU111
 632               		.loc 1 527 88 is_stmt 0 view .LVU112
 633 0014 E091 0000 		lds r30,split_shmem
 634 0018 F091 0000 		lds r31,split_shmem+1
 635 001c 2489      		ldd r18,Z+20
 636               		.loc 1 527 12 view .LVU113
 637 001e 90E0      		ldi r25,0
 638 0020 41E0      		ldi r20,lo8(1)
 639 0022 2817      		cp r18,r24
 640 0024 1906      		cpc __zero_reg__,r25
 641 0026 01F4      		brne .L27
 642 0028 40E0      		ldi r20,0
 643               	.L27:
 644 002a 01E0      		ldi r16,lo8(1)
 645 002c 10E0      		ldi r17,0
 646 002e 9E01      		movw r18,r28
 647 0030 2F5F      		subi r18,-1
 648 0032 3F4F      		sbci r19,-1
 649 0034 60E0      		ldi r22,lo8(last_update.8)
 650 0036 70E0      		ldi r23,hi8(last_update.8)
 651 0038 87E0      		ldi r24,lo8(7)
 652 003a 0E94 0000 		call send_if_condition
 653               	.LVL44:
 654               	/* epilogue start */
 528:quantum/split_common/transactions.c **** }
 655               		.loc 1 528 1 view .LVU114
 656 003e 0F90      		pop __tmp_reg__
 657 0040 DF91      		pop r29
 658 0042 CF91      		pop r28
 659 0044 1F91      		pop r17
 660 0046 0F91      		pop r16
 661 0048 0895      		ret
 662               		.cfi_endproc
 663               	.LFE39:
 665               		.section	.text.layer_state_handlers_master,"ax",@progbits
 667               	layer_state_handlers_master:
 668               	.LVL45:
 669               	.LFB37:
 255:quantum/split_common/transactions.c ****     static uint32_t last_layer_state_update         = 0;
 670               		.loc 1 255 100 is_stmt 1 view -0
 671               		.cfi_startproc
 255:quantum/split_common/transactions.c ****     static uint32_t last_layer_state_update         = 0;
 672               		.loc 1 255 100 is_stmt 0 view .LVU116
 673 0000 0F93      		push r16
 674               	.LCFI42:
 675               		.cfi_def_cfa_offset 3
 676               		.cfi_offset 16, -2
 677 0002 1F93      		push r17
 678               	.LCFI43:
 679               		.cfi_def_cfa_offset 4
 680               		.cfi_offset 17, -3
 681 0004 CF93      		push r28
 682               	.LCFI44:
 683               		.cfi_def_cfa_offset 5
 684               		.cfi_offset 28, -4
 685 0006 DF93      		push r29
 686               	.LCFI45:
 687               		.cfi_def_cfa_offset 6
 688               		.cfi_offset 29, -5
 689               	/* prologue: function */
 690               	/* frame size = 0 */
 691               	/* stack size = 4 */
 692               	.L__stack_usage = 4
 256:quantum/split_common/transactions.c ****     static uint32_t last_default_layer_state_update = 0;
 693               		.loc 1 256 5 is_stmt 1 view .LVU117
 257:quantum/split_common/transactions.c **** 
 694               		.loc 1 257 5 view .LVU118
 259:quantum/split_common/transactions.c ****     if (okay) {
 695               		.loc 1 259 5 view .LVU119
 259:quantum/split_common/transactions.c ****     if (okay) {
 696               		.loc 1 259 105 is_stmt 0 view .LVU120
 697 0008 C091 0000 		lds r28,split_shmem
 698 000c D091 0000 		lds r29,split_shmem+1
 259:quantum/split_common/transactions.c ****     if (okay) {
 699               		.loc 1 259 17 view .LVU121
 700 0010 41E0      		ldi r20,lo8(1)
 701 0012 0C85      		ldd r16,Y+12
 702 0014 1D85      		ldd r17,Y+13
 703 0016 2E85      		ldd r18,Y+14
 704 0018 3F85      		ldd r19,Y+15
 705 001a 8091 0000 		lds r24,layer_state
 706 001e 9091 0000 		lds r25,layer_state+1
 707 0022 A091 0000 		lds r26,layer_state+2
 708 0026 B091 0000 		lds r27,layer_state+3
 709               	.LVL46:
 259:quantum/split_common/transactions.c ****     if (okay) {
 710               		.loc 1 259 17 view .LVU122
 711 002a 0817      		cp r16,r24
 712 002c 1907      		cpc r17,r25
 713 002e 2A07      		cpc r18,r26
 714 0030 3B07      		cpc r19,r27
 715 0032 01F4      		brne .L29
 716 0034 40E0      		ldi r20,0
 717               	.L29:
 718 0036 04E0      		ldi r16,lo8(4)
 719 0038 10E0      		ldi r17,0
 720 003a 20E0      		ldi r18,lo8(layer_state)
 721 003c 30E0      		ldi r19,hi8(layer_state)
 722 003e 60E0      		ldi r22,lo8(last_layer_state_update.7)
 723 0040 70E0      		ldi r23,hi8(last_layer_state_update.7)
 724               	.LVL47:
 259:quantum/split_common/transactions.c ****     if (okay) {
 725               		.loc 1 259 17 view .LVU123
 726 0042 85E0      		ldi r24,lo8(5)
 727 0044 0E94 0000 		call send_if_condition
 728               	.LVL48:
 260:quantum/split_common/transactions.c ****         okay &= send_if_condition(PUT_DEFAULT_LAYER_STATE, &last_default_layer_state_update, (defau
 729               		.loc 1 260 5 is_stmt 1 view .LVU124
 260:quantum/split_common/transactions.c ****         okay &= send_if_condition(PUT_DEFAULT_LAYER_STATE, &last_default_layer_state_update, (defau
 730               		.loc 1 260 8 is_stmt 0 view .LVU125
 731 0048 8823      		tst r24
 732 004a 01F0      		breq .L28
 261:quantum/split_common/transactions.c ****     }
 733               		.loc 1 261 9 is_stmt 1 view .LVU126
 261:quantum/split_common/transactions.c ****     }
 734               		.loc 1 261 17 is_stmt 0 view .LVU127
 735 004c 41E0      		ldi r20,lo8(1)
 736 004e 0889      		ldd r16,Y+16
 737 0050 1989      		ldd r17,Y+17
 738 0052 2A89      		ldd r18,Y+18
 739 0054 3B89      		ldd r19,Y+19
 740 0056 8091 0000 		lds r24,default_layer_state
 741 005a 9091 0000 		lds r25,default_layer_state+1
 742 005e A091 0000 		lds r26,default_layer_state+2
 743 0062 B091 0000 		lds r27,default_layer_state+3
 744               	.LVL49:
 261:quantum/split_common/transactions.c ****     }
 745               		.loc 1 261 17 view .LVU128
 746 0066 0817      		cp r16,r24
 747 0068 1907      		cpc r17,r25
 748 006a 2A07      		cpc r18,r26
 749 006c 3B07      		cpc r19,r27
 750 006e 01F4      		brne .L31
 751 0070 40E0      		ldi r20,0
 752               	.L31:
 753 0072 04E0      		ldi r16,lo8(4)
 754 0074 10E0      		ldi r17,0
 755 0076 20E0      		ldi r18,lo8(default_layer_state)
 756 0078 30E0      		ldi r19,hi8(default_layer_state)
 757 007a 60E0      		ldi r22,lo8(last_default_layer_state_update.6)
 758 007c 70E0      		ldi r23,hi8(last_default_layer_state_update.6)
 759 007e 86E0      		ldi r24,lo8(6)
 760 0080 0E94 0000 		call send_if_condition
 761               	.LVL50:
 263:quantum/split_common/transactions.c **** }
 762               		.loc 1 263 5 is_stmt 1 view .LVU129
 763               	.L28:
 764               	/* epilogue start */
 264:quantum/split_common/transactions.c **** 
 765               		.loc 1 264 1 is_stmt 0 view .LVU130
 766 0084 DF91      		pop r29
 767 0086 CF91      		pop r28
 768 0088 1F91      		pop r17
 769 008a 0F91      		pop r16
 770 008c 0895      		ret
 771               		.cfi_endproc
 772               	.LFE37:
 774               		.section	.text.read_if_checksum_mismatch,"ax",@progbits
 776               	read_if_checksum_mismatch:
 777               	.LVL51:
 778               	.LFB28:
  83:quantum/split_common/transactions.c ****     uint8_t curr_checksum;
 779               		.loc 1 83 180 is_stmt 1 view -0
 780               		.cfi_startproc
  83:quantum/split_common/transactions.c ****     uint8_t curr_checksum;
 781               		.loc 1 83 180 is_stmt 0 view .LVU132
 782 0000 6F92      		push r6
 783               	.LCFI46:
 784               		.cfi_def_cfa_offset 3
 785               		.cfi_offset 6, -2
 786 0002 7F92      		push r7
 787               	.LCFI47:
 788               		.cfi_def_cfa_offset 4
 789               		.cfi_offset 7, -3
 790 0004 8F92      		push r8
 791               	.LCFI48:
 792               		.cfi_def_cfa_offset 5
 793               		.cfi_offset 8, -4
 794 0006 9F92      		push r9
 795               	.LCFI49:
 796               		.cfi_def_cfa_offset 6
 797               		.cfi_offset 9, -5
 798 0008 AF92      		push r10
 799               	.LCFI50:
 800               		.cfi_def_cfa_offset 7
 801               		.cfi_offset 10, -6
 802 000a BF92      		push r11
 803               	.LCFI51:
 804               		.cfi_def_cfa_offset 8
 805               		.cfi_offset 11, -7
 806 000c CF92      		push r12
 807               	.LCFI52:
 808               		.cfi_def_cfa_offset 9
 809               		.cfi_offset 12, -8
 810 000e DF92      		push r13
 811               	.LCFI53:
 812               		.cfi_def_cfa_offset 10
 813               		.cfi_offset 13, -9
 814 0010 EF92      		push r14
 815               	.LCFI54:
 816               		.cfi_def_cfa_offset 11
 817               		.cfi_offset 14, -10
 818 0012 FF92      		push r15
 819               	.LCFI55:
 820               		.cfi_def_cfa_offset 12
 821               		.cfi_offset 15, -11
 822 0014 0F93      		push r16
 823               	.LCFI56:
 824               		.cfi_def_cfa_offset 13
 825               		.cfi_offset 16, -12
 826 0016 1F93      		push r17
 827               	.LCFI57:
 828               		.cfi_def_cfa_offset 14
 829               		.cfi_offset 17, -13
 830 0018 CF93      		push r28
 831               	.LCFI58:
 832               		.cfi_def_cfa_offset 15
 833               		.cfi_offset 28, -14
 834 001a DF93      		push r29
 835               	.LCFI59:
 836               		.cfi_def_cfa_offset 16
 837               		.cfi_offset 29, -15
 838 001c 00D0      		rcall .
 839 001e 00D0      		rcall .
 840 0020 0F92      		push __tmp_reg__
 841               	.LCFI60:
 842               		.cfi_def_cfa_offset 21
 843 0022 CDB7      		in r28,__SP_L__
 844 0024 DEB7      		in r29,__SP_H__
 845               	.LCFI61:
 846               		.cfi_def_cfa_register 28
 847               	/* prologue: function */
 848               	/* frame size = 5 */
 849               	/* stack size = 19 */
 850               	.L__stack_usage = 19
 851 0026 662E      		mov r6,r22
 852 0028 5A01      		movw r10,r20
 853 002a 722E      		mov r7,r18
 854 002c 832E      		mov r8,r19
 855 002e 902E      		mov r9,r16
 856 0030 C12E      		mov r12,r17
  84:quantum/split_common/transactions.c ****     bool    okay = transport_read(trans_id_checksum, &curr_checksum, sizeof(curr_checksum));
 857               		.loc 1 84 5 is_stmt 1 view .LVU133
  85:quantum/split_common/transactions.c ****     if (okay && (timer_elapsed32(*last_update) >= FORCED_SYNC_THROTTLE_MS || curr_checksum != crc8(
 858               		.loc 1 85 5 view .LVU134
  85:quantum/split_common/transactions.c ****     if (okay && (timer_elapsed32(*last_update) >= FORCED_SYNC_THROTTLE_MS || curr_checksum != crc8(
 859               		.loc 1 85 20 is_stmt 0 view .LVU135
 860 0032 01E0      		ldi r16,lo8(1)
 861 0034 10E0      		ldi r17,0
 862               	.LVL52:
  85:quantum/split_common/transactions.c ****     if (okay && (timer_elapsed32(*last_update) >= FORCED_SYNC_THROTTLE_MS || curr_checksum != crc8(
 863               		.loc 1 85 20 view .LVU136
 864 0036 9E01      		movw r18,r28
 865               	.LVL53:
  85:quantum/split_common/transactions.c ****     if (okay && (timer_elapsed32(*last_update) >= FORCED_SYNC_THROTTLE_MS || curr_checksum != crc8(
 866               		.loc 1 85 20 view .LVU137
 867 0038 2F5F      		subi r18,-1
 868 003a 3F4F      		sbci r19,-1
 869 003c 50E0      		ldi r21,0
 870 003e 40E0      		ldi r20,0
 871               	.LVL54:
  85:quantum/split_common/transactions.c ****     if (okay && (timer_elapsed32(*last_update) >= FORCED_SYNC_THROTTLE_MS || curr_checksum != crc8(
 872               		.loc 1 85 20 view .LVU138
 873 0040 70E0      		ldi r23,0
 874 0042 60E0      		ldi r22,0
 875               	.LVL55:
  85:quantum/split_common/transactions.c ****     if (okay && (timer_elapsed32(*last_update) >= FORCED_SYNC_THROTTLE_MS || curr_checksum != crc8(
 876               		.loc 1 85 20 view .LVU139
 877 0044 0E94 0000 		call transport_execute_transaction
 878               	.LVL56:
  85:quantum/split_common/transactions.c ****     if (okay && (timer_elapsed32(*last_update) >= FORCED_SYNC_THROTTLE_MS || curr_checksum != crc8(
 879               		.loc 1 85 20 view .LVU140
 880 0048 D82E      		mov r13,r24
 881               	.LVL57:
  86:quantum/split_common/transactions.c ****         okay &= transport_read(trans_id_retrieve, destination, length);
 882               		.loc 1 86 5 is_stmt 1 view .LVU141
  86:quantum/split_common/transactions.c ****         okay &= transport_read(trans_id_retrieve, destination, length);
 883               		.loc 1 86 8 is_stmt 0 view .LVU142
 884 004a 8823      		tst r24
 885 004c 01F4      		brne .+2
 886 004e 00C0      		rjmp .L36
  86:quantum/split_common/transactions.c ****         okay &= transport_read(trans_id_retrieve, destination, length);
 887               		.loc 1 86 18 discriminator 1 view .LVU143
 888 0050 D501      		movw r26,r10
 889 0052 8D91      		ld r24,X+
 890 0054 9D91      		ld r25,X+
 891 0056 0D90      		ld __tmp_reg__,X+
 892 0058 BC91      		ld r27,X
 893 005a A02D      		mov r26,__tmp_reg__
 894 005c BC01      		movw r22,r24
 895 005e CD01      		movw r24,r26
 896 0060 0E94 0000 		call timer_elapsed32
 897               	.LVL58:
  86:quantum/split_common/transactions.c ****         okay &= transport_read(trans_id_retrieve, destination, length);
 898               		.loc 1 86 14 discriminator 1 view .LVU144
 899 0064 6436      		cpi r22,100
 900 0066 7105      		cpc r23,__zero_reg__
 901 0068 8105      		cpc r24,__zero_reg__
 902 006a 9105      		cpc r25,__zero_reg__
 903 006c 00F0      		brlo .L37
 904               	.L41:
  87:quantum/split_common/transactions.c ****         okay &= curr_checksum == crc8(equiv_shmem, length);
 905               		.loc 1 87 9 is_stmt 1 view .LVU145
  87:quantum/split_common/transactions.c ****         okay &= curr_checksum == crc8(equiv_shmem, length);
 906               		.loc 1 87 17 is_stmt 0 view .LVU146
 907 006e 8701      		movw r16,r14
 908 0070 272D      		mov r18,r7
 909 0072 382D      		mov r19,r8
 910 0074 50E0      		ldi r21,0
 911 0076 40E0      		ldi r20,0
 912 0078 70E0      		ldi r23,0
 913 007a 60E0      		ldi r22,0
 914 007c 862D      		mov r24,r6
 915 007e 0E94 0000 		call transport_execute_transaction
 916               	.LVL59:
 917 0082 D82E      		mov r13,r24
 918               	.LVL60:
  88:quantum/split_common/transactions.c ****         if (okay) {
 919               		.loc 1 88 9 is_stmt 1 view .LVU147
  88:quantum/split_common/transactions.c ****         if (okay) {
 920               		.loc 1 88 34 is_stmt 0 view .LVU148
 921 0084 B701      		movw r22,r14
 922 0086 892D      		mov r24,r9
 923 0088 9C2D      		mov r25,r12
 924 008a 0E94 0000 		call crc8
 925               	.LVL61:
  88:quantum/split_common/transactions.c ****         if (okay) {
 926               		.loc 1 88 31 view .LVU149
 927 008e 91E0      		ldi r25,lo8(1)
 928 0090 2981      		ldd r18,Y+1
 929 0092 2813      		cpse r18,r24
  88:quantum/split_common/transactions.c ****         if (okay) {
 930               		.loc 1 88 31 view .LVU150
 931 0094 90E0      		ldi r25,0
 932               	.L38:
 933 0096 D922      		and r13,r25
 934               	.LVL62:
  89:quantum/split_common/transactions.c ****             *last_update = timer_read32();
 935               		.loc 1 89 9 is_stmt 1 view .LVU151
  89:quantum/split_common/transactions.c ****             *last_update = timer_read32();
 936               		.loc 1 89 12 is_stmt 0 view .LVU152
 937 0098 01F0      		breq .L35
 938               	.LVL63:
 939               	.LBB66:
 940               	.LBI66:
  83:quantum/split_common/transactions.c ****     uint8_t curr_checksum;
 941               		.loc 1 83 20 is_stmt 1 view .LVU153
 942               	.LBB67:
  90:quantum/split_common/transactions.c ****         }
 943               		.loc 1 90 13 view .LVU154
  90:quantum/split_common/transactions.c ****         }
 944               		.loc 1 90 28 is_stmt 0 view .LVU155
 945 009a 0E94 0000 		call timer_read32
 946               	.LVL64:
 947 009e F501      		movw r30,r10
 948 00a0 6083      		st Z,r22
 949 00a2 7183      		std Z+1,r23
 950 00a4 8283      		std Z+2,r24
 951 00a6 9383      		std Z+3,r25
 952               	.LVL65:
  95:quantum/split_common/transactions.c **** }
 953               		.loc 1 95 5 is_stmt 1 view .LVU156
 954               	.L35:
  95:quantum/split_common/transactions.c **** }
 955               		.loc 1 95 5 is_stmt 0 view .LVU157
 956               	.LBE67:
 957               	.LBE66:
  96:quantum/split_common/transactions.c **** 
 958               		.loc 1 96 1 view .LVU158
 959 00a8 8D2D      		mov r24,r13
 960               	/* epilogue start */
 961 00aa 0F90      		pop __tmp_reg__
 962 00ac 0F90      		pop __tmp_reg__
 963 00ae 0F90      		pop __tmp_reg__
 964 00b0 0F90      		pop __tmp_reg__
 965 00b2 0F90      		pop __tmp_reg__
 966 00b4 DF91      		pop r29
 967 00b6 CF91      		pop r28
 968 00b8 1F91      		pop r17
 969 00ba 0F91      		pop r16
 970 00bc FF90      		pop r15
 971 00be EF90      		pop r14
 972               	.LVL66:
  96:quantum/split_common/transactions.c **** 
 973               		.loc 1 96 1 view .LVU159
 974 00c0 DF90      		pop r13
 975               	.LVL67:
  96:quantum/split_common/transactions.c **** 
 976               		.loc 1 96 1 view .LVU160
 977 00c2 CF90      		pop r12
 978 00c4 BF90      		pop r11
 979 00c6 AF90      		pop r10
 980               	.LVL68:
  96:quantum/split_common/transactions.c **** 
 981               		.loc 1 96 1 view .LVU161
 982 00c8 9F90      		pop r9
 983 00ca 8F90      		pop r8
 984 00cc 7F90      		pop r7
 985 00ce 6F90      		pop r6
 986               	.LVL69:
  96:quantum/split_common/transactions.c **** 
 987               		.loc 1 96 1 view .LVU162
 988 00d0 0895      		ret
 989               	.LVL70:
 990               	.L37:
  86:quantum/split_common/transactions.c ****         okay &= transport_read(trans_id_retrieve, destination, length);
 991               		.loc 1 86 95 discriminator 2 view .LVU163
 992 00d2 B701      		movw r22,r14
 993 00d4 892D      		mov r24,r9
 994 00d6 9C2D      		mov r25,r12
 995 00d8 0E94 0000 		call crc8
 996               	.LVL71:
  86:quantum/split_common/transactions.c ****         okay &= transport_read(trans_id_retrieve, destination, length);
 997               		.loc 1 86 75 discriminator 2 view .LVU164
 998 00dc 9981      		ldd r25,Y+1
 999 00de 8913      		cpse r24,r25
 1000 00e0 00C0      		rjmp .L41
 1001               	.L36:
  93:quantum/split_common/transactions.c ****     }
 1002               		.loc 1 93 9 is_stmt 1 view .LVU165
 1003 00e2 A701      		movw r20,r14
 1004 00e4 692D      		mov r22,r9
 1005 00e6 7C2D      		mov r23,r12
 1006 00e8 872D      		mov r24,r7
 1007 00ea 982D      		mov r25,r8
 1008 00ec 0E94 0000 		call memcpy
 1009               	.LVL72:
  95:quantum/split_common/transactions.c **** }
 1010               		.loc 1 95 5 view .LVU166
  95:quantum/split_common/transactions.c **** }
 1011               		.loc 1 95 12 is_stmt 0 view .LVU167
 1012 00f0 00C0      		rjmp .L35
 1013               		.cfi_endproc
 1014               	.LFE28:
 1016               		.section	.text.encoder_handlers_master,"ax",@progbits
 1018               	encoder_handlers_master:
 1019               	.LVL73:
 1020               	.LFB33:
 177:quantum/split_common/transactions.c ****     static uint32_t last_update = 0;
 1021               		.loc 1 177 96 is_stmt 1 view -0
 1022               		.cfi_startproc
 177:quantum/split_common/transactions.c ****     static uint32_t last_update = 0;
 1023               		.loc 1 177 96 is_stmt 0 view .LVU169
 1024 0000 EF92      		push r14
 1025               	.LCFI62:
 1026               		.cfi_def_cfa_offset 3
 1027               		.cfi_offset 14, -2
 1028 0002 FF92      		push r15
 1029               	.LCFI63:
 1030               		.cfi_def_cfa_offset 4
 1031               		.cfi_offset 15, -3
 1032 0004 0F93      		push r16
 1033               	.LCFI64:
 1034               		.cfi_def_cfa_offset 5
 1035               		.cfi_offset 16, -4
 1036 0006 1F93      		push r17
 1037               	.LCFI65:
 1038               		.cfi_def_cfa_offset 6
 1039               		.cfi_offset 17, -5
 1040 0008 CF93      		push r28
 1041               	.LCFI66:
 1042               		.cfi_def_cfa_offset 7
 1043               		.cfi_offset 28, -6
 1044 000a DF93      		push r29
 1045               	.LCFI67:
 1046               		.cfi_def_cfa_offset 8
 1047               		.cfi_offset 29, -7
 1048 000c 0F92      		push __tmp_reg__
 1049               	.LCFI68:
 1050               		.cfi_def_cfa_offset 9
 1051 000e CDB7      		in r28,__SP_L__
 1052 0010 DEB7      		in r29,__SP_H__
 1053               	.LCFI69:
 1054               		.cfi_def_cfa_register 28
 1055               	/* prologue: function */
 1056               	/* frame size = 1 */
 1057               	/* stack size = 7 */
 1058               	.L__stack_usage = 7
 178:quantum/split_common/transactions.c ****     uint8_t         temp_state[NUMBER_OF_ENCODERS];
 1059               		.loc 1 178 5 is_stmt 1 view .LVU170
 179:quantum/split_common/transactions.c **** 
 1060               		.loc 1 179 5 view .LVU171
 181:quantum/split_common/transactions.c ****     if (okay) encoder_update_raw(temp_state);
 1061               		.loc 1 181 5 view .LVU172
 181:quantum/split_common/transactions.c ****     if (okay) encoder_update_raw(temp_state);
 1062               		.loc 1 181 132 is_stmt 0 view .LVU173
 1063 0012 0091 0000 		lds r16,split_shmem
 1064 0016 1091 0000 		lds r17,split_shmem+1
 1065 001a 095F      		subi r16,-7
 1066 001c 1F4F      		sbci r17,-1
 181:quantum/split_common/transactions.c ****     if (okay) encoder_update_raw(temp_state);
 1067               		.loc 1 181 17 view .LVU174
 1068 001e EE24      		clr r14
 1069 0020 E394      		inc r14
 1070 0022 F12C      		mov r15,__zero_reg__
 1071               	.LVL74:
 181:quantum/split_common/transactions.c ****     if (okay) encoder_update_raw(temp_state);
 1072               		.loc 1 181 17 view .LVU175
 1073 0024 9E01      		movw r18,r28
 1074 0026 2F5F      		subi r18,-1
 1075 0028 3F4F      		sbci r19,-1
 1076 002a 40E0      		ldi r20,lo8(last_update.4)
 1077 002c 50E0      		ldi r21,hi8(last_update.4)
 1078 002e 63E0      		ldi r22,lo8(3)
 1079               	.LVL75:
 181:quantum/split_common/transactions.c ****     if (okay) encoder_update_raw(temp_state);
 1080               		.loc 1 181 17 view .LVU176
 1081 0030 82E0      		ldi r24,lo8(2)
 1082 0032 0E94 0000 		call read_if_checksum_mismatch
 1083               	.LVL76:
 1084 0036 182F      		mov r17,r24
 1085               	.LVL77:
 182:quantum/split_common/transactions.c ****     return okay;
 1086               		.loc 1 182 5 is_stmt 1 view .LVU177
 182:quantum/split_common/transactions.c ****     return okay;
 1087               		.loc 1 182 8 is_stmt 0 view .LVU178
 1088 0038 8823      		tst r24
 1089 003a 01F0      		breq .L45
 182:quantum/split_common/transactions.c ****     return okay;
 1090               		.loc 1 182 15 is_stmt 1 discriminator 1 view .LVU179
 1091 003c CE01      		movw r24,r28
 1092 003e 0196      		adiw r24,1
 1093 0040 0E94 0000 		call encoder_update_raw
 1094               	.LVL78:
 183:quantum/split_common/transactions.c **** }
 1095               		.loc 1 183 5 discriminator 1 view .LVU180
 1096               	.L45:
 184:quantum/split_common/transactions.c **** 
 1097               		.loc 1 184 1 is_stmt 0 view .LVU181
 1098 0044 812F      		mov r24,r17
 1099               	/* epilogue start */
 1100 0046 0F90      		pop __tmp_reg__
 1101 0048 DF91      		pop r29
 1102 004a CF91      		pop r28
 1103 004c 1F91      		pop r17
 1104               	.LVL79:
 184:quantum/split_common/transactions.c **** 
 1105               		.loc 1 184 1 view .LVU182
 1106 004e 0F91      		pop r16
 1107 0050 FF90      		pop r15
 1108 0052 EF90      		pop r14
 1109 0054 0895      		ret
 1110               		.cfi_endproc
 1111               	.LFE33:
 1113               		.section	.text.slave_matrix_handlers_master,"ax",@progbits
 1115               	slave_matrix_handlers_master:
 1116               	.LVL80:
 1117               	.LFB31:
 117:quantum/split_common/transactions.c ****     static uint32_t     last_update                    = 0;
 1118               		.loc 1 117 101 is_stmt 1 view -0
 1119               		.cfi_startproc
 117:quantum/split_common/transactions.c ****     static uint32_t     last_update                    = 0;
 1120               		.loc 1 117 101 is_stmt 0 view .LVU184
 1121 0000 CF92      		push r12
 1122               	.LCFI70:
 1123               		.cfi_def_cfa_offset 3
 1124               		.cfi_offset 12, -2
 1125 0002 DF92      		push r13
 1126               	.LCFI71:
 1127               		.cfi_def_cfa_offset 4
 1128               		.cfi_offset 13, -3
 1129 0004 EF92      		push r14
 1130               	.LCFI72:
 1131               		.cfi_def_cfa_offset 5
 1132               		.cfi_offset 14, -4
 1133 0006 FF92      		push r15
 1134               	.LCFI73:
 1135               		.cfi_def_cfa_offset 6
 1136               		.cfi_offset 15, -5
 1137 0008 0F93      		push r16
 1138               	.LCFI74:
 1139               		.cfi_def_cfa_offset 7
 1140               		.cfi_offset 16, -6
 1141 000a 1F93      		push r17
 1142               	.LCFI75:
 1143               		.cfi_def_cfa_offset 8
 1144               		.cfi_offset 17, -7
 1145 000c CF93      		push r28
 1146               	.LCFI76:
 1147               		.cfi_def_cfa_offset 9
 1148               		.cfi_offset 28, -8
 1149 000e DF93      		push r29
 1150               	.LCFI77:
 1151               		.cfi_def_cfa_offset 10
 1152               		.cfi_offset 29, -9
 1153 0010 00D0      		rcall .
 1154 0012 00D0      		rcall .
 1155 0014 0F92      		push __tmp_reg__
 1156               	.LCFI78:
 1157               		.cfi_def_cfa_offset 15
 1158 0016 CDB7      		in r28,__SP_L__
 1159 0018 DEB7      		in r29,__SP_H__
 1160               	.LCFI79:
 1161               		.cfi_def_cfa_register 28
 1162               	/* prologue: function */
 1163               	/* frame size = 5 */
 1164               	/* stack size = 13 */
 1165               	.L__stack_usage = 13
 1166 001a 6B01      		movw r12,r22
 118:quantum/split_common/transactions.c ****     static matrix_row_t last_matrix[(MATRIX_ROWS) / 2] = {0};  // last successfully-read matrix, so
 1167               		.loc 1 118 5 is_stmt 1 view .LVU185
 119:quantum/split_common/transactions.c ****     matrix_row_t        temp_matrix[(MATRIX_ROWS) / 2];        // holding area while we test whethe
 1168               		.loc 1 119 5 view .LVU186
 120:quantum/split_common/transactions.c **** 
 1169               		.loc 1 120 5 view .LVU187
 122:quantum/split_common/transactions.c ****     if (okay) {
 1170               		.loc 1 122 5 view .LVU188
 122:quantum/split_common/transactions.c ****     if (okay) {
 1171               		.loc 1 122 140 is_stmt 0 view .LVU189
 1172 001c 0091 0000 		lds r16,split_shmem
 1173 0020 1091 0000 		lds r17,split_shmem+1
 1174 0024 0F5F      		subi r16,-1
 1175 0026 1F4F      		sbci r17,-1
 122:quantum/split_common/transactions.c ****     if (okay) {
 1176               		.loc 1 122 17 view .LVU190
 1177 0028 85E0      		ldi r24,lo8(5)
 1178 002a E82E      		mov r14,r24
 1179 002c F12C      		mov r15,__zero_reg__
 1180               	.LVL81:
 122:quantum/split_common/transactions.c ****     if (okay) {
 1181               		.loc 1 122 17 view .LVU191
 1182 002e 9E01      		movw r18,r28
 1183 0030 2F5F      		subi r18,-1
 1184 0032 3F4F      		sbci r19,-1
 1185 0034 40E0      		ldi r20,lo8(last_update.3)
 1186 0036 50E0      		ldi r21,hi8(last_update.3)
 1187 0038 61E0      		ldi r22,lo8(1)
 1188               	.LVL82:
 122:quantum/split_common/transactions.c ****     if (okay) {
 1189               		.loc 1 122 17 view .LVU192
 1190 003a 80E0      		ldi r24,0
 1191 003c 0E94 0000 		call read_if_checksum_mismatch
 1192               	.LVL83:
 123:quantum/split_common/transactions.c ****         // Checksum matches the received data, save as the last matrix state
 1193               		.loc 1 123 5 is_stmt 1 view .LVU193
 123:quantum/split_common/transactions.c ****         // Checksum matches the received data, save as the last matrix state
 1194               		.loc 1 123 8 is_stmt 0 view .LVU194
 1195 0040 8823      		tst r24
 1196 0042 01F0      		breq .L51
 125:quantum/split_common/transactions.c ****     }
 1197               		.loc 1 125 9 is_stmt 1 view .LVU195
 1198 0044 95E0      		ldi r25,lo8(5)
 1199 0046 FE01      		movw r30,r28
 1200 0048 3196      		adiw r30,1
 1201 004a A0E0      		ldi r26,lo8(last_matrix.2)
 1202 004c B0E0      		ldi r27,hi8(last_matrix.2)
 1203               		0:
 1204 004e 0190      		ld r0,Z+
 1205 0050 0D92      		st X+,r0
 1206 0052 9A95      		dec r25
 1207 0054 01F4      		brne 0b
 1208               	.L51:
 128:quantum/split_common/transactions.c ****     return okay;
 1209               		.loc 1 128 5 view .LVU196
 1210 0056 95E0      		ldi r25,lo8(5)
 1211 0058 E0E0      		ldi r30,lo8(last_matrix.2)
 1212 005a F0E0      		ldi r31,hi8(last_matrix.2)
 1213 005c D601      		movw r26,r12
 1214               		0:
 1215 005e 0190      		ld r0,Z+
 1216 0060 0D92      		st X+,r0
 1217 0062 9A95      		dec r25
 1218 0064 01F4      		brne 0b
 129:quantum/split_common/transactions.c **** }
 1219               		.loc 1 129 5 view .LVU197
 1220               	/* epilogue start */
 130:quantum/split_common/transactions.c **** 
 1221               		.loc 1 130 1 is_stmt 0 view .LVU198
 1222 0066 0F90      		pop __tmp_reg__
 1223 0068 0F90      		pop __tmp_reg__
 1224 006a 0F90      		pop __tmp_reg__
 1225 006c 0F90      		pop __tmp_reg__
 1226 006e 0F90      		pop __tmp_reg__
 1227 0070 DF91      		pop r29
 1228 0072 CF91      		pop r28
 1229 0074 1F91      		pop r17
 1230 0076 0F91      		pop r16
 1231 0078 FF90      		pop r15
 1232 007a EF90      		pop r14
 1233 007c DF90      		pop r13
 1234 007e CF90      		pop r12
 1235               	.LVL84:
 130:quantum/split_common/transactions.c **** 
 1236               		.loc 1 130 1 view .LVU199
 1237 0080 0895      		ret
 1238               		.cfi_endproc
 1239               	.LFE31:
 1241               		.section	.rodata.transactions_master.str1.1,"aMS",@progbits,1
 1242               	.LC0:
 1243 0000 736C 6176 		.string	"slave_matrix"
 1243      655F 6D61 
 1243      7472 6978 
 1243      00
 1244               	.LC1:
 1245 000d 656E 636F 		.string	"encoder"
 1245      6465 7200 
 1246               	.LC2:
 1247 0015 7379 6E63 		.string	"sync_timer"
 1247      5F74 696D 
 1247      6572 00
 1248               	.LC3:
 1249 0020 6C61 7965 		.string	"layer_state"
 1249      725F 7374 
 1249      6174 6500 
 1250               	.LC4:
 1251 002c 6F6C 6564 		.string	"oled"
 1251      00
 1252               		.section	.text.transactions_master,"ax",@progbits
 1253               	.global	transactions_master
 1255               	transactions_master:
 1256               	.LVL85:
 1257               	.LFB41:
 529:quantum/split_common/transactions.c **** 
 530:quantum/split_common/transactions.c **** static void oled_handlers_slave(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 531:quantum/split_common/transactions.c ****     if (split_shmem->current_oled_state) {
 532:quantum/split_common/transactions.c ****         oled_on();
 533:quantum/split_common/transactions.c ****     } else {
 534:quantum/split_common/transactions.c ****         oled_off();
 535:quantum/split_common/transactions.c ****     }
 536:quantum/split_common/transactions.c **** }
 537:quantum/split_common/transactions.c **** 
 538:quantum/split_common/transactions.c **** #    define TRANSACTIONS_OLED_MASTER()      TRANSACTION_HANDLER_MASTER(oled)
 539:quantum/split_common/transactions.c **** #    define TRANSACTIONS_OLED_SLAVE()       TRANSACTION_HANDLER_SLAVE(oled)
 540:quantum/split_common/transactions.c **** #    define TRANSACTIONS_OLED_REGISTRATIONS [PUT_OLED] = trans_initiator2target_initializer(current
 541:quantum/split_common/transactions.c **** 
 542:quantum/split_common/transactions.c **** #else  // defined(OLED_ENABLE) && defined(SPLIT_OLED_ENABLE)
 543:quantum/split_common/transactions.c **** 
 544:quantum/split_common/transactions.c **** #    define TRANSACTIONS_OLED_MASTER()
 545:quantum/split_common/transactions.c **** #    define TRANSACTIONS_OLED_SLAVE()
 546:quantum/split_common/transactions.c **** #    define TRANSACTIONS_OLED_REGISTRATIONS
 547:quantum/split_common/transactions.c **** 
 548:quantum/split_common/transactions.c **** #endif  // defined(OLED_ENABLE) && defined(SPLIT_OLED_ENABLE)
 549:quantum/split_common/transactions.c **** 
 550:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
 551:quantum/split_common/transactions.c **** // ST7565
 552:quantum/split_common/transactions.c **** 
 553:quantum/split_common/transactions.c **** #if defined(ST7565_ENABLE) && defined(SPLIT_ST7565_ENABLE)
 554:quantum/split_common/transactions.c **** 
 555:quantum/split_common/transactions.c **** static bool st7565_handlers_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 556:quantum/split_common/transactions.c ****     static uint32_t last_update          = 0;
 557:quantum/split_common/transactions.c ****     bool            current_st7565_state = st7565_is_on();
 558:quantum/split_common/transactions.c ****     return send_if_condition(PUT_ST7565, &last_update, (current_st7565_state != split_shmem->curren
 559:quantum/split_common/transactions.c **** }
 560:quantum/split_common/transactions.c **** 
 561:quantum/split_common/transactions.c **** static void st7565_handlers_slave(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 562:quantum/split_common/transactions.c ****     if (split_shmem->current_st7565_state) {
 563:quantum/split_common/transactions.c ****         st7565_on();
 564:quantum/split_common/transactions.c ****     } else {
 565:quantum/split_common/transactions.c ****         st7565_off();
 566:quantum/split_common/transactions.c ****     }
 567:quantum/split_common/transactions.c **** }
 568:quantum/split_common/transactions.c **** 
 569:quantum/split_common/transactions.c **** #    define TRANSACTIONS_ST7565_MASTER()      TRANSACTION_HANDLER_MASTER(st7565)
 570:quantum/split_common/transactions.c **** #    define TRANSACTIONS_ST7565_SLAVE()       TRANSACTION_HANDLER_SLAVE(st7565)
 571:quantum/split_common/transactions.c **** #    define TRANSACTIONS_ST7565_REGISTRATIONS [PUT_ST7565] = trans_initiator2target_initializer(cur
 572:quantum/split_common/transactions.c **** 
 573:quantum/split_common/transactions.c **** #else  // defined(ST7565_ENABLE) && defined(SPLIT_ST7565_ENABLE)
 574:quantum/split_common/transactions.c **** 
 575:quantum/split_common/transactions.c **** #    define TRANSACTIONS_ST7565_MASTER()
 576:quantum/split_common/transactions.c **** #    define TRANSACTIONS_ST7565_SLAVE()
 577:quantum/split_common/transactions.c **** #    define TRANSACTIONS_ST7565_REGISTRATIONS
 578:quantum/split_common/transactions.c **** 
 579:quantum/split_common/transactions.c **** #endif  // defined(ST7565_ENABLE) && defined(SPLIT_ST7565_ENABLE)
 580:quantum/split_common/transactions.c **** 
 581:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
 582:quantum/split_common/transactions.c **** 
 583:quantum/split_common/transactions.c **** uint8_t                  dummy;
 584:quantum/split_common/transactions.c **** split_transaction_desc_t split_transaction_table[NUM_TOTAL_TRANSACTIONS] = {
 585:quantum/split_common/transactions.c ****     // Set defaults
 586:quantum/split_common/transactions.c ****     [0 ...(NUM_TOTAL_TRANSACTIONS - 1)] = {NULL, 0, 0, 0, 0, 0},
 587:quantum/split_common/transactions.c **** 
 588:quantum/split_common/transactions.c **** #ifdef USE_I2C
 589:quantum/split_common/transactions.c ****     [I2C_EXECUTE_CALLBACK] = trans_initiator2target_initializer(transaction_id),
 590:quantum/split_common/transactions.c **** #endif  // USE_I2C
 591:quantum/split_common/transactions.c **** 
 592:quantum/split_common/transactions.c ****     // clang-format off
 593:quantum/split_common/transactions.c ****     TRANSACTIONS_SLAVE_MATRIX_REGISTRATIONS
 594:quantum/split_common/transactions.c ****     TRANSACTIONS_MASTER_MATRIX_REGISTRATIONS
 595:quantum/split_common/transactions.c ****     TRANSACTIONS_ENCODERS_REGISTRATIONS
 596:quantum/split_common/transactions.c ****     TRANSACTIONS_SYNC_TIMER_REGISTRATIONS
 597:quantum/split_common/transactions.c ****     TRANSACTIONS_LAYER_STATE_REGISTRATIONS
 598:quantum/split_common/transactions.c ****     TRANSACTIONS_LED_STATE_REGISTRATIONS
 599:quantum/split_common/transactions.c ****     TRANSACTIONS_MODS_REGISTRATIONS
 600:quantum/split_common/transactions.c ****     TRANSACTIONS_BACKLIGHT_REGISTRATIONS
 601:quantum/split_common/transactions.c ****     TRANSACTIONS_RGBLIGHT_REGISTRATIONS
 602:quantum/split_common/transactions.c ****     TRANSACTIONS_LED_MATRIX_REGISTRATIONS
 603:quantum/split_common/transactions.c ****     TRANSACTIONS_RGB_MATRIX_REGISTRATIONS
 604:quantum/split_common/transactions.c ****     TRANSACTIONS_WPM_REGISTRATIONS
 605:quantum/split_common/transactions.c ****     TRANSACTIONS_OLED_REGISTRATIONS
 606:quantum/split_common/transactions.c ****     TRANSACTIONS_ST7565_REGISTRATIONS
 607:quantum/split_common/transactions.c **** // clang-format on
 608:quantum/split_common/transactions.c **** 
 609:quantum/split_common/transactions.c **** #if defined(SPLIT_TRANSACTION_IDS_KB) || defined(SPLIT_TRANSACTION_IDS_USER)
 610:quantum/split_common/transactions.c ****         [PUT_RPC_INFO]  = trans_initiator2target_initializer_cb(rpc_info, slave_rpc_info_callback),
 611:quantum/split_common/transactions.c ****     [PUT_RPC_REQ_DATA]  = trans_initiator2target_initializer(rpc_m2s_buffer),
 612:quantum/split_common/transactions.c ****     [EXECUTE_RPC]       = trans_initiator2target_initializer_cb(rpc_info.transaction_id, slave_rpc_
 613:quantum/split_common/transactions.c ****     [GET_RPC_RESP_DATA] = trans_target2initiator_initializer(rpc_s2m_buffer),
 614:quantum/split_common/transactions.c **** #endif  // defined(SPLIT_TRANSACTION_IDS_KB) || defined(SPLIT_TRANSACTION_IDS_USER)
 615:quantum/split_common/transactions.c **** };
 616:quantum/split_common/transactions.c **** 
 617:quantum/split_common/transactions.c **** bool transactions_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 1258               		.loc 1 617 85 is_stmt 1 view -0
 1259               		.cfi_startproc
 1260               		.loc 1 617 85 is_stmt 0 view .LVU201
 1261 0000 0F93      		push r16
 1262               	.LCFI80:
 1263               		.cfi_def_cfa_offset 3
 1264               		.cfi_offset 16, -2
 1265 0002 1F93      		push r17
 1266               	.LCFI81:
 1267               		.cfi_def_cfa_offset 4
 1268               		.cfi_offset 17, -3
 1269 0004 CF93      		push r28
 1270               	.LCFI82:
 1271               		.cfi_def_cfa_offset 5
 1272               		.cfi_offset 28, -4
 1273 0006 DF93      		push r29
 1274               	.LCFI83:
 1275               		.cfi_def_cfa_offset 6
 1276               		.cfi_offset 29, -5
 1277               	/* prologue: function */
 1278               	/* frame size = 0 */
 1279               	/* stack size = 4 */
 1280               	.L__stack_usage = 4
 1281 0008 D82F      		mov r29,r24
 1282 000a C92F      		mov r28,r25
 1283 000c 8B01      		movw r16,r22
 618:quantum/split_common/transactions.c ****     TRANSACTIONS_SLAVE_MATRIX_MASTER();
 1284               		.loc 1 618 5 is_stmt 1 view .LVU202
 1285               		.loc 1 618 5 view .LVU203
 1286 000e 20E0      		ldi r18,lo8(gs(slave_matrix_handlers_master))
 1287 0010 30E0      		ldi r19,hi8(gs(slave_matrix_handlers_master))
 1288 0012 40E0      		ldi r20,lo8(.LC0)
 1289 0014 50E0      		ldi r21,hi8(.LC0)
 1290 0016 0E94 0000 		call transaction_handler_master
 1291               	.LVL86:
 1292               		.loc 1 618 5 is_stmt 0 view .LVU204
 1293 001a 8823      		tst r24
 1294 001c 01F0      		breq .L57
 1295               		.loc 1 618 5 is_stmt 1 discriminator 2 view .LVU205
 619:quantum/split_common/transactions.c ****     TRANSACTIONS_MASTER_MATRIX_MASTER();
 1296               		.loc 1 619 40 discriminator 2 view .LVU206
 620:quantum/split_common/transactions.c ****     TRANSACTIONS_ENCODERS_MASTER();
 1297               		.loc 1 620 5 discriminator 2 view .LVU207
 1298               		.loc 1 620 5 discriminator 2 view .LVU208
 1299 001e 20E0      		ldi r18,lo8(gs(encoder_handlers_master))
 1300 0020 30E0      		ldi r19,hi8(gs(encoder_handlers_master))
 1301 0022 40E0      		ldi r20,lo8(.LC1)
 1302 0024 50E0      		ldi r21,hi8(.LC1)
 1303 0026 B801      		movw r22,r16
 1304 0028 8D2F      		mov r24,r29
 1305 002a 9C2F      		mov r25,r28
 1306 002c 0E94 0000 		call transaction_handler_master
 1307               	.LVL87:
 1308 0030 8823      		tst r24
 1309 0032 01F0      		breq .L57
 1310               		.loc 1 620 5 discriminator 2 view .LVU209
 621:quantum/split_common/transactions.c ****     TRANSACTIONS_SYNC_TIMER_MASTER();
 1311               		.loc 1 621 5 discriminator 2 view .LVU210
 1312               		.loc 1 621 5 discriminator 2 view .LVU211
 1313 0034 20E0      		ldi r18,lo8(gs(sync_timer_handlers_master))
 1314 0036 30E0      		ldi r19,hi8(gs(sync_timer_handlers_master))
 1315 0038 40E0      		ldi r20,lo8(.LC2)
 1316 003a 50E0      		ldi r21,hi8(.LC2)
 1317 003c B801      		movw r22,r16
 1318 003e 8D2F      		mov r24,r29
 1319 0040 9C2F      		mov r25,r28
 1320 0042 0E94 0000 		call transaction_handler_master
 1321               	.LVL88:
 1322 0046 8823      		tst r24
 1323 0048 01F0      		breq .L57
 1324               		.loc 1 621 5 discriminator 2 view .LVU212
 622:quantum/split_common/transactions.c ****     TRANSACTIONS_LAYER_STATE_MASTER();
 1325               		.loc 1 622 5 discriminator 2 view .LVU213
 1326               		.loc 1 622 5 discriminator 2 view .LVU214
 1327 004a 20E0      		ldi r18,lo8(gs(layer_state_handlers_master))
 1328 004c 30E0      		ldi r19,hi8(gs(layer_state_handlers_master))
 1329 004e 40E0      		ldi r20,lo8(.LC3)
 1330 0050 50E0      		ldi r21,hi8(.LC3)
 1331 0052 B801      		movw r22,r16
 1332 0054 8D2F      		mov r24,r29
 1333 0056 9C2F      		mov r25,r28
 1334 0058 0E94 0000 		call transaction_handler_master
 1335               	.LVL89:
 1336 005c 8823      		tst r24
 1337 005e 01F0      		breq .L57
 1338               		.loc 1 622 5 discriminator 2 view .LVU215
 623:quantum/split_common/transactions.c ****     TRANSACTIONS_LED_STATE_MASTER();
 1339               		.loc 1 623 36 discriminator 2 view .LVU216
 624:quantum/split_common/transactions.c ****     TRANSACTIONS_MODS_MASTER();
 1340               		.loc 1 624 31 discriminator 2 view .LVU217
 625:quantum/split_common/transactions.c ****     TRANSACTIONS_BACKLIGHT_MASTER();
 1341               		.loc 1 625 36 discriminator 2 view .LVU218
 626:quantum/split_common/transactions.c ****     TRANSACTIONS_RGBLIGHT_MASTER();
 1342               		.loc 1 626 35 discriminator 2 view .LVU219
 627:quantum/split_common/transactions.c ****     TRANSACTIONS_LED_MATRIX_MASTER();
 1343               		.loc 1 627 37 discriminator 2 view .LVU220
 628:quantum/split_common/transactions.c ****     TRANSACTIONS_RGB_MATRIX_MASTER();
 1344               		.loc 1 628 37 discriminator 2 view .LVU221
 629:quantum/split_common/transactions.c ****     TRANSACTIONS_WPM_MASTER();
 1345               		.loc 1 629 30 discriminator 2 view .LVU222
 630:quantum/split_common/transactions.c ****     TRANSACTIONS_OLED_MASTER();
 1346               		.loc 1 630 5 discriminator 2 view .LVU223
 1347               		.loc 1 630 5 discriminator 2 view .LVU224
 1348 0060 20E0      		ldi r18,lo8(gs(oled_handlers_master))
 1349 0062 30E0      		ldi r19,hi8(gs(oled_handlers_master))
 1350 0064 40E0      		ldi r20,lo8(.LC4)
 1351 0066 50E0      		ldi r21,hi8(.LC4)
 1352 0068 B801      		movw r22,r16
 1353 006a 8D2F      		mov r24,r29
 1354 006c 9C2F      		mov r25,r28
 1355               	/* epilogue start */
 631:quantum/split_common/transactions.c ****     TRANSACTIONS_ST7565_MASTER();
 632:quantum/split_common/transactions.c ****     return true;
 633:quantum/split_common/transactions.c **** }
 1356               		.loc 1 633 1 is_stmt 0 discriminator 2 view .LVU225
 1357 006e DF91      		pop r29
 1358 0070 CF91      		pop r28
 1359 0072 1F91      		pop r17
 1360 0074 0F91      		pop r16
 1361               	.LVL90:
 630:quantum/split_common/transactions.c ****     TRANSACTIONS_OLED_MASTER();
 1362               		.loc 1 630 5 discriminator 2 view .LVU226
 1363 0076 0C94 0000 		jmp transaction_handler_master
 1364               	.LVL91:
 1365               	.L57:
 1366               		.loc 1 633 1 view .LVU227
 1367 007a 80E0      		ldi r24,0
 1368               	/* epilogue start */
 1369 007c DF91      		pop r29
 1370 007e CF91      		pop r28
 1371 0080 1F91      		pop r17
 1372 0082 0F91      		pop r16
 1373               	.LVL92:
 1374               		.loc 1 633 1 view .LVU228
 1375 0084 0895      		ret
 1376               		.cfi_endproc
 1377               	.LFE41:
 1379               		.section	.text.transactions_slave,"ax",@progbits
 1380               	.global	transactions_slave
 1382               	transactions_slave:
 1383               	.LVL93:
 1384               	.LFB42:
 634:quantum/split_common/transactions.c **** 
 635:quantum/split_common/transactions.c **** void transactions_slave(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 1385               		.loc 1 635 84 is_stmt 1 view -0
 1386               		.cfi_startproc
 1387               		.loc 1 635 84 is_stmt 0 view .LVU230
 1388 0000 CF92      		push r12
 1389               	.LCFI84:
 1390               		.cfi_def_cfa_offset 3
 1391               		.cfi_offset 12, -2
 1392 0002 DF92      		push r13
 1393               	.LCFI85:
 1394               		.cfi_def_cfa_offset 4
 1395               		.cfi_offset 13, -3
 1396 0004 EF92      		push r14
 1397               	.LCFI86:
 1398               		.cfi_def_cfa_offset 5
 1399               		.cfi_offset 14, -4
 1400 0006 FF92      		push r15
 1401               	.LCFI87:
 1402               		.cfi_def_cfa_offset 6
 1403               		.cfi_offset 15, -5
 1404 0008 0F93      		push r16
 1405               	.LCFI88:
 1406               		.cfi_def_cfa_offset 7
 1407               		.cfi_offset 16, -6
 1408 000a 1F93      		push r17
 1409               	.LCFI89:
 1410               		.cfi_def_cfa_offset 8
 1411               		.cfi_offset 17, -7
 1412 000c CF93      		push r28
 1413               	.LCFI90:
 1414               		.cfi_def_cfa_offset 9
 1415               		.cfi_offset 28, -8
 1416 000e DF93      		push r29
 1417               	.LCFI91:
 1418               		.cfi_def_cfa_offset 10
 1419               		.cfi_offset 29, -9
 1420 0010 0F92      		push __tmp_reg__
 1421               	.LCFI92:
 1422               		.cfi_def_cfa_offset 11
 1423 0012 CDB7      		in r28,__SP_L__
 1424 0014 DEB7      		in r29,__SP_H__
 1425               	.LCFI93:
 1426               		.cfi_def_cfa_register 28
 1427               	/* prologue: function */
 1428               	/* frame size = 1 */
 1429               	/* stack size = 9 */
 1430               	.L__stack_usage = 9
 1431 0016 FB01      		movw r30,r22
 636:quantum/split_common/transactions.c ****     TRANSACTIONS_SLAVE_MATRIX_SLAVE();
 1432               		.loc 1 636 5 is_stmt 1 view .LVU231
 1433               		.loc 1 636 5 view .LVU232
 1434               	.LBB103:
 1435               		.loc 1 636 5 view .LVU233
 1436               	.LVL94:
 1437               	.LBB104:
 1438               	.LBI104:
  48:/usr/avr/include/util/atomic.h **** {
 1439               		.loc 2 48 27 view .LVU234
 1440               	.LBB105:
  50:/usr/avr/include/util/atomic.h ****     return 1;
 1441               		.loc 2 50 5 view .LVU235
 1442               	/* #APP */
 1443               	 ;  50 "/usr/avr/include/util/atomic.h" 1
 1444 0018 F894      		cli
 1445               	 ;  0 "" 2
  51:/usr/avr/include/util/atomic.h **** }
 1446               		.loc 2 51 5 view .LVU236
 1447               	.LVL95:
  51:/usr/avr/include/util/atomic.h **** }
 1448               		.loc 2 51 5 is_stmt 0 view .LVU237
 1449               	/* #NOAPP */
 1450               	.LBE105:
 1451               	.LBE104:
 1452               		.loc 1 636 5 is_stmt 1 view .LVU238
 1453               		.loc 1 636 5 view .LVU239
 1454               	.LBB106:
 1455               	.LBI106:
 132:quantum/split_common/transactions.c ****     memcpy(split_shmem->smatrix.matrix, slave_matrix, sizeof(split_shmem->smatrix.matrix));
 1456               		.loc 1 132 13 view .LVU240
 1457               	.LBB107:
 133:quantum/split_common/transactions.c ****     split_shmem->smatrix.checksum = crc8(split_shmem->smatrix.matrix, sizeof(split_shmem->smatrix.m
 1458               		.loc 1 133 5 view .LVU241
 133:quantum/split_common/transactions.c ****     split_shmem->smatrix.checksum = crc8(split_shmem->smatrix.matrix, sizeof(split_shmem->smatrix.m
 1459               		.loc 1 133 23 is_stmt 0 view .LVU242
 1460 001a 0091 0000 		lds r16,split_shmem
 1461 001e 1091 0000 		lds r17,split_shmem+1
 133:quantum/split_common/transactions.c ****     split_shmem->smatrix.checksum = crc8(split_shmem->smatrix.matrix, sizeof(split_shmem->smatrix.m
 1462               		.loc 1 133 32 view .LVU243
 1463 0022 C801      		movw r24,r16
 1464               	.LVL96:
 133:quantum/split_common/transactions.c ****     split_shmem->smatrix.checksum = crc8(split_shmem->smatrix.matrix, sizeof(split_shmem->smatrix.m
 1465               		.loc 1 133 32 view .LVU244
 1466 0024 0196      		adiw r24,1
 133:quantum/split_common/transactions.c ****     split_shmem->smatrix.checksum = crc8(split_shmem->smatrix.matrix, sizeof(split_shmem->smatrix.m
 1467               		.loc 1 133 5 view .LVU245
 1468 0026 25E0      		ldi r18,lo8(5)
 1469 0028 DC01      		movw r26,r24
 1470               		0:
 1471 002a 0190      		ld r0,Z+
 1472 002c 0D92      		st X+,r0
 1473 002e 2A95      		dec r18
 1474 0030 01F4      		brne 0b
 134:quantum/split_common/transactions.c **** }
 1475               		.loc 1 134 5 is_stmt 1 view .LVU246
 134:quantum/split_common/transactions.c **** }
 1476               		.loc 1 134 37 is_stmt 0 view .LVU247
 1477 0032 65E0      		ldi r22,lo8(5)
 1478 0034 70E0      		ldi r23,0
 1479               	.LVL97:
 134:quantum/split_common/transactions.c **** }
 1480               		.loc 1 134 37 view .LVU248
 1481 0036 0E94 0000 		call crc8
 1482               	.LVL98:
 134:quantum/split_common/transactions.c **** }
 1483               		.loc 1 134 35 view .LVU249
 1484 003a F801      		movw r30,r16
 1485 003c 8083      		st Z,r24
 1486               	.LVL99:
 134:quantum/split_common/transactions.c **** }
 1487               		.loc 1 134 35 view .LVU250
 1488               	.LBE107:
 1489               	.LBE106:
 1490               		.loc 1 636 5 is_stmt 1 view .LVU251
 1491               		.loc 1 636 5 view .LVU252
 1492               	.LBB108:
 1493               	.LBI108:
  54:/usr/avr/include/util/atomic.h **** {
 1494               		.loc 2 54 24 view .LVU253
 1495               	.LBB109:
  56:/usr/avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
 1496               		.loc 2 56 5 view .LVU254
 1497               	/* #APP */
 1498               	 ;  56 "/usr/avr/include/util/atomic.h" 1
 1499 003e 7894      		sei
 1500               	 ;  0 "" 2
  57:/usr/avr/include/util/atomic.h ****     (void)__s;
 1501               		.loc 2 57 5 view .LVU255
 1502               		.loc 2 58 5 view .LVU256
 1503               	.LVL100:
 1504               		.loc 2 58 5 is_stmt 0 view .LVU257
 1505               	/* #NOAPP */
 1506               	.LBE109:
 1507               	.LBE108:
 1508               	.LBE103:
 1509               		.loc 1 636 5 is_stmt 1 view .LVU258
 1510               		.loc 1 636 5 view .LVU259
 637:quantum/split_common/transactions.c ****     TRANSACTIONS_MASTER_MATRIX_SLAVE();
 1511               		.loc 1 637 39 view .LVU260
 638:quantum/split_common/transactions.c ****     TRANSACTIONS_ENCODERS_SLAVE();
 1512               		.loc 1 638 5 view .LVU261
 1513               		.loc 1 638 5 view .LVU262
 1514               	.LBB110:
 1515               		.loc 1 638 5 view .LVU263
 1516               	.LBB111:
 1517               	.LBI111:
  48:/usr/avr/include/util/atomic.h **** {
 1518               		.loc 2 48 27 view .LVU264
 1519               	.LBB112:
  50:/usr/avr/include/util/atomic.h ****     return 1;
 1520               		.loc 2 50 5 view .LVU265
 1521               	/* #APP */
 1522               	 ;  50 "/usr/avr/include/util/atomic.h" 1
 1523 0040 F894      		cli
 1524               	 ;  0 "" 2
  51:/usr/avr/include/util/atomic.h **** }
 1525               		.loc 2 51 5 view .LVU266
 1526               	.LVL101:
  51:/usr/avr/include/util/atomic.h **** }
 1527               		.loc 2 51 5 is_stmt 0 view .LVU267
 1528               	/* #NOAPP */
 1529               	.LBE112:
 1530               	.LBE111:
 1531               		.loc 1 638 5 is_stmt 1 view .LVU268
 1532               		.loc 1 638 5 view .LVU269
 1533               	.LBB113:
 1534               	.LBI113:
 186:quantum/split_common/transactions.c ****     uint8_t encoder_state[NUMBER_OF_ENCODERS];
 1535               		.loc 1 186 13 view .LVU270
 1536               	.LBB114:
 187:quantum/split_common/transactions.c ****     encoder_state_raw(encoder_state);
 1537               		.loc 1 187 5 view .LVU271
 188:quantum/split_common/transactions.c ****     // Always prepare the encoder state for read.
 1538               		.loc 1 188 5 view .LVU272
 1539 0042 CE01      		movw r24,r28
 1540 0044 0196      		adiw r24,1
 1541 0046 0E94 0000 		call encoder_state_raw
 1542               	.LVL102:
 190:quantum/split_common/transactions.c ****     // Now update the checksum given that the encoders has been written to
 1543               		.loc 1 190 5 view .LVU273
 1544 004a 8981      		ldd r24,Y+1
 1545 004c F801      		movw r30,r16
 1546 004e 8783      		std Z+7,r24
 192:quantum/split_common/transactions.c **** }
 1547               		.loc 1 192 5 view .LVU274
 192:quantum/split_common/transactions.c **** }
 1548               		.loc 1 192 38 is_stmt 0 view .LVU275
 1549 0050 61E0      		ldi r22,lo8(1)
 1550 0052 70E0      		ldi r23,0
 1551 0054 CE01      		movw r24,r28
 1552 0056 0196      		adiw r24,1
 1553 0058 0E94 0000 		call crc8
 1554               	.LVL103:
 192:quantum/split_common/transactions.c **** }
 1555               		.loc 1 192 36 view .LVU276
 1556 005c F801      		movw r30,r16
 1557 005e 8683      		std Z+6,r24
 1558               	.LVL104:
 192:quantum/split_common/transactions.c **** }
 1559               		.loc 1 192 36 view .LVU277
 1560               	.LBE114:
 1561               	.LBE113:
 1562               		.loc 1 638 5 is_stmt 1 view .LVU278
 1563               		.loc 1 638 5 view .LVU279
 1564               	.LBB115:
 1565               	.LBI115:
  54:/usr/avr/include/util/atomic.h **** {
 1566               		.loc 2 54 24 view .LVU280
 1567               	.LBB116:
  56:/usr/avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
 1568               		.loc 2 56 5 view .LVU281
 1569               	/* #APP */
 1570               	 ;  56 "/usr/avr/include/util/atomic.h" 1
 1571 0060 7894      		sei
 1572               	 ;  0 "" 2
  57:/usr/avr/include/util/atomic.h ****     (void)__s;
 1573               		.loc 2 57 5 view .LVU282
 1574               		.loc 2 58 5 view .LVU283
 1575               	.LVL105:
 1576               		.loc 2 58 5 is_stmt 0 view .LVU284
 1577               	/* #NOAPP */
 1578               	.LBE116:
 1579               	.LBE115:
 1580               	.LBE110:
 1581               		.loc 1 638 5 is_stmt 1 view .LVU285
 1582               		.loc 1 638 5 view .LVU286
 639:quantum/split_common/transactions.c ****     TRANSACTIONS_SYNC_TIMER_SLAVE();
 1583               		.loc 1 639 5 view .LVU287
 1584               		.loc 1 639 5 view .LVU288
 1585               	.LBB117:
 1586               		.loc 1 639 5 view .LVU289
 1587               	.LBB118:
 1588               	.LBI118:
  48:/usr/avr/include/util/atomic.h **** {
 1589               		.loc 2 48 27 view .LVU290
 1590               	.LBB119:
  50:/usr/avr/include/util/atomic.h ****     return 1;
 1591               		.loc 2 50 5 view .LVU291
 1592               	/* #APP */
 1593               	 ;  50 "/usr/avr/include/util/atomic.h" 1
 1594 0062 F894      		cli
 1595               	 ;  0 "" 2
  51:/usr/avr/include/util/atomic.h **** }
 1596               		.loc 2 51 5 view .LVU292
 1597               	.LVL106:
  51:/usr/avr/include/util/atomic.h **** }
 1598               		.loc 2 51 5 is_stmt 0 view .LVU293
 1599               	/* #NOAPP */
 1600               	.LBE119:
 1601               	.LBE118:
 1602               		.loc 1 639 5 is_stmt 1 view .LVU294
 1603               		.loc 1 639 5 view .LVU295
 1604               	.LBB120:
 1605               	.LBI120:
 230:quantum/split_common/transactions.c ****     static uint32_t last_sync_timer = 0;
 1606               		.loc 1 230 13 view .LVU296
 1607               	.LBB121:
 231:quantum/split_common/transactions.c ****     if (last_sync_timer != split_shmem->sync_timer) {
 1608               		.loc 1 231 5 view .LVU297
 232:quantum/split_common/transactions.c ****         last_sync_timer = split_shmem->sync_timer;
 1609               		.loc 1 232 5 view .LVU298
 232:quantum/split_common/transactions.c ****         last_sync_timer = split_shmem->sync_timer;
 1610               		.loc 1 232 39 is_stmt 0 view .LVU299
 1611 0064 6085      		ldd r22,Z+8
 1612 0066 7185      		ldd r23,Z+9
 1613 0068 8285      		ldd r24,Z+10
 1614 006a 9385      		ldd r25,Z+11
 232:quantum/split_common/transactions.c ****         last_sync_timer = split_shmem->sync_timer;
 1615               		.loc 1 232 8 view .LVU300
 1616 006c C090 0000 		lds r12,last_sync_timer.0
 1617 0070 D090 0000 		lds r13,last_sync_timer.0+1
 1618 0074 E090 0000 		lds r14,last_sync_timer.0+2
 1619 0078 F090 0000 		lds r15,last_sync_timer.0+3
 1620 007c 6C15      		cp r22,r12
 1621 007e 7D05      		cpc r23,r13
 1622 0080 8E05      		cpc r24,r14
 1623 0082 9F05      		cpc r25,r15
 1624 0084 01F0      		breq .L69
 233:quantum/split_common/transactions.c ****         sync_timer_update(last_sync_timer);
 1625               		.loc 1 233 9 is_stmt 1 view .LVU301
 233:quantum/split_common/transactions.c ****         sync_timer_update(last_sync_timer);
 1626               		.loc 1 233 25 is_stmt 0 view .LVU302
 1627 0086 6093 0000 		sts last_sync_timer.0,r22
 1628 008a 7093 0000 		sts last_sync_timer.0+1,r23
 1629 008e 8093 0000 		sts last_sync_timer.0+2,r24
 1630 0092 9093 0000 		sts last_sync_timer.0+3,r25
 234:quantum/split_common/transactions.c ****     }
 1631               		.loc 1 234 9 is_stmt 1 view .LVU303
 1632 0096 0E94 0000 		call sync_timer_update
 1633               	.LVL107:
 1634               	.L69:
 234:quantum/split_common/transactions.c ****     }
 1635               		.loc 1 234 9 is_stmt 0 view .LVU304
 1636               	.LBE121:
 1637               	.LBE120:
 1638               		.loc 1 639 5 is_stmt 1 view .LVU305
 1639               		.loc 1 639 5 view .LVU306
 1640               	.LBB122:
 1641               	.LBI122:
  54:/usr/avr/include/util/atomic.h **** {
 1642               		.loc 2 54 24 view .LVU307
 1643               	.LBB123:
  56:/usr/avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
 1644               		.loc 2 56 5 view .LVU308
 1645               	/* #APP */
 1646               	 ;  56 "/usr/avr/include/util/atomic.h" 1
 1647 009a 7894      		sei
 1648               	 ;  0 "" 2
  57:/usr/avr/include/util/atomic.h ****     (void)__s;
 1649               		.loc 2 57 5 view .LVU309
 1650               		.loc 2 58 5 view .LVU310
 1651               	.LVL108:
 1652               		.loc 2 58 5 is_stmt 0 view .LVU311
 1653               	/* #NOAPP */
 1654               	.LBE123:
 1655               	.LBE122:
 1656               	.LBE117:
 1657               		.loc 1 639 5 is_stmt 1 view .LVU312
 1658               		.loc 1 639 5 view .LVU313
 640:quantum/split_common/transactions.c ****     TRANSACTIONS_LAYER_STATE_SLAVE();
 1659               		.loc 1 640 5 view .LVU314
 1660               		.loc 1 640 5 view .LVU315
 1661               	.LBB124:
 1662               		.loc 1 640 5 view .LVU316
 1663               	.LBB125:
 1664               	.LBI125:
  48:/usr/avr/include/util/atomic.h **** {
 1665               		.loc 2 48 27 view .LVU317
 1666               	.LBB126:
  50:/usr/avr/include/util/atomic.h ****     return 1;
 1667               		.loc 2 50 5 view .LVU318
 1668               	/* #APP */
 1669               	 ;  50 "/usr/avr/include/util/atomic.h" 1
 1670 009c F894      		cli
 1671               	 ;  0 "" 2
  51:/usr/avr/include/util/atomic.h **** }
 1672               		.loc 2 51 5 view .LVU319
 1673               	.LVL109:
  51:/usr/avr/include/util/atomic.h **** }
 1674               		.loc 2 51 5 is_stmt 0 view .LVU320
 1675               	/* #NOAPP */
 1676               	.LBE126:
 1677               	.LBE125:
 1678               		.loc 1 640 5 is_stmt 1 view .LVU321
 1679               		.loc 1 640 5 view .LVU322
 1680               	.LBB127:
 1681               	.LBI127:
 266:quantum/split_common/transactions.c ****     layer_state         = split_shmem->layers.layer_state;
 1682               		.loc 1 266 13 view .LVU323
 1683               	.LBB128:
 267:quantum/split_common/transactions.c ****     default_layer_state = split_shmem->layers.default_layer_state;
 1684               		.loc 1 267 5 view .LVU324
 267:quantum/split_common/transactions.c ****     default_layer_state = split_shmem->layers.default_layer_state;
 1685               		.loc 1 267 25 is_stmt 0 view .LVU325
 1686 009e F801      		movw r30,r16
 1687 00a0 8485      		ldd r24,Z+12
 1688 00a2 9585      		ldd r25,Z+13
 1689 00a4 A685      		ldd r26,Z+14
 1690 00a6 B785      		ldd r27,Z+15
 1691 00a8 8093 0000 		sts layer_state,r24
 1692 00ac 9093 0000 		sts layer_state+1,r25
 1693 00b0 A093 0000 		sts layer_state+2,r26
 1694 00b4 B093 0000 		sts layer_state+3,r27
 268:quantum/split_common/transactions.c **** }
 1695               		.loc 1 268 5 is_stmt 1 view .LVU326
 268:quantum/split_common/transactions.c **** }
 1696               		.loc 1 268 25 is_stmt 0 view .LVU327
 1697 00b8 8089      		ldd r24,Z+16
 1698 00ba 9189      		ldd r25,Z+17
 1699 00bc A289      		ldd r26,Z+18
 1700 00be B389      		ldd r27,Z+19
 1701 00c0 8093 0000 		sts default_layer_state,r24
 1702 00c4 9093 0000 		sts default_layer_state+1,r25
 1703 00c8 A093 0000 		sts default_layer_state+2,r26
 1704 00cc B093 0000 		sts default_layer_state+3,r27
 1705               	.LVL110:
 268:quantum/split_common/transactions.c **** }
 1706               		.loc 1 268 25 view .LVU328
 1707               	.LBE128:
 1708               	.LBE127:
 1709               		.loc 1 640 5 is_stmt 1 view .LVU329
 1710               		.loc 1 640 5 view .LVU330
 1711               	.LBB129:
 1712               	.LBI129:
  54:/usr/avr/include/util/atomic.h **** {
 1713               		.loc 2 54 24 view .LVU331
 1714               	.LBB130:
  56:/usr/avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
 1715               		.loc 2 56 5 view .LVU332
 1716               	/* #APP */
 1717               	 ;  56 "/usr/avr/include/util/atomic.h" 1
 1718 00d0 7894      		sei
 1719               	 ;  0 "" 2
  57:/usr/avr/include/util/atomic.h ****     (void)__s;
 1720               		.loc 2 57 5 view .LVU333
 1721               		.loc 2 58 5 view .LVU334
 1722               	.LVL111:
 1723               		.loc 2 58 5 is_stmt 0 view .LVU335
 1724               	/* #NOAPP */
 1725               	.LBE130:
 1726               	.LBE129:
 1727               	.LBE124:
 1728               		.loc 1 640 5 is_stmt 1 view .LVU336
 1729               		.loc 1 640 5 view .LVU337
 641:quantum/split_common/transactions.c ****     TRANSACTIONS_LED_STATE_SLAVE();
 1730               		.loc 1 641 35 view .LVU338
 642:quantum/split_common/transactions.c ****     TRANSACTIONS_MODS_SLAVE();
 1731               		.loc 1 642 30 view .LVU339
 643:quantum/split_common/transactions.c ****     TRANSACTIONS_BACKLIGHT_SLAVE();
 1732               		.loc 1 643 35 view .LVU340
 644:quantum/split_common/transactions.c ****     TRANSACTIONS_RGBLIGHT_SLAVE();
 1733               		.loc 1 644 34 view .LVU341
 645:quantum/split_common/transactions.c ****     TRANSACTIONS_LED_MATRIX_SLAVE();
 1734               		.loc 1 645 36 view .LVU342
 646:quantum/split_common/transactions.c ****     TRANSACTIONS_RGB_MATRIX_SLAVE();
 1735               		.loc 1 646 36 view .LVU343
 647:quantum/split_common/transactions.c ****     TRANSACTIONS_WPM_SLAVE();
 1736               		.loc 1 647 29 view .LVU344
 648:quantum/split_common/transactions.c ****     TRANSACTIONS_OLED_SLAVE();
 1737               		.loc 1 648 5 view .LVU345
 1738               		.loc 1 648 5 view .LVU346
 1739               	.LBB131:
 1740               		.loc 1 648 5 view .LVU347
 1741               	.LBB132:
 1742               	.LBI132:
  48:/usr/avr/include/util/atomic.h **** {
 1743               		.loc 2 48 27 view .LVU348
 1744               	.LBB133:
  50:/usr/avr/include/util/atomic.h ****     return 1;
 1745               		.loc 2 50 5 view .LVU349
 1746               	/* #APP */
 1747               	 ;  50 "/usr/avr/include/util/atomic.h" 1
 1748 00d2 F894      		cli
 1749               	 ;  0 "" 2
  51:/usr/avr/include/util/atomic.h **** }
 1750               		.loc 2 51 5 view .LVU350
 1751               	.LVL112:
  51:/usr/avr/include/util/atomic.h **** }
 1752               		.loc 2 51 5 is_stmt 0 view .LVU351
 1753               	/* #NOAPP */
 1754               	.LBE133:
 1755               	.LBE132:
 1756               		.loc 1 648 5 is_stmt 1 view .LVU352
 1757               		.loc 1 648 5 view .LVU353
 1758               	.LBB134:
 1759               	.LBI134:
 530:quantum/split_common/transactions.c ****     if (split_shmem->current_oled_state) {
 1760               		.loc 1 530 13 view .LVU354
 1761               	.LBB135:
 531:quantum/split_common/transactions.c ****         oled_on();
 1762               		.loc 1 531 5 view .LVU355
 531:quantum/split_common/transactions.c ****         oled_on();
 1763               		.loc 1 531 8 is_stmt 0 view .LVU356
 1764 00d4 8489      		ldd r24,Z+20
 1765 00d6 8823      		tst r24
 1766 00d8 01F0      		breq .L70
 532:quantum/split_common/transactions.c ****     } else {
 1767               		.loc 1 532 9 is_stmt 1 view .LVU357
 1768 00da 0E94 0000 		call oled_on
 1769               	.LVL113:
 1770               	.L71:
 532:quantum/split_common/transactions.c ****     } else {
 1771               		.loc 1 532 9 is_stmt 0 view .LVU358
 1772               	.LBE135:
 1773               	.LBE134:
 1774               		.loc 1 648 5 is_stmt 1 view .LVU359
 1775               		.loc 1 648 5 view .LVU360
 1776               	.LBB137:
 1777               	.LBI137:
  54:/usr/avr/include/util/atomic.h **** {
 1778               		.loc 2 54 24 view .LVU361
 1779               	.LBB138:
  56:/usr/avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
 1780               		.loc 2 56 5 view .LVU362
 1781               	/* #APP */
 1782               	 ;  56 "/usr/avr/include/util/atomic.h" 1
 1783 00de 7894      		sei
 1784               	 ;  0 "" 2
  57:/usr/avr/include/util/atomic.h ****     (void)__s;
 1785               		.loc 2 57 5 view .LVU363
 1786               		.loc 2 58 5 view .LVU364
 1787               	.LVL114:
 1788               		.loc 2 58 5 is_stmt 0 view .LVU365
 1789               	/* #NOAPP */
 1790               	.LBE138:
 1791               	.LBE137:
 1792               	.LBE131:
 1793               		.loc 1 648 5 is_stmt 1 view .LVU366
 1794               		.loc 1 648 5 view .LVU367
 649:quantum/split_common/transactions.c ****     TRANSACTIONS_ST7565_SLAVE();
 1795               		.loc 1 649 32 view .LVU368
 1796               	/* epilogue start */
 650:quantum/split_common/transactions.c **** }
 1797               		.loc 1 650 1 is_stmt 0 view .LVU369
 1798 00e0 0F90      		pop __tmp_reg__
 1799 00e2 DF91      		pop r29
 1800 00e4 CF91      		pop r28
 1801 00e6 1F91      		pop r17
 1802 00e8 0F91      		pop r16
 1803 00ea FF90      		pop r15
 1804 00ec EF90      		pop r14
 1805 00ee DF90      		pop r13
 1806 00f0 CF90      		pop r12
 1807 00f2 0895      		ret
 1808               	.LVL115:
 1809               	.L70:
 1810               	.LBB140:
 1811               	.LBB139:
 1812               	.LBB136:
 534:quantum/split_common/transactions.c ****     }
 1813               		.loc 1 534 9 is_stmt 1 view .LVU370
 1814 00f4 0E94 0000 		call oled_off
 1815               	.LVL116:
 1816 00f8 00C0      		rjmp .L71
 1817               	.LBE136:
 1818               	.LBE139:
 1819               	.LBE140:
 1820               		.cfi_endproc
 1821               	.LFE42:
 1823               		.section	.bss.last_sync_timer.0,"aw",@nobits
 1826               	last_sync_timer.0:
 1827 0000 0000 0000 		.zero	4
 1828               		.section	.progmem.data.__c.1,"a"
 1831               	__c.1:
 1832 0000 4661 696C 		.string	"Failed to execute %s\n"
 1832      6564 2074 
 1832      6F20 6578 
 1832      6563 7574 
 1832      6520 2573 
 1833               		.section	.bss.last_matrix.2,"aw",@nobits
 1836               	last_matrix.2:
 1837 0000 0000 0000 		.zero	5
 1837      00
 1838               		.section	.bss.last_update.3,"aw",@nobits
 1841               	last_update.3:
 1842 0000 0000 0000 		.zero	4
 1843               		.section	.bss.last_update.4,"aw",@nobits
 1846               	last_update.4:
 1847 0000 0000 0000 		.zero	4
 1848               		.section	.bss.last_update.5,"aw",@nobits
 1851               	last_update.5:
 1852 0000 0000 0000 		.zero	4
 1853               		.section	.bss.last_default_layer_state_update.6,"aw",@nobits
 1856               	last_default_layer_state_update.6:
 1857 0000 0000 0000 		.zero	4
 1858               		.section	.bss.last_layer_state_update.7,"aw",@nobits
 1861               	last_layer_state_update.7:
 1862 0000 0000 0000 		.zero	4
 1863               		.section	.bss.last_update.8,"aw",@nobits
 1866               	last_update.8:
 1867 0000 0000 0000 		.zero	4
 1868               	.global	split_transaction_table
 1869               		.section	.data.split_transaction_table,"aw"
 1872               	split_transaction_table:
 1873 0000 0000      		.word	dummy
 1874 0002 00        		.byte	0
 1875 0003 0000      		.word	0
 1876 0005 01        		.byte	1
 1877 0006 0000      		.word	0
 1878 0008 0000      		.word	0
 1879 000a 0000      		.word	dummy
 1880 000c 00        		.byte	0
 1881 000d 0000      		.word	0
 1882 000f 05        		.byte	5
 1883 0010 0100      		.word	1
 1884 0012 0000      		.word	0
 1885 0014 0000      		.word	dummy
 1886 0016 00        		.byte	0
 1887 0017 0000      		.word	0
 1888 0019 01        		.byte	1
 1889 001a 0600      		.word	6
 1890 001c 0000      		.word	0
 1891 001e 0000      		.word	dummy
 1892 0020 00        		.byte	0
 1893 0021 0000      		.word	0
 1894 0023 01        		.byte	1
 1895 0024 0700      		.word	7
 1896 0026 0000      		.word	0
 1897 0028 0000      		.word	dummy
 1898 002a 04        		.byte	4
 1899 002b 0800      		.word	8
 1900 002d 00        		.byte	0
 1901 002e 0000      		.word	0
 1902 0030 0000      		.word	0
 1903 0032 0000      		.word	dummy
 1904 0034 04        		.byte	4
 1905 0035 0C00      		.word	12
 1906 0037 00        		.byte	0
 1907 0038 0000      		.word	0
 1908 003a 0000      		.word	0
 1909 003c 0000      		.word	dummy
 1910 003e 04        		.byte	4
 1911 003f 1000      		.word	16
 1912 0041 00        		.byte	0
 1913 0042 0000      		.word	0
 1914 0044 0000      		.word	0
 1915 0046 0000      		.word	dummy
 1916 0048 01        		.byte	1
 1917 0049 1400      		.word	20
 1918 004b 00        		.byte	0
 1919 004c 0000      		.word	0
 1920 004e 0000      		.word	0
 1921               		.comm	dummy,1,1
 1922               		.weak	crc8
 1923               		.text
 1924               	.Letext0:
 1925               		.file 4 "/usr/avr/include/stdint.h"
 1926               		.file 5 "/usr/lib/gcc/avr/11.2.0/include/stddef.h"
 1927               		.file 6 "quantum/matrix.h"
 1928               		.file 7 "quantum/logging/debug.h"
 1929               		.file 8 "quantum/action_layer.h"
 1930               		.file 9 "tmk_core/common/avr/gpio.h"
 1931               		.file 10 "quantum/split_common/transport.h"
 1932               		.file 11 "quantum/split_common/transactions.h"
 1933               		.file 12 "drivers/oled/oled_driver.h"
 1934               		.file 13 "tmk_core/common/sync_timer.h"
 1935               		.file 14 "quantum/encoder.h"
 1936               		.file 15 "tmk_core/common/avr/xprintf.h"
 1937               		.file 16 "quantum/split_common/split_util.h"
 1938               		.file 17 "/usr/avr/include/math.h"
 1939               		.file 18 "/usr/avr/include/string.h"
 1940               		.file 19 "quantum/crc.h"
 1941               		.file 20 "tmk_core/common/timer.h"
 1942               		.file 21 "quantum/sequencer/sequencer.h"
 1943               		.file 22 "quantum/split_common/transaction_id_define.h"
 1944               		.file 23 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 transactions.c
     /tmp/cc16uhXM.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc16uhXM.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc16uhXM.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc16uhXM.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc16uhXM.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc16uhXM.s:12     .text.sync_timer_handlers_master:0000000000000000 sync_timer_handlers_master
     /tmp/cc16uhXM.s:1851   .bss.last_update.5:0000000000000000 last_update.5
     /tmp/cc16uhXM.s:143    .text.transaction_handler_master:0000000000000000 transaction_handler_master
     /tmp/cc16uhXM.s:1831   .progmem.data.__c.1:0000000000000000 __c.1
     /tmp/cc16uhXM.s:418    .text.send_if_condition:0000000000000000 send_if_condition
     /tmp/cc16uhXM.s:591    .text.oled_handlers_master:0000000000000000 oled_handlers_master
     /tmp/cc16uhXM.s:1866   .bss.last_update.8:0000000000000000 last_update.8
     /tmp/cc16uhXM.s:667    .text.layer_state_handlers_master:0000000000000000 layer_state_handlers_master
     /tmp/cc16uhXM.s:1861   .bss.last_layer_state_update.7:0000000000000000 last_layer_state_update.7
     /tmp/cc16uhXM.s:1856   .bss.last_default_layer_state_update.6:0000000000000000 last_default_layer_state_update.6
     /tmp/cc16uhXM.s:776    .text.read_if_checksum_mismatch:0000000000000000 read_if_checksum_mismatch
     /tmp/cc16uhXM.s:1018   .text.encoder_handlers_master:0000000000000000 encoder_handlers_master
     /tmp/cc16uhXM.s:1846   .bss.last_update.4:0000000000000000 last_update.4
     /tmp/cc16uhXM.s:1115   .text.slave_matrix_handlers_master:0000000000000000 slave_matrix_handlers_master
     /tmp/cc16uhXM.s:1841   .bss.last_update.3:0000000000000000 last_update.3
     /tmp/cc16uhXM.s:1836   .bss.last_matrix.2:0000000000000000 last_matrix.2
     /tmp/cc16uhXM.s:1255   .text.transactions_master:0000000000000000 transactions_master
     /tmp/cc16uhXM.s:1382   .text.transactions_slave:0000000000000000 transactions_slave
     /tmp/cc16uhXM.s:1826   .bss.last_sync_timer.0:0000000000000000 last_sync_timer.0
     /tmp/cc16uhXM.s:1872   .data.split_transaction_table:0000000000000000 split_transaction_table
                            *COM*:0000000000000001 dummy

UNDEFINED SYMBOLS
timer_elapsed32
sync_timer_read32
transport_execute_transaction
timer_read32
is_transport_connected
debug_config
__xprintf
is_oled_on
split_shmem
layer_state
default_layer_state
crc8
memcpy
encoder_update_raw
encoder_state_raw
sync_timer_update
oled_on
oled_off
__do_copy_data
__do_clear_bss
